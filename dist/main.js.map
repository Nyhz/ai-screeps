{
  "version": 3,
  "sources": ["../src/main.ts", "../src/roles/builder.ts", "../src/utils.ts", "../src/roles/harvester.ts", "../src/roles/upgrader.ts", "../src/roomManager.ts", "../src/spawnManager.ts", "../src/towerManager.ts"],
  "sourcesContent": ["import { runBuilder } from \"./roles/builder\";\nimport { runHarvester } from \"./roles/harvester\";\nimport { runUpgrader } from \"./roles/upgrader\";\nimport { runRooms } from \"./roomManager\";\nimport { runSpawns } from \"./spawnManager\";\nimport { runTowers } from \"./towerManager\";\nimport { cleanupMemory } from \"./utils\";\n\nfunction runCreep(creep: Creep): void {\n  if (creep.memory.role === \"harvester\") {\n    runHarvester(creep);\n    return;\n  }\n  if (creep.memory.role === \"upgrader\") {\n    runUpgrader(creep);\n    return;\n  }\n  if (creep.memory.role === \"builder\") {\n    runBuilder(creep);\n  }\n}\n\nexport const loop = (): void => {\n  cleanupMemory();\n  runRooms();\n  runSpawns();\n  runTowers();\n\n  for (const name in Game.creeps) {\n    runCreep(Game.creeps[name]);\n  }\n};\n", "export function runBuilder(creep: Creep): void {\n  if (creep.memory.working && creep.store[RESOURCE_ENERGY] === 0) {\n    creep.memory.working = false;\n  }\n  if (!creep.memory.working && creep.store.getFreeCapacity() === 0) {\n    creep.memory.working = true;\n  }\n\n  if (creep.memory.working) {\n    const site = creep.pos.findClosestByPath(FIND_CONSTRUCTION_SITES);\n    if (site) {\n      if (creep.build(site) === ERR_NOT_IN_RANGE) {\n        creep.moveTo(site, { visualizePathStyle: { stroke: \"#ab47bc\" } });\n      }\n      return;\n    }\n\n    const controller = creep.room.controller;\n    if (!controller) return;\n    if (creep.upgradeController(controller) === ERR_NOT_IN_RANGE) {\n      creep.moveTo(controller, { visualizePathStyle: { stroke: \"#66bb6a\" } });\n    }\n    return;\n  }\n\n  const container = creep.pos.findClosestByPath(FIND_STRUCTURES, {\n    filter: (structure: Structure) =>\n      (structure.structureType === STRUCTURE_CONTAINER ||\n        structure.structureType === STRUCTURE_STORAGE) &&\n      (structure as StructureContainer | StructureStorage).store.getUsedCapacity(RESOURCE_ENERGY) > 0\n  }) as StructureContainer | StructureStorage | null;\n\n  if (container) {\n    if (creep.withdraw(container, RESOURCE_ENERGY) === ERR_NOT_IN_RANGE) {\n      creep.moveTo(container, { visualizePathStyle: { stroke: \"#ffa726\" } });\n    }\n    return;\n  }\n\n  const source = creep.pos.findClosestByPath(FIND_SOURCES_ACTIVE);\n  if (!source) return;\n  if (creep.harvest(source) === ERR_NOT_IN_RANGE) {\n    creep.moveTo(source, { visualizePathStyle: { stroke: \"#ffa726\" } });\n  }\n}\n", "export function countRole(role: CreepMemory[\"role\"]): number {\n  return _.filter(Game.creeps, (creep) => creep.memory.role === role).length;\n}\n\nexport function nearestEnergyTarget(creep: Creep): StructureSpawn | StructureExtension | StructureTower | null {\n  const target = creep.pos.findClosestByPath(FIND_STRUCTURES, {\n    filter: (structure: Structure) =>\n      (structure.structureType === STRUCTURE_SPAWN ||\n        structure.structureType === STRUCTURE_EXTENSION ||\n        structure.structureType === STRUCTURE_TOWER) &&\n      (structure as StructureSpawn | StructureExtension | StructureTower).store.getFreeCapacity(RESOURCE_ENERGY) > 0\n  });\n\n  if (!target) return null;\n  return target as StructureSpawn | StructureExtension | StructureTower;\n}\n\nexport function cleanupMemory(): void {\n  for (const name in Memory.creeps) {\n    if (!Game.creeps[name]) {\n      delete Memory.creeps[name];\n    }\n  }\n}\n", "import { nearestEnergyTarget } from \"../utils\";\n\nexport function runHarvester(creep: Creep): void {\n  if (creep.store.getFreeCapacity() > 0) {\n    const source = creep.pos.findClosestByPath(FIND_SOURCES_ACTIVE);\n    if (!source) return;\n\n    if (creep.harvest(source) === ERR_NOT_IN_RANGE) {\n      creep.moveTo(source, { visualizePathStyle: { stroke: \"#f5c542\" } });\n    }\n    return;\n  }\n\n  const target = nearestEnergyTarget(creep);\n  if (!target) {\n    const controller = creep.room.controller;\n    if (!controller) return;\n    if (creep.upgradeController(controller) === ERR_NOT_IN_RANGE) {\n      creep.moveTo(controller, { visualizePathStyle: { stroke: \"#ffffff\" } });\n    }\n    return;\n  }\n\n  if (creep.transfer(target, RESOURCE_ENERGY) === ERR_NOT_IN_RANGE) {\n    creep.moveTo(target, { visualizePathStyle: { stroke: \"#42a5f5\" } });\n  }\n}\n", "export function runUpgrader(creep: Creep): void {\n  const controller = creep.room.controller;\n  if (!controller) return;\n\n  if (creep.memory.working && creep.store[RESOURCE_ENERGY] === 0) {\n    creep.memory.working = false;\n  }\n  if (!creep.memory.working && creep.store.getFreeCapacity() === 0) {\n    creep.memory.working = true;\n  }\n\n  if (creep.memory.working) {\n    if (creep.upgradeController(controller) === ERR_NOT_IN_RANGE) {\n      creep.moveTo(controller, { visualizePathStyle: { stroke: \"#66bb6a\" } });\n    }\n    return;\n  }\n\n  const container = creep.pos.findClosestByPath(FIND_STRUCTURES, {\n    filter: (structure: Structure) =>\n      (structure.structureType === STRUCTURE_CONTAINER ||\n        structure.structureType === STRUCTURE_STORAGE) &&\n      (structure as StructureContainer | StructureStorage).store.getUsedCapacity(RESOURCE_ENERGY) > 0\n  }) as StructureContainer | StructureStorage | null;\n\n  if (container) {\n    if (creep.withdraw(container, RESOURCE_ENERGY) === ERR_NOT_IN_RANGE) {\n      creep.moveTo(container, { visualizePathStyle: { stroke: \"#ffa726\" } });\n    }\n    return;\n  }\n\n  const source = creep.pos.findClosestByPath(FIND_SOURCES_ACTIVE);\n  if (!source) return;\n  if (creep.harvest(source) === ERR_NOT_IN_RANGE) {\n    creep.moveTo(source, { visualizePathStyle: { stroke: \"#ffa726\" } });\n  }\n}\n", "function placeIfPossible(room: Room, x: number, y: number, structureType: BuildableStructureConstant): void {\n  if (x < 1 || x > 48 || y < 1 || y > 48) return;\n  room.createConstructionSite(x, y, structureType);\n}\n\nfunction stampExtensionsAroundSpawn(spawn: StructureSpawn): void {\n  const room = spawn.room;\n  const center = spawn.pos;\n\n  const offsets: Array<[number, number]> = [\n    [2, 0],\n    [-2, 0],\n    [0, 2],\n    [0, -2],\n    [2, 2],\n    [2, -2],\n    [-2, 2],\n    [-2, -2],\n    [3, 1],\n    [3, -1]\n  ];\n\n  for (const [dx, dy] of offsets) {\n    placeIfPossible(room, center.x + dx, center.y + dy, STRUCTURE_EXTENSION);\n  }\n}\n\nfunction connectSpawnToController(spawn: StructureSpawn): void {\n  const controller = spawn.room.controller;\n  if (!controller) return;\n  const path = spawn.pos.findPathTo(controller.pos, { ignoreCreeps: true });\n  for (const step of path) {\n    spawn.room.createConstructionSite(step.x, step.y, STRUCTURE_ROAD);\n  }\n}\n\nfunction placeSourceContainers(spawn: StructureSpawn): void {\n  const sources = spawn.room.find(FIND_SOURCES);\n  for (const source of sources) {\n    const path = spawn.pos.findPathTo(source.pos, { ignoreCreeps: true });\n    const end = path[path.length - 1];\n    if (end) {\n      spawn.room.createConstructionSite(end.x, end.y, STRUCTURE_CONTAINER);\n    }\n  }\n}\n\nexport function runRooms(): void {\n  if (Game.time % 53 !== 0) return;\n\n  const spawns = Object.values(Game.spawns);\n  for (const spawn of spawns) {\n    const room = spawn.room;\n    const rcl = room.controller?.level ?? 0;\n    const sites = room.find(FIND_CONSTRUCTION_SITES);\n    if (sites.length > 6) continue;\n\n    if (rcl >= 2) {\n      stampExtensionsAroundSpawn(spawn);\n      placeSourceContainers(spawn);\n    }\n\n    if (rcl >= 3) {\n      placeIfPossible(room, spawn.pos.x + 3, spawn.pos.y, STRUCTURE_TOWER);\n      connectSpawnToController(spawn);\n    }\n  }\n}\n", "import { countRole } from \"./utils\";\n\nconst BODY_BY_ROLE: Record<CreepMemory[\"role\"], BodyPartConstant[]> = {\n  harvester: [WORK, WORK, CARRY, MOVE],\n  upgrader: [WORK, CARRY, CARRY, MOVE, MOVE],\n  builder: [WORK, CARRY, CARRY, MOVE, MOVE]\n};\n\nexport function runSpawns(): void {\n  const spawns = Object.values(Game.spawns);\n  for (const spawn of spawns) {\n    if (spawn.spawning) continue;\n\n    const harvesterCount = countRole(\"harvester\");\n    const upgraderCount = countRole(\"upgrader\");\n    const builderCount = countRole(\"builder\");\n\n    const sites = spawn.room.find(FIND_CONSTRUCTION_SITES);\n    const targetBuilders = sites.length > 0 ? 2 : 1;\n\n    let nextRole: CreepMemory[\"role\"] | null = null;\n    if (harvesterCount < 3) nextRole = \"harvester\";\n    else if (upgraderCount < 3) nextRole = \"upgrader\";\n    else if (builderCount < targetBuilders) nextRole = \"builder\";\n\n    if (!nextRole) continue;\n\n    const name = `${nextRole}-${Game.time}`;\n    const body = BODY_BY_ROLE[nextRole];\n    spawn.spawnCreep(body, name, { memory: { role: nextRole, working: false } });\n  }\n}\n", "export function runTowers(): void {\n  const towers = _.filter(\n    Object.values(Game.structures),\n    (structure): structure is StructureTower => structure.structureType === STRUCTURE_TOWER\n  );\n\n  for (const tower of towers) {\n    const closestHostile = tower.pos.findClosestByRange(FIND_HOSTILE_CREEPS);\n    if (closestHostile) {\n      tower.attack(closestHostile);\n      continue;\n    }\n\n    const mostDamaged = tower.pos.findClosestByRange(FIND_STRUCTURES, {\n      filter: (structure: Structure) =>\n        structure.hits < structure.hitsMax &&\n        structure.hits < 200000 &&\n        structure.structureType !== STRUCTURE_WALL\n    });\n\n    if (mostDamaged) {\n      tower.repair(mostDamaged);\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
