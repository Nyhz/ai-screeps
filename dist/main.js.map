{
  "version": 3,
  "sources": ["../src/main.ts", "../src/config/roles.ts", "../src/colony/intel.ts", "../src/config/settings.ts", "../src/colony/spawnPlanner.ts", "../src/config/colonyStages.ts", "../src/colony/stageManager.ts", "../src/colony/strategyManager.ts", "../src/managers/colonyManager.ts", "../src/managers/constructionManager.ts", "../src/managers/defenseManager.ts", "../src/config/bodyPlans.ts", "../src/utils.ts", "../src/managers/spawnManager.ts", "../src/tasks/movement.ts", "../src/tasks/work.ts", "../src/tasks/energy.ts", "../src/roles/common.ts", "../src/roles/builder.ts", "../src/tasks/combat.ts", "../src/roles/claimer.ts", "../src/roles/harvester.ts", "../src/roles/hauler.ts", "../src/roles/miner.ts", "../src/roles/repairer.ts", "../src/roles/reserver.ts", "../src/roles/scout.ts", "../src/roles/soldier.ts", "../src/roles/upgrader.ts", "../src/roles/waller.ts", "../src/roles/index.ts"],
  "sourcesContent": ["import { runColonyManager } from \"./managers/colonyManager\";\nimport { runConstructionManager } from \"./managers/constructionManager\";\nimport { runDefenseManager } from \"./managers/defenseManager\";\nimport { runSpawnManager } from \"./managers/spawnManager\";\nimport { runRole } from \"./roles\";\nimport { cleanupMemory } from \"./utils\";\n\nexport const loop = (): void => {\n  cleanupMemory();\n\n  runColonyManager();\n  runSpawnManager();\n  runConstructionManager();\n  runDefenseManager();\n\n  for (const creep of Object.values(Game.creeps)) {\n    runRole(creep);\n  }\n};\r\n", "export const ROLE_ORDER = [\n  \"harvester\",\n  \"hauler\",\n  \"miner\",\n  \"upgrader\",\n  \"builder\",\n  \"repairer\",\n  \"waller\",\n  \"scout\",\n  \"reserver\",\n  \"claimer\",\n  \"soldier\"\n] as const;\n\nexport type RoleName = (typeof ROLE_ORDER)[number];\n\nexport const CORE_ROLES: RoleName[] = [\"harvester\", \"hauler\", \"upgrader\", \"builder\"];\n\nexport const COMBAT_ROLES: RoleName[] = [\"soldier\"];\r\n", "import { ROLE_ORDER, type RoleName } from \"../config/roles\";\nimport type { RoomSnapshot } from \"./types\";\n\nfunction emptyRoleCounts(): Record<RoleName, number> {\n  const counts = {} as Record<RoleName, number>;\n  for (const role of ROLE_ORDER) {\n    counts[role] = 0;\n  }\n  return counts;\n}\n\nexport function collectRoomSnapshot(room: Room): RoomSnapshot {\n  const creepsByRole = emptyRoleCounts();\n  for (const creep of Object.values(Game.creeps)) {\n    if (creep.memory.homeRoom !== room.name) continue;\n    creepsByRole[creep.memory.role] += 1;\n  }\n\n  const structures = room.find(FIND_STRUCTURES);\n  const structuresByType: Partial<Record<StructureConstant, number>> = {};\n  for (const structure of structures) {\n    structuresByType[structure.structureType] = (structuresByType[structure.structureType] ?? 0) + 1;\n  }\n\n  const storageEnergy = room.storage?.store.getUsedCapacity(RESOURCE_ENERGY) ?? 0;\n  const controller = room.controller;\n\n  return {\n    roomName: room.name,\n    rcl: controller?.level ?? 0,\n    energyAvailable: room.energyAvailable,\n    energyCapacityAvailable: room.energyCapacityAvailable,\n    sourceCount: room.find(FIND_SOURCES).length,\n    constructionSiteCount: room.find(FIND_CONSTRUCTION_SITES).length,\n    hostileCount: room.find(FIND_HOSTILE_CREEPS).length,\n    storageEnergy,\n    structuresByType,\n    creepsByRole\n  };\n}\r\n", "import type { ColonyStage } from \"./colonyStages\";\nimport type { RoleName } from \"./roles\";\n\ntype RoleTargetOverrides = Partial<Record<RoleName, number>>;\n\nexport interface RoomControlSettings {\n  roleTargets?: RoleTargetOverrides;\n  roleTargetsByStage?: Partial<Record<ColonyStage, RoleTargetOverrides>>;\n  disablePvP?: boolean;\n  noAttackRooms?: string[];\n  remoteRoomAllowlist?: string[];\n  remoteRoomBlocklist?: string[];\n}\n\ninterface ResolvedRoomControlSettings {\n  roleTargets: RoleTargetOverrides;\n  roleTargetsByStage: Partial<Record<ColonyStage, RoleTargetOverrides>>;\n  disablePvP: boolean;\n  noAttackRooms: string[];\n  remoteRoomAllowlist?: string[];\n  remoteRoomBlocklist: string[];\n}\n\nexport const COLONY_SETTINGS = {\n  pvp: {\n    enabled: false,\n    noAttackRooms: [] as string[]\n  },\n  stage: {\n    towersMinRcl: 3,\n    wallsMinRcl: 4,\n    remoteMiningMinRcl: 3,\n    remoteMiningMinEnergyCapacity: 800,\n    expansionMinRcl: 4,\n    offenseMinRcl: 6,\n    offenseMinStorageEnergy: 100000\n  },\n  planner: {\n    minHarvesters: 2,\n    baseHaulers: 1,\n    baseUpgraders: 1,\n    buildersWhenSitesExist: 2,\n    buildersWhenNoSites: 1,\n    heavyBuildSiteThreshold: 5,\n    heavyBuilderCount: 3,\n    upgradersByStage: {\n      bootstrap: 1,\n      early: 2,\n      mid: 3,\n      late: 3\n    } as Record<ColonyStage, number>,\n    repairersWhenEstablished: 1,\n    scoutCount: 1,\n    reserverCount: 1,\n    claimerCount: 1,\n    minSoldiers: 2,\n    hostilesPerSoldier: 2\n  },\n  construction: {\n    runInterval: 37,\n    maxRoomConstructionSites: 10\n  },\n  defense: {\n    wallRepairCap: 200000,\n    structureRepairCap: 300000\n  },\n  walls: {\n    targetHitsByRcl: {\n      1: 5000,\n      2: 20000,\n      3: 100000,\n      4: 100000,\n      5: 200000,\n      6: 500000,\n      7: 1000000,\n      8: 2000000\n    } as Record<number, number>\n  },\n  energy: {\n    pickupDroppedEnergyMinAmount: 50,\n    haulerContainerWithdrawMinEnergy: 100\n  },\n  movement: {\n    maxRoomsPerPath: 16,\n    defaultRange: 1\n  },\n  roleTargets: {\n    default: {} as RoleTargetOverrides,\n    byStage: {\n      bootstrap: {},\n      early: {},\n      mid: {},\n      late: {}\n    } as Record<ColonyStage, RoleTargetOverrides>\n  },\n  rooms: {\n    // Example:\n    // W1N1: {\n    //   disablePvP: true,\n    //   noAttackRooms: [\"W1N2\"],\n    //   roleTargets: { upgrader: 3, builder: 2 },\n    //   roleTargetsByStage: { mid: { reserver: 2 } }\n    // }\n  } as Record<string, RoomControlSettings>\n};\n\nfunction unique(values: string[]): string[] {\n  return [...new Set(values)];\n}\n\nexport function resolveRoomSettings(roomName: string): ResolvedRoomControlSettings {\n  const roomSettings = COLONY_SETTINGS.rooms[roomName];\n\n  return {\n    roleTargets: roomSettings?.roleTargets ?? {},\n    roleTargetsByStage: roomSettings?.roleTargetsByStage ?? {},\n    disablePvP: roomSettings?.disablePvP ?? false,\n    noAttackRooms: unique([...(COLONY_SETTINGS.pvp.noAttackRooms ?? []), ...(roomSettings?.noAttackRooms ?? [])]),\n    remoteRoomAllowlist: roomSettings?.remoteRoomAllowlist,\n    remoteRoomBlocklist: roomSettings?.remoteRoomBlocklist ?? []\n  };\n}\n\nexport function isAttackAllowed(homeRoom: string, targetRoom: string): boolean {\n  const roomSettings = resolveRoomSettings(homeRoom);\n  if (!COLONY_SETTINGS.pvp.enabled || roomSettings.disablePvP) return false;\n  return !roomSettings.noAttackRooms.includes(targetRoom);\n}\n\nexport function isRemoteRoomAllowed(homeRoom: string, targetRoom: string): boolean {\n  const roomSettings = resolveRoomSettings(homeRoom);\n  if (roomSettings.remoteRoomBlocklist.includes(targetRoom)) return false;\n  if (roomSettings.remoteRoomAllowlist && roomSettings.remoteRoomAllowlist.length > 0) {\n    return roomSettings.remoteRoomAllowlist.includes(targetRoom);\n  }\n  return true;\n}\n\nexport function getWallTargetHits(rcl: number): number {\n  const target = COLONY_SETTINGS.walls.targetHitsByRcl[rcl];\n  if (target) return target;\n  return rcl >= 8 ? COLONY_SETTINGS.walls.targetHitsByRcl[8] : COLONY_SETTINGS.walls.targetHitsByRcl[1];\n}\n", "import type { CapabilityFlags, ColonyStage } from \"../config/colonyStages\";\nimport { COLONY_SETTINGS, resolveRoomSettings } from \"../config/settings\";\nimport { ROLE_ORDER, type RoleName } from \"../config/roles\";\nimport type { RoomSnapshot } from \"./types\";\n\nfunction baseDesired(): Record<RoleName, number> {\n  const desired = {} as Record<RoleName, number>;\n  for (const role of ROLE_ORDER) {\n    desired[role] = 0;\n  }\n  return desired;\n}\n\nfunction applyRoleOverrides(target: Record<RoleName, number>, overrides: Partial<Record<RoleName, number>>): void {\n  for (const role of ROLE_ORDER) {\n    const desired = overrides[role];\n    if (desired === undefined) continue;\n    target[role] = Math.max(0, desired);\n  }\n}\n\nexport function deriveDesiredRoles(\n  snapshot: RoomSnapshot,\n  stage: ColonyStage,\n  capabilities: CapabilityFlags\n): Record<RoleName, number> {\n  const desired = baseDesired();\n  const roomSettings = resolveRoomSettings(snapshot.roomName);\n\n  // Always keep a minimum survival workforce so a room can recover from wipes.\n  desired.harvester = Math.max(COLONY_SETTINGS.planner.minHarvesters, snapshot.sourceCount);\n  desired.hauler = COLONY_SETTINGS.planner.baseHaulers;\n  desired.upgrader = COLONY_SETTINGS.planner.baseUpgraders;\n  desired.builder =\n    snapshot.constructionSiteCount > 0\n      ? COLONY_SETTINGS.planner.buildersWhenSitesExist\n      : COLONY_SETTINGS.planner.buildersWhenNoSites;\n\n  if (stage !== \"bootstrap\") {\n    desired.miner = snapshot.sourceCount;\n    desired.hauler = Math.max(desired.hauler, snapshot.sourceCount, COLONY_SETTINGS.planner.baseHaulers);\n    desired.upgrader = COLONY_SETTINGS.planner.upgradersByStage[stage];\n    desired.builder =\n      snapshot.constructionSiteCount > COLONY_SETTINGS.planner.heavyBuildSiteThreshold\n        ? COLONY_SETTINGS.planner.heavyBuilderCount\n        : desired.builder;\n    desired.repairer = COLONY_SETTINGS.planner.repairersWhenEstablished;\n  }\n\n  if (capabilities.allowWalls) {\n    desired.waller = 1;\n  }\n\n  if (capabilities.allowRemoteMining) {\n    desired.scout = COLONY_SETTINGS.planner.scoutCount;\n    desired.reserver = COLONY_SETTINGS.planner.reserverCount;\n  }\n\n  if (capabilities.allowExpansion) {\n    desired.claimer = COLONY_SETTINGS.planner.claimerCount;\n  }\n\n  if (capabilities.allowOffense) {\n    desired.soldier = Math.max(\n      COLONY_SETTINGS.planner.minSoldiers,\n      Math.ceil(snapshot.hostileCount / Math.max(1, COLONY_SETTINGS.planner.hostilesPerSoldier))\n    );\n  }\n\n  applyRoleOverrides(desired, COLONY_SETTINGS.roleTargets.default);\n  applyRoleOverrides(desired, COLONY_SETTINGS.roleTargets.byStage[stage] ?? {});\n  applyRoleOverrides(desired, roomSettings.roleTargets);\n  applyRoleOverrides(desired, roomSettings.roleTargetsByStage[stage] ?? {});\n\n  return desired;\n}\n", "export type ColonyStage = \"bootstrap\" | \"early\" | \"mid\" | \"late\";\n\nexport interface StageThresholdConfig {\n  stage: ColonyStage;\n  minRcl: number;\n  minEnergyCapacity: number;\n}\n\nexport const STAGE_THRESHOLDS: StageThresholdConfig[] = [\n  { stage: \"late\", minRcl: 6, minEnergyCapacity: 1800 },\n  { stage: \"mid\", minRcl: 4, minEnergyCapacity: 800 },\n  { stage: \"early\", minRcl: 2, minEnergyCapacity: 450 },\n  { stage: \"bootstrap\", minRcl: 0, minEnergyCapacity: 0 }\n];\n\nexport interface CapabilityFlags {\n  allowRoads: boolean;\n  allowTowers: boolean;\n  allowWalls: boolean;\n  allowRemoteMining: boolean;\n  allowExpansion: boolean;\n  allowOffense: boolean;\n}\r\n", "import { STAGE_THRESHOLDS, type CapabilityFlags, type ColonyStage } from \"../config/colonyStages\";\nimport { COLONY_SETTINGS, resolveRoomSettings } from \"../config/settings\";\nimport type { RoomSnapshot } from \"./types\";\n\nfunction deriveStage(snapshot: RoomSnapshot): ColonyStage {\n  for (const threshold of STAGE_THRESHOLDS) {\n    if (snapshot.rcl >= threshold.minRcl && snapshot.energyCapacityAvailable >= threshold.minEnergyCapacity) {\n      return threshold.stage;\n    }\n  }\n\n  return \"bootstrap\";\n}\n\nfunction ownedRoomCount(): number {\n  return Object.values(Game.rooms).filter((room) => room.controller?.my).length;\n}\n\nfunction canExpand(snapshot: RoomSnapshot): boolean {\n  const gclLevel = Game.gcl.level;\n  const myRooms = ownedRoomCount();\n  return snapshot.rcl >= COLONY_SETTINGS.stage.expansionMinRcl && gclLevel > myRooms;\n}\n\nfunction canAttack(snapshot: RoomSnapshot): boolean {\n  const roomSettings = resolveRoomSettings(snapshot.roomName);\n  if (!COLONY_SETTINGS.pvp.enabled || roomSettings.disablePvP) return false;\n  return (\n    snapshot.rcl >= COLONY_SETTINGS.stage.offenseMinRcl &&\n    snapshot.storageEnergy >= COLONY_SETTINGS.stage.offenseMinStorageEnergy\n  );\n}\n\nexport function deriveCapabilities(snapshot: RoomSnapshot, stage: ColonyStage): CapabilityFlags {\n  return {\n    allowRoads: stage !== \"bootstrap\",\n    allowTowers: snapshot.rcl >= COLONY_SETTINGS.stage.towersMinRcl,\n    allowWalls: snapshot.rcl >= COLONY_SETTINGS.stage.wallsMinRcl,\n    allowRemoteMining:\n      snapshot.rcl >= COLONY_SETTINGS.stage.remoteMiningMinRcl &&\n      snapshot.energyCapacityAvailable >= COLONY_SETTINGS.stage.remoteMiningMinEnergyCapacity,\n    allowExpansion: canExpand(snapshot),\n    allowOffense: canAttack(snapshot)\n  };\n}\n\nexport function deriveStageAndCapabilities(snapshot: RoomSnapshot): { stage: ColonyStage; capabilities: CapabilityFlags } {\n  const stage = deriveStage(snapshot);\n  const capabilities = deriveCapabilities(snapshot, stage);\n  return { stage, capabilities };\n}\r\n", "import type { ColonyStrategy } from \"./types\";\nimport { isAttackAllowed, isRemoteRoomAllowed } from \"../config/settings\";\n\nfunction unique(values: string[]): string[] {\n  return [...new Set(values)];\n}\n\nfunction neighboringRooms(room: Room): string[] {\n  const exits = Game.map.describeExits(room.name);\n  if (!exits) return [];\n  return unique(Object.values(exits));\n}\n\nexport function deriveTargetRooms(room: Room, strategy: ColonyStrategy): ColonyStrategy {\n  const visibleNeighbors = neighboringRooms(room);\n  const allowedRemoteNeighbors = visibleNeighbors.filter((name) => isRemoteRoomAllowed(room.name, name));\n\n  const scoutTargetRooms = visibleNeighbors;\n  const reserveTargetRooms = strategy.capabilities.allowRemoteMining ? allowedRemoteNeighbors : [];\n\n  const claimTargetRooms = strategy.capabilities.allowExpansion\n    ? allowedRemoteNeighbors.filter((name) => {\n        const targetRoom = Game.rooms[name];\n        if (!targetRoom?.controller) return true;\n        return !targetRoom.controller.owner && !targetRoom.controller.reservation;\n      })\n    : [];\n\n  const attackTargetRooms = strategy.capabilities.allowOffense\n    ? visibleNeighbors.filter((name) => {\n        if (!isAttackAllowed(room.name, name)) return false;\n        const targetRoom = Game.rooms[name];\n        if (!targetRoom) return false;\n        return targetRoom.find(FIND_HOSTILE_CREEPS).length > 0;\n      })\n    : [];\n\n  return {\n    ...strategy,\n    scoutTargetRooms,\n    reserveTargetRooms,\n    claimTargetRooms,\n    attackTargetRooms\n  };\n}\r\n", "import { collectRoomSnapshot } from \"../colony/intel\";\nimport { deriveDesiredRoles } from \"../colony/spawnPlanner\";\nimport { deriveStageAndCapabilities } from \"../colony/stageManager\";\nimport { deriveTargetRooms } from \"../colony/strategyManager\";\nimport type { ColonyStrategy } from \"../colony/types\";\n\nexport function runColonyManager(): void {\n  for (const room of Object.values(Game.rooms)) {\n    if (!room.controller?.my) continue;\n\n    const snapshot = collectRoomSnapshot(room);\n    const { stage, capabilities } = deriveStageAndCapabilities(snapshot);\n    const desiredRoles = deriveDesiredRoles(snapshot, stage, capabilities);\n\n    const baseStrategy: ColonyStrategy = {\n      stage,\n      capabilities,\n      desiredRoles,\n      scoutTargetRooms: [],\n      reserveTargetRooms: [],\n      claimTargetRooms: [],\n      attackTargetRooms: []\n    };\n\n    const resolved = deriveTargetRooms(room, baseStrategy);\n\n    if (!Memory.strategy) {\n      Memory.strategy = {};\n    }\n\n    Memory.strategy[room.name] = resolved;\n  }\n}\r\n", "import { COLONY_SETTINGS } from \"../config/settings\";\n\nfunction placeIfFree(room: Room, x: number, y: number, structureType: BuildableStructureConstant): void {\n  if (x < 1 || x > 48 || y < 1 || y > 48) return;\n\n  const look = room.lookForAt(LOOK_STRUCTURES, x, y);\n  if (look.length > 0) return;\n\n  const sites = room.lookForAt(LOOK_CONSTRUCTION_SITES, x, y);\n  if (sites.length > 0) return;\n\n  room.createConstructionSite(x, y, structureType);\n}\n\nfunction placeExtensions(room: Room, anchor: RoomPosition): void {\n  const max = CONTROLLER_STRUCTURES[STRUCTURE_EXTENSION][room.controller?.level ?? 0] ?? 0;\n  const built = room.find(FIND_MY_STRUCTURES, {\n    filter: (structure: Structure) => structure.structureType === STRUCTURE_EXTENSION\n  }).length;\n  const sites = room.find(FIND_MY_CONSTRUCTION_SITES, {\n    filter: (site: ConstructionSite) => site.structureType === STRUCTURE_EXTENSION\n  }).length;\n\n  if (built + sites >= max) return;\n\n  const offsets: Array<[number, number]> = [\n    [2, 0],\n    [-2, 0],\n    [0, 2],\n    [0, -2],\n    [2, 2],\n    [2, -2],\n    [-2, 2],\n    [-2, -2],\n    [3, 1],\n    [3, -1],\n    [-3, 1],\n    [-3, -1],\n    [1, 3],\n    [-1, 3],\n    [1, -3],\n    [-1, -3]\n  ];\n\n  for (const [dx, dy] of offsets) {\n    if (built + sites >= max) break;\n    placeIfFree(room, anchor.x + dx, anchor.y + dy, STRUCTURE_EXTENSION);\n  }\n}\n\nfunction placeRoadsFromAnchor(room: Room, anchor: RoomPosition): void {\n  const controller = room.controller;\n  if (controller) {\n    const path = anchor.findPathTo(controller.pos, { ignoreCreeps: true });\n    for (const step of path) {\n      placeIfFree(room, step.x, step.y, STRUCTURE_ROAD);\n    }\n  }\n\n  const sources = room.find(FIND_SOURCES);\n  for (const source of sources) {\n    const path = anchor.findPathTo(source.pos, { ignoreCreeps: true });\n    for (const step of path) {\n      placeIfFree(room, step.x, step.y, STRUCTURE_ROAD);\n    }\n  }\n}\n\nfunction placeSourceContainers(room: Room, anchor: RoomPosition): void {\n  const sources = room.find(FIND_SOURCES);\n  for (const source of sources) {\n    const hasContainer = source.pos.findInRange(FIND_STRUCTURES, 1, {\n      filter: (structure: Structure) => structure.structureType === STRUCTURE_CONTAINER\n    }).length;\n\n    if (hasContainer > 0) continue;\n\n    const path = anchor.findPathTo(source.pos, { ignoreCreeps: true });\n    const finalStep = path[path.length - 1];\n    if (!finalStep) continue;\n\n    placeIfFree(room, finalStep.x, finalStep.y, STRUCTURE_CONTAINER);\n  }\n}\n\nfunction placeTowers(room: Room, anchor: RoomPosition): void {\n  const max = CONTROLLER_STRUCTURES[STRUCTURE_TOWER][room.controller?.level ?? 0] ?? 0;\n  if (max === 0) return;\n\n  const built = room.find(FIND_MY_STRUCTURES, {\n    filter: (structure: Structure) => structure.structureType === STRUCTURE_TOWER\n  }).length;\n  const sites = room.find(FIND_MY_CONSTRUCTION_SITES, {\n    filter: (site: ConstructionSite) => site.structureType === STRUCTURE_TOWER\n  }).length;\n\n  if (built + sites >= max) return;\n\n  placeIfFree(room, anchor.x + 3, anchor.y, STRUCTURE_TOWER);\n  placeIfFree(room, anchor.x - 3, anchor.y, STRUCTURE_TOWER);\n  placeIfFree(room, anchor.x, anchor.y + 3, STRUCTURE_TOWER);\n}\n\nfunction placeDefensiveRing(room: Room, anchor: RoomPosition): void {\n  for (let dx = -4; dx <= 4; dx += 1) {\n    for (let dy = -4; dy <= 4; dy += 1) {\n      const onEdge = Math.abs(dx) === 4 || Math.abs(dy) === 4;\n      if (!onEdge) continue;\n      placeIfFree(room, anchor.x + dx, anchor.y + dy, STRUCTURE_WALL);\n    }\n  }\n}\n\nexport function runConstructionManager(): void {\n  if (Game.time % COLONY_SETTINGS.construction.runInterval !== 0) return;\n\n  for (const room of Object.values(Game.rooms)) {\n    if (!room.controller?.my) continue;\n\n    const mySpawn = room.find(FIND_MY_SPAWNS)[0];\n    if (!mySpawn) continue;\n\n    const strategy = Memory.strategy?.[room.name];\n    if (!strategy) continue;\n\n    const siteCount = room.find(FIND_CONSTRUCTION_SITES).length;\n    if (siteCount > COLONY_SETTINGS.construction.maxRoomConstructionSites) continue;\n\n    const anchor = mySpawn.pos;\n    placeExtensions(room, anchor);\n    placeSourceContainers(room, anchor);\n\n    if (strategy.capabilities.allowRoads) {\n      placeRoadsFromAnchor(room, anchor);\n    }\n\n    if (strategy.capabilities.allowTowers) {\n      placeTowers(room, anchor);\n    }\n\n    if (strategy.capabilities.allowWalls) {\n      placeDefensiveRing(room, anchor);\n    }\n  }\n}\r\n", "import { COLONY_SETTINGS } from \"../config/settings\";\n\nexport function runDefenseManager(): void {\n  const towers = _.filter(\n    Object.values(Game.structures),\n    (structure): structure is StructureTower => structure.structureType === STRUCTURE_TOWER && structure.my\n  );\n\n  for (const tower of towers) {\n    const closestHostile = tower.pos.findClosestByRange(FIND_HOSTILE_CREEPS);\n    if (closestHostile) {\n      tower.attack(closestHostile);\n      continue;\n    }\n\n    const wounded = tower.pos.findClosestByRange(FIND_MY_CREEPS, {\n      filter: (creep: Creep) => creep.hits < creep.hitsMax\n    });\n\n    if (wounded) {\n      tower.heal(wounded);\n      continue;\n    }\n\n    const repairTarget = tower.pos.findClosestByRange(FIND_STRUCTURES, {\n      filter: (structure: Structure) => {\n        if (structure.structureType === STRUCTURE_WALL || structure.structureType === STRUCTURE_RAMPART) {\n          return structure.hits < COLONY_SETTINGS.defense.wallRepairCap;\n        }\n\n        return structure.hits < structure.hitsMax && structure.hits < COLONY_SETTINGS.defense.structureRepairCap;\n      }\n    });\n\n    if (repairTarget) {\n      tower.repair(repairTarget);\n    }\n  }\n}\r\n", "import type { RoleName } from \"./roles\";\n\nexport interface BodyBlueprint {\n  min: BodyPartConstant[];\n  segment: BodyPartConstant[];\n  maxSegments: number;\n}\n\nexport const ROLE_BODIES: Record<RoleName, BodyBlueprint> = {\n  harvester: { min: [WORK, CARRY, MOVE], segment: [WORK, CARRY, MOVE], maxSegments: 6 },\n  hauler: { min: [CARRY, CARRY, MOVE], segment: [CARRY, CARRY, MOVE], maxSegments: 8 },\n  miner: { min: [WORK, WORK, MOVE], segment: [WORK, WORK, MOVE], maxSegments: 5 },\n  upgrader: { min: [WORK, CARRY, MOVE], segment: [WORK, CARRY, MOVE], maxSegments: 8 },\n  builder: { min: [WORK, CARRY, MOVE], segment: [WORK, CARRY, MOVE], maxSegments: 6 },\n  repairer: { min: [WORK, CARRY, MOVE], segment: [WORK, CARRY, MOVE], maxSegments: 5 },\n  waller: { min: [WORK, CARRY, MOVE], segment: [WORK, CARRY, MOVE], maxSegments: 7 },\n  scout: { min: [MOVE], segment: [MOVE], maxSegments: 1 },\n  reserver: { min: [CLAIM, MOVE], segment: [CLAIM, MOVE], maxSegments: 2 },\n  claimer: { min: [CLAIM, MOVE], segment: [CLAIM, MOVE], maxSegments: 1 },\n  soldier: { min: [TOUGH, MOVE, ATTACK, MOVE], segment: [TOUGH, MOVE, ATTACK, MOVE], maxSegments: 6 }\n};\r\n", "import type { RoleName } from \"./config/roles\";\n\nconst PART_COST: Record<BodyPartConstant, number> = {\n  move: 50,\n  work: 100,\n  carry: 50,\n  attack: 80,\n  ranged_attack: 150,\n  tough: 10,\n  heal: 250,\n  claim: 600\n};\n\nexport function bodyCost(body: BodyPartConstant[]): number {\n  return body.reduce((sum, part) => sum + PART_COST[part], 0);\n}\n\nexport function countRoleInRoom(roomName: string, role: RoleName): number {\n  let count = 0;\n  for (const creep of Object.values(Game.creeps)) {\n    if (creep.memory.homeRoom === roomName && creep.memory.role === role) {\n      count += 1;\n    }\n  }\n\n  return count;\n}\n\nexport function cleanupMemory(): void {\n  for (const name in Memory.creeps) {\n    if (!Game.creeps[name]) {\n      delete Memory.creeps[name];\n    }\n  }\n}\r\n", "import { ROLE_BODIES } from \"../config/bodyPlans\";\nimport { ROLE_ORDER, type RoleName } from \"../config/roles\";\nimport { bodyCost } from \"../utils\";\n\nfunction buildBody(role: RoleName, energyBudget: number): BodyPartConstant[] | null {\n  const blueprint = ROLE_BODIES[role];\n  const minCost = bodyCost(blueprint.min);\n  if (energyBudget < minCost) return null;\n\n  const body: BodyPartConstant[] = [...blueprint.min];\n  const segmentCost = bodyCost(blueprint.segment);\n\n  let segments = 1;\n  while (\n    segments < blueprint.maxSegments &&\n    body.length + blueprint.segment.length <= 50 &&\n    bodyCost(body) + segmentCost <= energyBudget\n  ) {\n    body.push(...blueprint.segment);\n    segments += 1;\n  }\n\n  return body;\n}\n\nfunction nextRoleToSpawn(spawn: StructureSpawn): RoleName | null {\n  const strategy = Memory.strategy?.[spawn.room.name];\n  if (!strategy) return null;\n\n  const current = Object.values(Game.creeps).filter((creep) => creep.memory.homeRoom === spawn.room.name);\n  if (current.length === 0) {\n    return \"harvester\";\n  }\n\n  for (const role of ROLE_ORDER) {\n    const desired = strategy.desiredRoles[role] ?? 0;\n    if (desired <= 0) continue;\n\n    const currentCount = current.filter((creep) => creep.memory.role === role).length;\n    if (currentCount < desired) {\n      return role;\n    }\n  }\n\n  return null;\n}\n\nexport function runSpawnManager(): void {\n  const spawns = Object.values(Game.spawns);\n  for (const spawn of spawns) {\n    if (spawn.spawning) continue;\n\n    const role = nextRoleToSpawn(spawn);\n    if (!role) continue;\n\n    const energyBudget = spawn.room.energyAvailable;\n    const body = buildBody(role, energyBudget);\n    if (!body) continue;\n\n    const name = `${role}-${spawn.room.name}-${Game.time}`;\n    spawn.spawnCreep(body, name, {\n      memory: {\n        role,\n        homeRoom: spawn.room.name,\n        working: false\n      }\n    });\n  }\n}\r\n", "import { COLONY_SETTINGS } from \"../config/settings\";\n\nexport function moveToTarget(creep: Creep, target: RoomPosition | { pos: RoomPosition }, range = 1): void {\n  creep.moveTo(target, {\n    reusePath: 10,\n    maxRooms: COLONY_SETTINGS.movement.maxRoomsPerPath,\n    range: range ?? COLONY_SETTINGS.movement.defaultRange,\n    visualizePathStyle: { stroke: \"#8ecae6\" }\n  });\n}\n\nexport function moveToRoomCenter(creep: Creep, roomName: string): void {\n  const target = new RoomPosition(25, 25, roomName);\n  moveToTarget(creep, target, 20);\n}\r\n", "import { moveToTarget } from \"./movement\";\n\nexport function upgradeController(creep: Creep): boolean {\n  const controller = creep.room.controller;\n  if (!controller) return false;\n\n  const result = creep.upgradeController(controller);\n  if (result === ERR_NOT_IN_RANGE) {\n    moveToTarget(creep, controller);\n    return true;\n  }\n\n  return result === OK;\n}\n\nexport function buildNearestSite(creep: Creep): boolean {\n  const site = creep.pos.findClosestByPath(FIND_CONSTRUCTION_SITES);\n  if (!site) return false;\n\n  const result = creep.build(site);\n  if (result === ERR_NOT_IN_RANGE) {\n    moveToTarget(creep, site);\n    return true;\n  }\n\n  return result === OK;\n}\n\nexport function repairInfrastructure(creep: Creep): boolean {\n  const target = creep.pos.findClosestByPath(FIND_STRUCTURES, {\n    filter: (structure: Structure) => {\n      if (structure.hits >= structure.hitsMax) return false;\n      return structure.structureType === STRUCTURE_ROAD || structure.structureType === STRUCTURE_CONTAINER;\n    }\n  });\n\n  if (!target) return false;\n\n  const result = creep.repair(target);\n  if (result === ERR_NOT_IN_RANGE) {\n    moveToTarget(creep, target);\n    return true;\n  }\n\n  return result === OK;\n}\n\nexport function fortifyDefenses(creep: Creep, minWallHits: number): boolean {\n  const target = creep.pos.findClosestByPath(FIND_STRUCTURES, {\n    filter: (structure: Structure) => {\n      if (structure.structureType !== STRUCTURE_WALL && structure.structureType !== STRUCTURE_RAMPART) return false;\n      return structure.hits < minWallHits;\n    }\n  });\n\n  if (!target) return false;\n\n  const result = creep.repair(target);\n  if (result === ERR_NOT_IN_RANGE) {\n    moveToTarget(creep, target);\n    return true;\n  }\n\n  return result === OK;\n}\r\n", "import { COLONY_SETTINGS } from \"../config/settings\";\nimport { moveToTarget } from \"./movement\";\n\nfunction isSourceWorker(creep: Creep): boolean {\n  return creep.memory.role === \"harvester\" || creep.memory.role === \"miner\";\n}\n\nfunction sourceLoad(roomName: string, sourceId: Id<Source>, excludeCreepName: string): number {\n  let load = 0;\n\n  for (const other of Object.values(Game.creeps)) {\n    if (other.name === excludeCreepName) continue;\n    if (other.memory.homeRoom !== roomName) continue;\n    if (!isSourceWorker(other)) continue;\n    if (other.memory.sourceId === sourceId) {\n      load += 1;\n    }\n  }\n\n  return load;\n}\n\nfunction assignSource(creep: Creep): Source | null {\n  const sources = creep.room.find(FIND_SOURCES_ACTIVE);\n  if (sources.length === 0) return null;\n\n  if (!isSourceWorker(creep)) {\n    if (creep.memory.sourceId) {\n      const existing = Game.getObjectById(creep.memory.sourceId as Id<Source>);\n      if (existing) return existing;\n    }\n\n    const nearest = creep.pos.findClosestByPath(sources) ?? sources[0];\n    creep.memory.sourceId = nearest.id;\n    return nearest;\n  }\n\n  const existing =\n    creep.memory.sourceId !== undefined ? Game.getObjectById(creep.memory.sourceId as Id<Source>) : null;\n  const shouldRebalance = Game.time % 25 === 0;\n  if (existing && !shouldRebalance) {\n    return existing;\n  }\n\n  let best: Source | null = null;\n  let bestLoad = Number.MAX_SAFE_INTEGER;\n  let bestRange = Number.MAX_SAFE_INTEGER;\n\n  for (const source of sources) {\n    const load = sourceLoad(creep.memory.homeRoom, source.id, creep.name);\n    const range = creep.pos.getRangeTo(source);\n\n    if (load < bestLoad || (load === bestLoad && range < bestRange)) {\n      best = source;\n      bestLoad = load;\n      bestRange = range;\n    }\n  }\n\n  const selected = best ?? sources[0];\n  creep.memory.sourceId = selected.id;\n  return selected;\n}\n\nexport function harvestEnergy(creep: Creep): boolean {\n  const source = assignSource(creep);\n  if (!source) return false;\n\n  const result = creep.harvest(source);\n  if (result === ERR_NOT_IN_RANGE) {\n    moveToTarget(creep, source);\n    return true;\n  }\n\n  return result === OK;\n}\n\nexport function withdrawStoredEnergy(creep: Creep): boolean {\n  const target = creep.pos.findClosestByPath(FIND_STRUCTURES, {\n    filter: (structure: Structure) => {\n      if (structure.structureType === STRUCTURE_STORAGE || structure.structureType === STRUCTURE_CONTAINER) {\n        return (structure as StructureStorage | StructureContainer).store.getUsedCapacity(RESOURCE_ENERGY) > 0;\n      }\n      return false;\n    }\n  }) as StructureStorage | StructureContainer | null;\n\n  if (!target) return false;\n\n  const result = creep.withdraw(target, RESOURCE_ENERGY);\n  if (result === ERR_NOT_IN_RANGE) {\n    moveToTarget(creep, target);\n    return true;\n  }\n\n  return result === OK;\n}\n\nexport function pickupDroppedEnergy(creep: Creep): boolean {\n  const resource = creep.pos.findClosestByPath(FIND_DROPPED_RESOURCES, {\n    filter: (dropped: Resource) =>\n      dropped.resourceType === RESOURCE_ENERGY && dropped.amount > COLONY_SETTINGS.energy.pickupDroppedEnergyMinAmount\n  });\n\n  if (!resource) return false;\n\n  const result = creep.pickup(resource);\n  if (result === ERR_NOT_IN_RANGE) {\n    moveToTarget(creep, resource);\n    return true;\n  }\n\n  return result === OK;\n}\n\nexport function fillPriorityEnergyTargets(creep: Creep): boolean {\n  const target = creep.pos.findClosestByPath(FIND_STRUCTURES, {\n    filter: (structure: Structure) => {\n      if (\n        structure.structureType === STRUCTURE_SPAWN ||\n        structure.structureType === STRUCTURE_EXTENSION ||\n        structure.structureType === STRUCTURE_TOWER\n      ) {\n        return (structure as StructureSpawn | StructureExtension | StructureTower).store.getFreeCapacity(RESOURCE_ENERGY) > 0;\n      }\n      return false;\n    }\n  }) as StructureSpawn | StructureExtension | StructureTower | null;\n\n  if (!target) return false;\n\n  const result = creep.transfer(target, RESOURCE_ENERGY);\n  if (result === ERR_NOT_IN_RANGE) {\n    moveToTarget(creep, target);\n    return true;\n  }\n\n  return result === OK;\n}\r\n", "import { harvestEnergy, pickupDroppedEnergy, withdrawStoredEnergy } from \"../tasks/energy\";\n\nexport function updateWorkingState(creep: Creep): void {\n  if (creep.memory.working && creep.store.getUsedCapacity(RESOURCE_ENERGY) === 0) {\n    creep.memory.working = false;\n  }\n\n  if (!creep.memory.working && creep.store.getFreeCapacity() === 0) {\n    creep.memory.working = true;\n  }\n}\n\nexport function acquireEnergy(creep: Creep): boolean {\n  return withdrawStoredEnergy(creep) || pickupDroppedEnergy(creep) || harvestEnergy(creep);\n}\r\n", "import { buildNearestSite, upgradeController } from \"../tasks/work\";\nimport { updateWorkingState, acquireEnergy } from \"./common\";\n\nexport function runBuilder(creep: Creep): void {\n  updateWorkingState(creep);\n\n  if (!creep.memory.working) {\n    acquireEnergy(creep);\n    return;\n  }\n\n  if (buildNearestSite(creep)) return;\n  upgradeController(creep);\n}\r\n", "import { moveToRoomCenter, moveToTarget } from \"./movement\";\nimport { isAttackAllowed } from \"../config/settings\";\n\nexport function reserveRoomController(creep: Creep, roomName: string): boolean {\n  if (creep.room.name !== roomName) {\n    moveToRoomCenter(creep, roomName);\n    return true;\n  }\n\n  const controller = creep.room.controller;\n  if (!controller) return false;\n\n  const result = creep.reserveController(controller);\n  if (result === ERR_NOT_IN_RANGE) {\n    moveToTarget(creep, controller);\n    return true;\n  }\n\n  return result === OK;\n}\n\nexport function claimRoomController(creep: Creep, roomName: string): boolean {\n  if (creep.room.name !== roomName) {\n    moveToRoomCenter(creep, roomName);\n    return true;\n  }\n\n  const controller = creep.room.controller;\n  if (!controller) return false;\n\n  const result = creep.claimController(controller);\n  if (result === ERR_NOT_IN_RANGE) {\n    moveToTarget(creep, controller);\n    return true;\n  }\n\n  return result === OK;\n}\n\nexport function attackInRoom(creep: Creep, roomName: string): boolean {\n  if (!isAttackAllowed(creep.memory.homeRoom, roomName)) return false;\n\n  if (creep.room.name !== roomName) {\n    moveToRoomCenter(creep, roomName);\n    return true;\n  }\n\n  const hostile = creep.pos.findClosestByPath(FIND_HOSTILE_CREEPS);\n  if (hostile) {\n    const result = creep.attack(hostile);\n    if (result === ERR_NOT_IN_RANGE) {\n      moveToTarget(creep, hostile);\n      return true;\n    }\n\n    return result === OK;\n  }\n\n  const hostileStructure = creep.pos.findClosestByPath(FIND_HOSTILE_STRUCTURES, {\n    filter: (structure: Structure) => structure.structureType !== STRUCTURE_CONTROLLER\n  });\n\n  if (!hostileStructure) return false;\n\n  const result = creep.attack(hostileStructure);\n  if (result === ERR_NOT_IN_RANGE) {\n    moveToTarget(creep, hostileStructure);\n    return true;\n  }\n\n  return result === OK;\n}\r\n", "import { claimRoomController } from \"../tasks/combat\";\n\nexport function runClaimer(creep: Creep): void {\n  const targets = Memory.strategy?.[creep.memory.homeRoom]?.claimTargetRooms ?? [];\n  if (targets.length === 0) return;\n\n  const targetRoom = targets[0];\n  claimRoomController(creep, targetRoom);\n}\r\n", "import { fillPriorityEnergyTargets } from \"../tasks/energy\";\nimport { upgradeController } from \"../tasks/work\";\nimport { updateWorkingState, acquireEnergy } from \"./common\";\n\nexport function runHarvester(creep: Creep): void {\n  updateWorkingState(creep);\n\n  if (!creep.memory.working) {\n    acquireEnergy(creep);\n    return;\n  }\n\n  if (fillPriorityEnergyTargets(creep)) return;\n  upgradeController(creep);\n}\r\n", "import { fillPriorityEnergyTargets, pickupDroppedEnergy, withdrawStoredEnergy } from \"../tasks/energy\";\nimport { COLONY_SETTINGS } from \"../config/settings\";\nimport { updateWorkingState } from \"./common\";\n\nfunction withdrawFromSourceContainers(creep: Creep): boolean {\n  const target = creep.pos.findClosestByPath(FIND_STRUCTURES, {\n    filter: (structure: Structure) => {\n      if (structure.structureType !== STRUCTURE_CONTAINER) return false;\n      const container = structure as StructureContainer;\n      return container.store.getUsedCapacity(RESOURCE_ENERGY) >= COLONY_SETTINGS.energy.haulerContainerWithdrawMinEnergy;\n    }\n  }) as StructureContainer | null;\n\n  if (!target) return false;\n\n  const result = creep.withdraw(target, RESOURCE_ENERGY);\n  if (result === ERR_NOT_IN_RANGE) {\n    creep.moveTo(target, { reusePath: 15, visualizePathStyle: { stroke: \"#219ebc\" } });\n    return true;\n  }\n\n  return result === OK;\n}\n\nexport function runHauler(creep: Creep): void {\n  updateWorkingState(creep);\n\n  if (!creep.memory.working) {\n    if (withdrawFromSourceContainers(creep)) return;\n    if (withdrawStoredEnergy(creep)) return;\n    pickupDroppedEnergy(creep);\n    return;\n  }\n\n  fillPriorityEnergyTargets(creep);\n}\r\n", "import { harvestEnergy } from \"../tasks/energy\";\n\nfunction sourceContainer(creep: Creep): StructureContainer | null {\n  const source = creep.memory.sourceId ? Game.getObjectById(creep.memory.sourceId) : null;\n  if (!source) return null;\n\n  const containers = source.pos.findInRange(FIND_STRUCTURES, 1, {\n    filter: (structure: Structure) => structure.structureType === STRUCTURE_CONTAINER\n  }) as StructureContainer[];\n\n  return containers[0] ?? null;\n}\n\nexport function runMiner(creep: Creep): void {\n  const container = sourceContainer(creep);\n  if (container && creep.pos.getRangeTo(container) > 0) {\n    creep.moveTo(container, { reusePath: 20, visualizePathStyle: { stroke: \"#ffb703\" } });\n    return;\n  }\n\n  harvestEnergy(creep);\n}\r\n", "import { repairInfrastructure, upgradeController } from \"../tasks/work\";\nimport { updateWorkingState, acquireEnergy } from \"./common\";\n\nexport function runRepairer(creep: Creep): void {\n  updateWorkingState(creep);\n\n  if (!creep.memory.working) {\n    acquireEnergy(creep);\n    return;\n  }\n\n  if (repairInfrastructure(creep)) return;\n  upgradeController(creep);\n}\r\n", "import { reserveRoomController } from \"../tasks/combat\";\n\nexport function runReserver(creep: Creep): void {\n  const targets = Memory.strategy?.[creep.memory.homeRoom]?.reserveTargetRooms ?? [];\n  if (targets.length === 0) return;\n\n  const targetRoom = targets[Game.time % targets.length];\n  reserveRoomController(creep, targetRoom);\n}\r\n", "import { moveToRoomCenter } from \"../tasks/movement\";\n\nexport function runScout(creep: Creep): void {\n  const targets = Memory.strategy?.[creep.memory.homeRoom]?.scoutTargetRooms ?? [];\n  if (targets.length === 0) return;\n\n  const targetRoom = targets[Game.time % targets.length];\n  if (creep.room.name !== targetRoom) {\n    moveToRoomCenter(creep, targetRoom);\n    return;\n  }\n\n  creep.moveTo(25, 25, { reusePath: 5 });\n}\r\n", "import { attackInRoom } from \"../tasks/combat\";\n\nexport function runSoldier(creep: Creep): void {\n  const targets = Memory.strategy?.[creep.memory.homeRoom]?.attackTargetRooms ?? [];\n  if (targets.length === 0) return;\n\n  const targetRoom = targets[Game.time % targets.length];\n  attackInRoom(creep, targetRoom);\n}\r\n", "import { upgradeController } from \"../tasks/work\";\nimport { updateWorkingState, acquireEnergy } from \"./common\";\n\nexport function runUpgrader(creep: Creep): void {\n  updateWorkingState(creep);\n\n  if (!creep.memory.working) {\n    acquireEnergy(creep);\n    return;\n  }\n\n  upgradeController(creep);\n}\r\n", "import { getWallTargetHits } from \"../config/settings\";\nimport { fortifyDefenses, upgradeController } from \"../tasks/work\";\nimport { updateWorkingState, acquireEnergy } from \"./common\";\n\nexport function runWaller(creep: Creep): void {\n  updateWorkingState(creep);\n\n  if (!creep.memory.working) {\n    acquireEnergy(creep);\n    return;\n  }\n\n  const rcl = creep.room.controller?.level ?? 1;\n  if (fortifyDefenses(creep, getWallTargetHits(rcl))) return;\n  upgradeController(creep);\n}\n", "import { runBuilder } from \"./builder\";\nimport { runClaimer } from \"./claimer\";\nimport { runHarvester } from \"./harvester\";\nimport { runHauler } from \"./hauler\";\nimport { runMiner } from \"./miner\";\nimport { runRepairer } from \"./repairer\";\nimport { runReserver } from \"./reserver\";\nimport { runScout } from \"./scout\";\nimport { runSoldier } from \"./soldier\";\nimport { runUpgrader } from \"./upgrader\";\nimport { runWaller } from \"./waller\";\n\nexport function runRole(creep: Creep): void {\n  switch (creep.memory.role) {\n    case \"harvester\":\n      runHarvester(creep);\n      return;\n    case \"hauler\":\n      runHauler(creep);\n      return;\n    case \"miner\":\n      runMiner(creep);\n      return;\n    case \"upgrader\":\n      runUpgrader(creep);\n      return;\n    case \"builder\":\n      runBuilder(creep);\n      return;\n    case \"repairer\":\n      runRepairer(creep);\n      return;\n    case \"waller\":\n      runWaller(creep);\n      return;\n    case \"scout\":\n      runScout(creep);\n      return;\n    case \"reserver\":\n      runReserver(creep);\n      return;\n    case \"claimer\":\n      runClaimer(creep);\n      return;\n    case \"soldier\":\n      runSoldier(creep);\n      return;\n  }\n}\r\n"],
  "mappings": "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",
  "names": ["unique", "existing", "result"]
}
