{
  "version": 3,
  "sources": ["../src/main.ts", "../src/config/roles.ts", "../src/runtime/tickCache.ts", "../src/colony/intel.ts", "../src/config/settings.ts", "../src/managers/threatManager.ts", "../src/colony/spawnPlanner.ts", "../src/config/colonyStages.ts", "../src/colony/stageManager.ts", "../src/colony/strategyManager.ts", "../src/managers/colonyManager.ts", "../src/colony/layoutPlanner.ts", "../src/tasks/movement.ts", "../src/tasks/minerals.ts", "../src/managers/constructionManager.ts", "../src/managers/defenseManager.ts", "../src/managers/linkManager.ts", "../src/config/bodyPlans.ts", "../src/utils.ts", "../src/managers/spawnManager.ts", "../src/managers/telemetryManager.ts", "../src/tasks/work.ts", "../src/tasks/energy.ts", "../src/roles/common.ts", "../src/roles/builder.ts", "../src/roles/bootstrapper.ts", "../src/tasks/combat.ts", "../src/roles/claimer.ts", "../src/roles/harvester.ts", "../src/roles/hauler.ts", "../src/roles/miner.ts", "../src/roles/mineralHauler.ts", "../src/roles/mineralMiner.ts", "../src/roles/repairer.ts", "../src/roles/reserver.ts", "../src/roles/scout.ts", "../src/roles/soldier.ts", "../src/roles/upgrader.ts", "../src/roles/waller.ts", "../src/roles/index.ts"],
  "sourcesContent": ["import { runColonyManager } from \"./managers/colonyManager\";\nimport { runConstructionManager } from \"./managers/constructionManager\";\nimport { runDefenseManager } from \"./managers/defenseManager\";\nimport { runLinkManager } from \"./managers/linkManager\";\nimport { runSpawnManager } from \"./managers/spawnManager\";\nimport { runTelemetryManager } from \"./managers/telemetryManager\";\nimport { runThreatManager } from \"./managers/threatManager\";\nimport { runRole } from \"./roles\";\nimport { getAllCreeps } from \"./runtime/tickCache\";\nimport { cleanupMemory } from \"./utils\";\n\nexport const loop = (): void => {\n  cleanupMemory();\n\n  runThreatManager();\n  runColonyManager();\n  runSpawnManager();\n  runConstructionManager();\n  runLinkManager();\n  runDefenseManager();\n  runTelemetryManager();\n\n  for (const creep of getAllCreeps()) {\n    runRole(creep);\n  }\n};\n", "export const ROLE_ORDER = [\n  \"harvester\",\n  \"hauler\",\n  \"miner\",\n  \"mineralMiner\",\n  \"mineralHauler\",\n  \"upgrader\",\n  \"builder\",\n  \"repairer\",\n  \"waller\",\n  \"scout\",\n  \"reserver\",\n  \"claimer\",\n  \"bootstrapper\",\n  \"soldier\"\n] as const;\n\nexport type RoleName = (typeof ROLE_ORDER)[number];\n\nexport const CORE_ROLES: RoleName[] = [\"harvester\", \"hauler\", \"upgrader\", \"builder\"];\n\nexport const COMBAT_ROLES: RoleName[] = [\"soldier\"];\r\n", "import { ROLE_ORDER, type RoleName } from \"../config/roles\";\n\ninterface RoomCreepBuckets {\n  creeps: Creep[];\n  byRole: Record<RoleName, Creep[]>;\n}\n\nlet cachedTick = -1;\nlet allCreeps: Creep[] = [];\nlet ownedRooms: Room[] = [];\nlet creepsByHomeRoom: Record<string, RoomCreepBuckets> = {};\n\nfunction emptyRoleBuckets(): Record<RoleName, Creep[]> {\n  const byRole = {} as Record<RoleName, Creep[]>;\n  for (const role of ROLE_ORDER) {\n    byRole[role] = [];\n  }\n  return byRole;\n}\n\nfunction ensureFreshTickCache(): void {\n  if (cachedTick === Game.time) return;\n\n  cachedTick = Game.time;\n  allCreeps = Object.values(Game.creeps);\n  ownedRooms = Object.values(Game.rooms).filter((room) => room.controller?.my);\n  creepsByHomeRoom = {};\n\n  for (const creep of allCreeps) {\n    const homeRoom = creep.memory.homeRoom ?? creep.room.name;\n    if (!creepsByHomeRoom[homeRoom]) {\n      creepsByHomeRoom[homeRoom] = {\n        creeps: [],\n        byRole: emptyRoleBuckets()\n      };\n    }\n\n    const bucket = creepsByHomeRoom[homeRoom];\n    bucket.creeps.push(creep);\n    bucket.byRole[creep.memory.role].push(creep);\n  }\n}\n\nexport function getAllCreeps(): Creep[] {\n  ensureFreshTickCache();\n  return allCreeps;\n}\n\nexport function getOwnedRooms(): Room[] {\n  ensureFreshTickCache();\n  return ownedRooms;\n}\n\nexport function getCreepsByHomeRoom(roomName: string): Creep[] {\n  ensureFreshTickCache();\n  return creepsByHomeRoom[roomName]?.creeps ?? [];\n}\n\nexport function getCreepsByHomeRoomAndRole(roomName: string, role: RoleName): Creep[] {\n  ensureFreshTickCache();\n  return creepsByHomeRoom[roomName]?.byRole[role] ?? [];\n}\n\nexport function countCreepsByHomeRoomAndRole(roomName: string, role: RoleName): number {\n  return getCreepsByHomeRoomAndRole(roomName, role).length;\n}\n", "import { ROLE_ORDER, type RoleName } from \"../config/roles\";\nimport { getCreepsByHomeRoom } from \"../runtime/tickCache\";\nimport type { RoomSnapshot } from \"./types\";\n\nfunction emptyRoleCounts(): Record<RoleName, number> {\n  const counts = {} as Record<RoleName, number>;\n  for (const role of ROLE_ORDER) {\n    counts[role] = 0;\n  }\n  return counts;\n}\n\nexport function collectRoomSnapshot(room: Room): RoomSnapshot {\n  const creepsByRole = emptyRoleCounts();\n  for (const creep of getCreepsByHomeRoom(room.name)) {\n    creepsByRole[creep.memory.role] += 1;\n  }\n\n  const structures = room.find(FIND_STRUCTURES);\n  const structuresByType: Partial<Record<StructureConstant, number>> = {};\n  for (const structure of structures) {\n    structuresByType[structure.structureType] = (structuresByType[structure.structureType] ?? 0) + 1;\n  }\n\n  const storageEnergy = room.storage?.store.getUsedCapacity(RESOURCE_ENERGY) ?? 0;\n  const controller = room.controller;\n\n  return {\n    roomName: room.name,\n    rcl: controller?.level ?? 0,\n    energyAvailable: room.energyAvailable,\n    energyCapacityAvailable: room.energyCapacityAvailable,\n    sourceCount: room.find(FIND_SOURCES).length,\n    constructionSiteCount: room.find(FIND_CONSTRUCTION_SITES).length,\n    hostileCount: room.find(FIND_HOSTILE_CREEPS).length,\n    storageEnergy,\n    structuresByType,\n    creepsByRole\n  };\n}\r\n", "import type { ColonyStage } from \"./colonyStages\";\nimport type { RoleName } from \"./roles\";\n\ntype RoleTargetOverrides = Partial<Record<RoleName, number>>;\n\nexport interface RoomControlSettings {\n  roleTargets?: RoleTargetOverrides;\n  roleTargetsByStage?: Partial<Record<ColonyStage, RoleTargetOverrides>>;\n  disablePvP?: boolean;\n  noAttackRooms?: string[];\n  remoteRoomAllowlist?: string[];\n  remoteRoomBlocklist?: string[];\n}\n\ninterface ResolvedRoomControlSettings {\n  roleTargets: RoleTargetOverrides;\n  roleTargetsByStage: Partial<Record<ColonyStage, RoleTargetOverrides>>;\n  disablePvP: boolean;\n  noAttackRooms: string[];\n  remoteRoomAllowlist?: string[];\n  remoteRoomBlocklist: string[];\n}\n\nexport const COLONY_SETTINGS = {\n  pvp: {\n    enabled: false,\n    noAttackRooms: [] as string[]\n  },\n  combat: {\n    offenseEnabled: false,\n    defenseEnabled: true,\n    defendEvenIfOffenseDisabled: true,\n    threatDecayTicks: 30,\n    lowThreatScore: 20,\n    mediumThreatScore: 60,\n    highThreatScore: 120,\n    criticalThreatScore: 220,\n    emergencySoldiersAtMedium: 1,\n    emergencySoldiersAtHigh: 2,\n    emergencySoldiersAtCritical: 4,\n    safeModeThreatLevel: \"critical\" as \"none\" | \"low\" | \"medium\" | \"high\" | \"critical\"\n  },\n  stage: {\n    towersMinRcl: 3,\n    wallsMinRcl: 4,\n    remoteMiningEnabled: false,\n    remoteMiningMinRcl: 3,\n    remoteMiningMinEnergyCapacity: 800,\n    expansionMinRcl: 4,\n    offenseMinRcl: 6,\n    offenseMinStorageEnergy: 100000\n  },\n  planner: {\n    minHarvesters: 2,\n    baseHaulers: 2,\n    minersPerSource: 2,\n    dedicatedHaulersPerSource: 1,\n    freeHaulers: 1,\n    baseUpgraders: 1,\n    buildersWhenSitesExist: 2,\n    buildersWhenNoSites: 1,\n    heavyBuildSiteThreshold: 5,\n    heavyBuilderCount: 3,\n    upgradersByStage: {\n      bootstrap: 1,\n      early: 2,\n      mid: 3,\n      late: 3\n    } as Record<ColonyStage, number>,\n    repairersWhenEstablished: 1,\n    scoutCount: 1,\n    reserverCount: 1,\n    claimerCount: 1,\n    minSoldiers: 2,\n    hostilesPerSoldier: 2\n  },\n  spawn: {\n    reserveEnergyRatio: 0.3\n  },\n  upgrading: {\n    pauseWhenStorageEnergyBelow: 10000,\n    pauseWhenNoStorageFillRatio: 0.7\n  },\n  construction: {\n    runInterval: 37,\n    maxRoomConstructionSites: 10,\n    autoPlaceSpawnInClaimedRooms: true,\n    sourceExtensionsPerSource: 2,\n    sourceExtensionsMinRcl: 2,\n    requireEnergyCapForSourceExtensions: false,\n    sourceExtensionMaxAvgFillRatioToExpand: 0.4\n  },\n  defense: {\n    wallRepairCap: 200000,\n    structureRepairCap: 300000\n  },\n  walls: {\n    targetHitsByRcl: {\n      1: 5000,\n      2: 20000,\n      3: 100000,\n      4: 100000,\n      5: 200000,\n      6: 500000,\n      7: 1000000,\n      8: 2000000\n    } as Record<number, number>\n  },\n  energy: {\n    pickupDroppedEnergyMinAmount: 50,\n    haulerContainerWithdrawMinEnergy: 100\n  },\n  minerals: {\n    enabled: true,\n    minRcl: 6,\n    requireStorage: true,\n    minerCount: 1,\n    haulerCount: 1,\n    containerWithdrawMin: 50,\n    allowTerminalFallback: true,\n    allowContainerFallback: true\n  },\n  movement: {\n    maxRoomsPerPath: 16,\n    defaultRange: 1\n  },\n  logistics: {\n    coreDeliveryRangeFromSpawn: 8\n  },\n  links: {\n    enabled: true,\n    minRcl: 5,\n    senderMinEnergy: 400,\n    receiverMinFreeCapacity: 200,\n    controllerLinkTargetLevel: 600\n  },\n  telemetry: {\n    enabled: true,\n    interval: 50\n  },\n  layout: {\n    scanMin: 6,\n    scanMax: 43,\n    minEdgeDistance: 4,\n    desiredControllerRange: 8,\n    desiredSourceRange: 8\n  },\n  expansion: {\n    autoClaimNeighbors: false,\n    maxConcurrentBootstrapRoomsPerHome: 1,\n    bootstrapperCountPerTargetRoom: 2,\n    manualClaimTargetsByRoom: {\n      E18N7: []\n    } as Record<string, string[]>\n  },\n  roleTargets: {\n    default: {} as RoleTargetOverrides,\n    byStage: {\n      bootstrap: {},\n      early: {},\n      mid: {},\n      late: {}\n    } as Record<ColonyStage, RoleTargetOverrides>\n  },\n  rooms: {\n    // Example:\n    // W1N1: {\n    //   disablePvP: true,\n    //   noAttackRooms: [\"W1N2\"],\n    //   roleTargets: { upgrader: 3, builder: 2 },\n    //   roleTargetsByStage: { mid: { reserver: 2 } }\n    // }\n  } as Record<string, RoomControlSettings>\n};\n\nfunction unique(values: string[]): string[] {\n  return [...new Set(values)];\n}\n\nexport function resolveRoomSettings(roomName: string): ResolvedRoomControlSettings {\n  const roomSettings = COLONY_SETTINGS.rooms[roomName];\n\n  return {\n    roleTargets: roomSettings?.roleTargets ?? {},\n    roleTargetsByStage: roomSettings?.roleTargetsByStage ?? {},\n    disablePvP: roomSettings?.disablePvP ?? false,\n    noAttackRooms: unique([...(COLONY_SETTINGS.pvp.noAttackRooms ?? []), ...(roomSettings?.noAttackRooms ?? [])]),\n    remoteRoomAllowlist: roomSettings?.remoteRoomAllowlist,\n    remoteRoomBlocklist: roomSettings?.remoteRoomBlocklist ?? []\n  };\n}\n\nexport function isAttackAllowed(homeRoom: string, targetRoom: string): boolean {\n  const roomSettings = resolveRoomSettings(homeRoom);\n  const offenseEnabled = COLONY_SETTINGS.combat.offenseEnabled && COLONY_SETTINGS.pvp.enabled;\n  if (!offenseEnabled || roomSettings.disablePvP) return false;\n  return !roomSettings.noAttackRooms.includes(targetRoom);\n}\n\nexport function isRemoteRoomAllowed(homeRoom: string, targetRoom: string): boolean {\n  const roomSettings = resolveRoomSettings(homeRoom);\n  if (roomSettings.remoteRoomBlocklist.includes(targetRoom)) return false;\n  if (roomSettings.remoteRoomAllowlist && roomSettings.remoteRoomAllowlist.length > 0) {\n    return roomSettings.remoteRoomAllowlist.includes(targetRoom);\n  }\n  return true;\n}\n\nfunction isOwnedByMe(roomName: string): boolean {\n  const room = Game.rooms[roomName];\n  return Boolean(room?.controller?.my);\n}\n\nfunction hasMySpawn(roomName: string): boolean {\n  const room = Game.rooms[roomName];\n  if (!room?.controller?.my) return false;\n  return room.find(FIND_MY_SPAWNS).length > 0;\n}\n\nexport function getManualClaimTargets(homeRoom: string): string[] {\n  return unique(COLONY_SETTINGS.expansion.manualClaimTargetsByRoom[homeRoom] ?? []);\n}\n\nfunction ensureExpansionState(homeRoom: string): Record<string, \"pendingClaim\" | \"claimedNoSpawn\" | \"spawnEstablished\"> {\n  if (!Memory.expansionState) {\n    Memory.expansionState = {};\n  }\n\n  if (!Memory.expansionState[homeRoom]) {\n    Memory.expansionState[homeRoom] = {};\n  }\n\n  return Memory.expansionState[homeRoom];\n}\n\nfunction inferExpansionState(targetRoom: string): \"pendingClaim\" | \"claimedNoSpawn\" | \"spawnEstablished\" | null {\n  const room = Game.rooms[targetRoom];\n  if (!room?.controller) return null;\n  if (!room.controller.my) return \"pendingClaim\";\n  return room.find(FIND_MY_SPAWNS).length > 0 ? \"spawnEstablished\" : \"claimedNoSpawn\";\n}\n\nexport function syncExpansionStateForHome(homeRoom: string): void {\n  const state = ensureExpansionState(homeRoom);\n  const targets = getManualClaimTargets(homeRoom);\n\n  for (const targetRoom of targets) {\n    if (!state[targetRoom]) {\n      state[targetRoom] = \"pendingClaim\";\n    }\n\n    const inferred = inferExpansionState(targetRoom);\n    if (!inferred) continue;\n    state[targetRoom] = inferred;\n  }\n}\n\nexport function markManualTargetClaimed(homeRoom: string, targetRoom: string): void {\n  const state = ensureExpansionState(homeRoom);\n  state[targetRoom] = \"claimedNoSpawn\";\n}\n\nexport function getPendingManualClaimTargets(homeRoom: string): string[] {\n  syncExpansionStateForHome(homeRoom);\n  const state = ensureExpansionState(homeRoom);\n  return getManualClaimTargets(homeRoom).filter((roomName) => state[roomName] === \"pendingClaim\");\n}\n\nexport function getBootstrapTargetRooms(homeRoom: string): string[] {\n  syncExpansionStateForHome(homeRoom);\n  const state = ensureExpansionState(homeRoom);\n  const targets = getManualClaimTargets(homeRoom).filter((roomName) => state[roomName] === \"claimedNoSpawn\");\n  const limit = Math.max(0, COLONY_SETTINGS.expansion.maxConcurrentBootstrapRoomsPerHome);\n  if (limit === 0) return [];\n  return targets.slice(0, limit);\n}\n\nexport function getWallTargetHits(rcl: number): number {\n  const target = COLONY_SETTINGS.walls.targetHitsByRcl[rcl];\n  if (target) return target;\n  return rcl >= 8 ? COLONY_SETTINGS.walls.targetHitsByRcl[8] : COLONY_SETTINGS.walls.targetHitsByRcl[1];\n}\n\nexport function isUpgradingPaused(room: Room): boolean {\n  const fillRatio = Math.max(0, Math.min(1, COLONY_SETTINGS.upgrading.pauseWhenNoStorageFillRatio));\n  const requiredEnergy = Math.ceil(room.energyCapacityAvailable * fillRatio);\n\n  const storageThreshold = Math.max(0, COLONY_SETTINGS.upgrading.pauseWhenStorageEnergyBelow);\n  if (room.storage && storageThreshold > 0) {\n    const storageEnergy = room.storage.store.getUsedCapacity(RESOURCE_ENERGY);\n    if (storageEnergy >= storageThreshold) return false;\n    // Fallback for low-capacity/early rooms with storage: allow upgrading when room is well filled.\n    return room.energyAvailable < requiredEnergy;\n  }\n\n  return room.energyAvailable < requiredEnergy;\n}\n", "import { COLONY_SETTINGS } from \"../config/settings\";\nimport { getOwnedRooms } from \"../runtime/tickCache\";\n\nfunction partWeight(part: BodyPartConstant): number {\n  switch (part) {\n    case ATTACK:\n      return 12;\n    case RANGED_ATTACK:\n      return 14;\n    case HEAL:\n      return 18;\n    case WORK:\n      return 6;\n    case TOUGH:\n      return 2;\n    case MOVE:\n      return 1;\n    default:\n      return 0;\n  }\n}\n\nfunction scoreHostile(hostile: Creep): {\n  score: number;\n  attackParts: number;\n  rangedParts: number;\n  healParts: number;\n  workParts: number;\n} {\n  let score = 0;\n  let attackParts = 0;\n  let rangedParts = 0;\n  let healParts = 0;\n  let workParts = 0;\n\n  for (const bodyPart of hostile.body) {\n    if (bodyPart.hits <= 0) continue;\n    score += partWeight(bodyPart.type);\n    if (bodyPart.type === ATTACK) attackParts += 1;\n    if (bodyPart.type === RANGED_ATTACK) rangedParts += 1;\n    if (bodyPart.type === HEAL) healParts += 1;\n    if (bodyPart.type === WORK) workParts += 1;\n  }\n\n  return { score, attackParts, rangedParts, healParts, workParts };\n}\n\nfunction threatLevelFromScore(score: number): ThreatLevel {\n  if (score >= COLONY_SETTINGS.combat.criticalThreatScore) return \"critical\";\n  if (score >= COLONY_SETTINGS.combat.highThreatScore) return \"high\";\n  if (score >= COLONY_SETTINGS.combat.mediumThreatScore) return \"medium\";\n  if (score >= COLONY_SETTINGS.combat.lowThreatScore) return \"low\";\n  return \"none\";\n}\n\nfunction threatLevelRank(level: ThreatLevel): number {\n  switch (level) {\n    case \"critical\":\n      return 4;\n    case \"high\":\n      return 3;\n    case \"medium\":\n      return 2;\n    case \"low\":\n      return 1;\n    default:\n      return 0;\n  }\n}\n\nfunction ensureThreatMemory(): Record<\n  string,\n  {\n    level: ThreatLevel;\n    score: number;\n    hostileCount: number;\n    attackParts: number;\n    rangedParts: number;\n    healParts: number;\n    workParts: number;\n    expiresAt: number;\n  }\n> {\n  if (!Memory.threat) {\n    Memory.threat = {};\n  }\n  return Memory.threat;\n}\n\nfunction ensureRoomStateMemory(): Record<string, RoomLifecycleState> {\n  if (!Memory.roomState) {\n    Memory.roomState = {};\n  }\n  return Memory.roomState;\n}\n\nfunction setRoomState(room: Room, threatLevel: ThreatLevel): void {\n  const roomState = ensureRoomStateMemory();\n\n  if (threatLevel === \"high\" || threatLevel === \"critical\") {\n    roomState[room.name] = \"war\";\n    return;\n  }\n\n  if (threatLevel === \"medium\" || threatLevel === \"low\") {\n    roomState[room.name] = \"recovery\";\n    return;\n  }\n\n  const rcl = room.controller?.level ?? 0;\n  if (rcl <= 1) {\n    roomState[room.name] = \"bootstrap\";\n  } else if (rcl <= 4) {\n    roomState[room.name] = \"developing\";\n  } else {\n    roomState[room.name] = \"mature\";\n  }\n}\n\nfunction refreshThreatForRoom(room: Room): void {\n  const hostiles = room.find(FIND_HOSTILE_CREEPS);\n  const threat = ensureThreatMemory();\n  const existing = threat[room.name];\n\n  if (hostiles.length === 0) {\n    if (existing && existing.expiresAt > Game.time) {\n      setRoomState(room, existing.level);\n      return;\n    }\n\n    threat[room.name] = {\n      level: \"none\",\n      score: 0,\n      hostileCount: 0,\n      attackParts: 0,\n      rangedParts: 0,\n      healParts: 0,\n      workParts: 0,\n      expiresAt: Game.time\n    };\n    setRoomState(room, \"none\");\n    return;\n  }\n\n  let score = 0;\n  let attackParts = 0;\n  let rangedParts = 0;\n  let healParts = 0;\n  let workParts = 0;\n\n  for (const hostile of hostiles) {\n    const hostileScore = scoreHostile(hostile);\n    score += hostileScore.score;\n    attackParts += hostileScore.attackParts;\n    rangedParts += hostileScore.rangedParts;\n    healParts += hostileScore.healParts;\n    workParts += hostileScore.workParts;\n  }\n\n  const level = threatLevelFromScore(score);\n  threat[room.name] = {\n    level,\n    score,\n    hostileCount: hostiles.length,\n    attackParts,\n    rangedParts,\n    healParts,\n    workParts,\n    expiresAt: Game.time + COLONY_SETTINGS.combat.threatDecayTicks\n  };\n\n  const requiredSafeModeLevel = COLONY_SETTINGS.combat.safeModeThreatLevel;\n  if (\n    threatLevelRank(level) >= threatLevelRank(requiredSafeModeLevel) &&\n    room.controller &&\n    !room.controller.safeMode &&\n    room.controller.safeModeAvailable > 0 &&\n    room.controller.safeModeCooldown === undefined\n  ) {\n    const hostileNearCriticalAssets = hostiles.some((hostile) => {\n      const nearSpawn = room.find(FIND_MY_SPAWNS).some((spawn) => hostile.pos.getRangeTo(spawn) <= 3);\n      const nearController = hostile.pos.getRangeTo(room.controller as StructureController) <= 3;\n      return nearSpawn || nearController;\n    });\n\n    if (hostileNearCriticalAssets) {\n      room.controller.activateSafeMode();\n    }\n  }\n\n  setRoomState(room, level);\n}\n\nexport function getEmergencySoldierCount(roomName: string): number {\n  const threat = Memory.threat?.[roomName];\n  if (!threat || threat.expiresAt < Game.time) return 0;\n\n  switch (threat.level) {\n    case \"critical\":\n      return COLONY_SETTINGS.combat.emergencySoldiersAtCritical;\n    case \"high\":\n      return COLONY_SETTINGS.combat.emergencySoldiersAtHigh;\n    case \"medium\":\n      return COLONY_SETTINGS.combat.emergencySoldiersAtMedium;\n    default:\n      return 0;\n  }\n}\n\nexport function runThreatManager(): void {\n  for (const room of getOwnedRooms()) {\n    refreshThreatForRoom(room);\n  }\n}\n", "import type { CapabilityFlags, ColonyStage } from \"../config/colonyStages\";\nimport {\n  COLONY_SETTINGS,\n  getBootstrapTargetRooms,\n  getPendingManualClaimTargets,\n  isUpgradingPaused,\n  isRemoteRoomAllowed,\n  resolveRoomSettings\n} from \"../config/settings\";\nimport { ROLE_ORDER, type RoleName } from \"../config/roles\";\nimport { getEmergencySoldierCount } from \"../managers/threatManager\";\nimport type { RoomSnapshot } from \"./types\";\n\nfunction baseDesired(): Record<RoleName, number> {\n  const desired = {} as Record<RoleName, number>;\n  for (const role of ROLE_ORDER) {\n    desired[role] = 0;\n  }\n  return desired;\n}\n\nfunction applyRoleOverrides(target: Record<RoleName, number>, overrides: Partial<Record<RoleName, number>>): void {\n  for (const role of ROLE_ORDER) {\n    const desired = overrides[role];\n    if (desired === undefined) continue;\n    target[role] = Math.max(0, desired);\n  }\n}\n\nfunction shouldRunMineralPipeline(snapshot: RoomSnapshot): boolean {\n  if (!COLONY_SETTINGS.minerals.enabled) return false;\n  if (snapshot.rcl < COLONY_SETTINGS.minerals.minRcl) return false;\n\n  const room = Game.rooms[snapshot.roomName];\n  if (!room) return false;\n\n  if (COLONY_SETTINGS.minerals.requireStorage && !room.storage) return false;\n\n  const mineral = room.find(FIND_MINERALS)[0];\n  return Boolean(mineral && mineral.mineralAmount > 0);\n}\n\nfunction shouldSpawnClaimer(snapshot: RoomSnapshot): boolean {\n  if (!COLONY_SETTINGS.expansion.autoClaimNeighbors) {\n    return getPendingManualClaimTargets(snapshot.roomName).length > 0;\n  }\n\n  const exits = Game.map.describeExits(snapshot.roomName);\n  if (!exits) return false;\n\n  const neighbors = [...new Set(Object.values(exits))];\n  for (const neighbor of neighbors) {\n    if (!isRemoteRoomAllowed(snapshot.roomName, neighbor)) continue;\n\n    const room = Game.rooms[neighbor];\n    if (!room?.controller) return true;\n    if (!room.controller.owner && !room.controller.reservation) return true;\n  }\n\n  return false;\n}\n\nexport function deriveDesiredRoles(\n  snapshot: RoomSnapshot,\n  stage: ColonyStage,\n  capabilities: CapabilityFlags\n): Record<RoleName, number> {\n  const desired = baseDesired();\n  const roomSettings = resolveRoomSettings(snapshot.roomName);\n  const roomState = Memory.roomState?.[snapshot.roomName] ?? \"developing\";\n\n  // Always keep a minimum survival workforce so a room can recover from wipes.\n  desired.harvester = Math.max(COLONY_SETTINGS.planner.minHarvesters, snapshot.sourceCount);\n  desired.hauler = COLONY_SETTINGS.planner.baseHaulers;\n  desired.upgrader = COLONY_SETTINGS.planner.baseUpgraders;\n  desired.builder =\n    snapshot.constructionSiteCount > 0\n      ? COLONY_SETTINGS.planner.buildersWhenSitesExist\n      : COLONY_SETTINGS.planner.buildersWhenNoSites;\n\n  if (stage !== \"bootstrap\") {\n    const canRunDedicatedMiners = snapshot.energyCapacityAvailable >= 400;\n    const minersPerSource = stage === \"early\" ? 1 : Math.max(1, COLONY_SETTINGS.planner.minersPerSource);\n    const dedicatedHaulersPerSource = Math.max(0, COLONY_SETTINGS.planner.dedicatedHaulersPerSource);\n    const freeHaulers = stage === \"early\" ? 0 : Math.max(0, COLONY_SETTINGS.planner.freeHaulers);\n    desired.harvester = canRunDedicatedMiners\n      ? Math.min(desired.harvester, 1)\n      : Math.max(COLONY_SETTINGS.planner.minHarvesters, snapshot.sourceCount);\n    desired.miner = canRunDedicatedMiners ? snapshot.sourceCount * minersPerSource : 0;\n    desired.hauler = Math.max(\n      desired.hauler,\n      snapshot.sourceCount * dedicatedHaulersPerSource + freeHaulers\n    );\n    desired.upgrader = COLONY_SETTINGS.planner.upgradersByStage[stage];\n    desired.builder =\n      snapshot.constructionSiteCount > COLONY_SETTINGS.planner.heavyBuildSiteThreshold\n        ? COLONY_SETTINGS.planner.heavyBuilderCount\n        : desired.builder;\n    desired.repairer = COLONY_SETTINGS.planner.repairersWhenEstablished;\n  }\n\n  if (capabilities.allowWalls) {\n    desired.waller = 1;\n  }\n\n  if (capabilities.allowRemoteMining) {\n    desired.scout = COLONY_SETTINGS.planner.scoutCount;\n    desired.reserver = COLONY_SETTINGS.planner.reserverCount;\n  }\n\n  if (capabilities.allowExpansion && shouldSpawnClaimer(snapshot)) {\n    desired.claimer = COLONY_SETTINGS.planner.claimerCount;\n  }\n\n  const bootstrapTargets = getBootstrapTargetRooms(snapshot.roomName);\n  if (bootstrapTargets.length > 0) {\n    desired.bootstrapper = bootstrapTargets.length * COLONY_SETTINGS.expansion.bootstrapperCountPerTargetRoom;\n  }\n\n  if (capabilities.allowOffense) {\n    desired.soldier = Math.max(\n      COLONY_SETTINGS.planner.minSoldiers,\n      Math.ceil(snapshot.hostileCount / Math.max(1, COLONY_SETTINGS.planner.hostilesPerSoldier))\n    );\n  }\n\n  if (shouldRunMineralPipeline(snapshot)) {\n    desired.mineralMiner = COLONY_SETTINGS.minerals.minerCount;\n    desired.mineralHauler = COLONY_SETTINGS.minerals.haulerCount;\n  }\n\n  const emergencySoldiers = getEmergencySoldierCount(snapshot.roomName);\n  if (emergencySoldiers > 0) {\n    desired.soldier = Math.max(desired.soldier, emergencySoldiers);\n  }\n\n  if (roomState === \"war\") {\n    desired.upgrader = Math.min(desired.upgrader, 1);\n    desired.builder = Math.min(desired.builder, 1);\n    desired.hauler = Math.max(desired.hauler, snapshot.sourceCount + 1);\n    desired.repairer = Math.max(desired.repairer, 2);\n  } else if (roomState === \"recovery\") {\n    desired.upgrader = Math.min(desired.upgrader, 2);\n    desired.repairer = Math.max(desired.repairer, 1);\n  }\n\n  const room = Game.rooms[snapshot.roomName];\n  if (room && isUpgradingPaused(room)) {\n    desired.upgrader = 0;\n  }\n\n  applyRoleOverrides(desired, COLONY_SETTINGS.roleTargets.default);\n  applyRoleOverrides(desired, COLONY_SETTINGS.roleTargets.byStage[stage] ?? {});\n  applyRoleOverrides(desired, roomSettings.roleTargets);\n  applyRoleOverrides(desired, roomSettings.roleTargetsByStage[stage] ?? {});\n\n  return desired;\n}\n", "export type ColonyStage = \"bootstrap\" | \"early\" | \"mid\" | \"late\";\n\nexport interface StageThresholdConfig {\n  stage: ColonyStage;\n  minRcl: number;\n  minEnergyCapacity: number;\n}\n\nexport const STAGE_THRESHOLDS: StageThresholdConfig[] = [\n  { stage: \"late\", minRcl: 6, minEnergyCapacity: 1800 },\n  { stage: \"mid\", minRcl: 4, minEnergyCapacity: 800 },\n  { stage: \"early\", minRcl: 2, minEnergyCapacity: 450 },\n  { stage: \"bootstrap\", minRcl: 0, minEnergyCapacity: 0 }\n];\n\nexport interface CapabilityFlags {\n  allowRoads: boolean;\n  allowTowers: boolean;\n  allowWalls: boolean;\n  allowRemoteMining: boolean;\n  allowExpansion: boolean;\n  allowOffense: boolean;\n}\r\n", "import { STAGE_THRESHOLDS, type CapabilityFlags, type ColonyStage } from \"../config/colonyStages\";\nimport { COLONY_SETTINGS, resolveRoomSettings } from \"../config/settings\";\nimport { getOwnedRooms } from \"../runtime/tickCache\";\nimport type { RoomSnapshot } from \"./types\";\n\nfunction deriveStage(snapshot: RoomSnapshot): ColonyStage {\n  for (const threshold of STAGE_THRESHOLDS) {\n    if (snapshot.rcl >= threshold.minRcl && snapshot.energyCapacityAvailable >= threshold.minEnergyCapacity) {\n      return threshold.stage;\n    }\n  }\n\n  return \"bootstrap\";\n}\n\nfunction ownedRoomCount(): number {\n  return getOwnedRooms().length;\n}\n\nfunction canExpand(snapshot: RoomSnapshot): boolean {\n  const gclLevel = Game.gcl.level;\n  const myRooms = ownedRoomCount();\n  return snapshot.rcl >= COLONY_SETTINGS.stage.expansionMinRcl && gclLevel > myRooms;\n}\n\nfunction canAttack(snapshot: RoomSnapshot): boolean {\n  const roomSettings = resolveRoomSettings(snapshot.roomName);\n  if (!COLONY_SETTINGS.combat.offenseEnabled || !COLONY_SETTINGS.pvp.enabled || roomSettings.disablePvP) return false;\n  return (\n    snapshot.rcl >= COLONY_SETTINGS.stage.offenseMinRcl &&\n    snapshot.storageEnergy >= COLONY_SETTINGS.stage.offenseMinStorageEnergy\n  );\n}\n\nexport function deriveCapabilities(snapshot: RoomSnapshot, stage: ColonyStage): CapabilityFlags {\n  return {\n    allowRoads: stage !== \"bootstrap\",\n    allowTowers: snapshot.rcl >= COLONY_SETTINGS.stage.towersMinRcl,\n    allowWalls: snapshot.rcl >= COLONY_SETTINGS.stage.wallsMinRcl,\n    allowRemoteMining:\n      COLONY_SETTINGS.stage.remoteMiningEnabled &&\n      snapshot.rcl >= COLONY_SETTINGS.stage.remoteMiningMinRcl &&\n      snapshot.energyCapacityAvailable >= COLONY_SETTINGS.stage.remoteMiningMinEnergyCapacity,\n    allowExpansion: canExpand(snapshot),\n    allowOffense: canAttack(snapshot)\n  };\n}\n\nexport function deriveStageAndCapabilities(snapshot: RoomSnapshot): { stage: ColonyStage; capabilities: CapabilityFlags } {\n  const stage = deriveStage(snapshot);\n  const capabilities = deriveCapabilities(snapshot, stage);\n  return { stage, capabilities };\n}\r\n", "import type { ColonyStrategy } from \"./types\";\nimport {\n  COLONY_SETTINGS,\n  getBootstrapTargetRooms,\n  getPendingManualClaimTargets,\n  isAttackAllowed,\n  isRemoteRoomAllowed\n} from \"../config/settings\";\n\nfunction unique(values: string[]): string[] {\n  return [...new Set(values)];\n}\n\nfunction neighboringRooms(room: Room): string[] {\n  const exits = Game.map.describeExits(room.name);\n  if (!exits) return [];\n  return unique(Object.values(exits));\n}\n\nexport function deriveTargetRooms(room: Room, strategy: ColonyStrategy): ColonyStrategy {\n  const visibleNeighbors = neighboringRooms(room);\n  const allowedRemoteNeighbors = visibleNeighbors.filter((name) => isRemoteRoomAllowed(room.name, name));\n\n  const scoutTargetRooms = visibleNeighbors;\n  const reserveTargetRooms = strategy.capabilities.allowRemoteMining ? allowedRemoteNeighbors : [];\n\n  const autoClaimTargetRooms = allowedRemoteNeighbors.filter((name) => {\n    const targetRoom = Game.rooms[name];\n    if (!targetRoom?.controller) return true;\n    return !targetRoom.controller.owner && !targetRoom.controller.reservation;\n  });\n\n  const manualClaimTargetRooms = getPendingManualClaimTargets(room.name);\n  const bootstrapTargetRooms = getBootstrapTargetRooms(room.name);\n  const desiredClaimList = COLONY_SETTINGS.expansion.autoClaimNeighbors ? autoClaimTargetRooms : manualClaimTargetRooms;\n  const claimTargetRooms = strategy.capabilities.allowExpansion && desiredClaimList.length > 0 ? [desiredClaimList[0]] : [];\n\n  const attackTargetRooms = strategy.capabilities.allowOffense\n    ? visibleNeighbors.filter((name) => {\n        if (!isAttackAllowed(room.name, name)) return false;\n        const targetRoom = Game.rooms[name];\n        if (!targetRoom) return false;\n        return targetRoom.find(FIND_HOSTILE_CREEPS).length > 0;\n      })\n    : [];\n\n  const localThreat = Memory.threat?.[room.name];\n  const shouldDefendLocalRoom =\n    COLONY_SETTINGS.combat.defenseEnabled &&\n    localThreat !== undefined &&\n    localThreat.expiresAt >= Game.time &&\n    localThreat.level !== \"none\";\n  if (shouldDefendLocalRoom && !attackTargetRooms.includes(room.name)) {\n    attackTargetRooms.unshift(room.name);\n  }\n\n  return {\n    ...strategy,\n    scoutTargetRooms,\n    reserveTargetRooms,\n    claimTargetRooms,\n    bootstrapTargetRooms,\n    attackTargetRooms\n  };\n}\n", "import { collectRoomSnapshot } from \"../colony/intel\";\nimport { deriveDesiredRoles } from \"../colony/spawnPlanner\";\nimport { deriveStageAndCapabilities } from \"../colony/stageManager\";\nimport { deriveTargetRooms } from \"../colony/strategyManager\";\nimport { syncExpansionStateForHome } from \"../config/settings\";\nimport { getOwnedRooms } from \"../runtime/tickCache\";\nimport type { ColonyStrategy } from \"../colony/types\";\n\nexport function runColonyManager(): void {\n  for (const room of getOwnedRooms()) {\n    syncExpansionStateForHome(room.name);\n\n    const snapshot = collectRoomSnapshot(room);\n    const { stage, capabilities } = deriveStageAndCapabilities(snapshot);\n    const desiredRoles = deriveDesiredRoles(snapshot, stage, capabilities);\n\n    const baseStrategy: ColonyStrategy = {\n      stage,\n      capabilities,\n      desiredRoles,\n      scoutTargetRooms: [],\n      reserveTargetRooms: [],\n      claimTargetRooms: [],\n      bootstrapTargetRooms: [],\n      attackTargetRooms: []\n    };\n\n    const resolved = deriveTargetRooms(room, baseStrategy);\n\n    if (!Memory.strategy) {\n      Memory.strategy = {};\n    }\n\n    Memory.strategy[room.name] = resolved;\n  }\n}\r\n", "import { COLONY_SETTINGS } from \"../config/settings\";\n\ninterface CandidateScore {\n  x: number;\n  y: number;\n  score: number;\n}\n\nfunction isWalkable(room: Room, x: number, y: number): boolean {\n  if (x < 1 || x > 48 || y < 1 || y > 48) return false;\n  return room.getTerrain().get(x, y) !== TERRAIN_MASK_WALL;\n}\n\nfunction edgePenalty(x: number, y: number): number {\n  const distanceToEdge = Math.min(x, 49 - x, y, 49 - y);\n  if (distanceToEdge >= COLONY_SETTINGS.layout.minEdgeDistance) return 0;\n  return (COLONY_SETTINGS.layout.minEdgeDistance - distanceToEdge) * 20;\n}\n\nfunction walkableAreaScore(room: Room, x: number, y: number): number {\n  let walkable = 0;\n\n  for (let dx = -4; dx <= 4; dx += 1) {\n    for (let dy = -4; dy <= 4; dy += 1) {\n      if (isWalkable(room, x + dx, y + dy)) {\n        walkable += 1;\n      }\n    }\n  }\n\n  return walkable * 2;\n}\n\nfunction distanceScore(distance: number, desired: number): number {\n  return Math.max(0, 50 - Math.abs(distance - desired) * 4);\n}\n\nfunction scoreAnchor(room: Room, x: number, y: number): number {\n  if (!isWalkable(room, x, y)) return Number.NEGATIVE_INFINITY;\n\n  const look = room.lookForAt(LOOK_STRUCTURES, x, y);\n  if (look.length > 0) return Number.NEGATIVE_INFINITY;\n\n  let score = walkableAreaScore(room, x, y);\n  score -= edgePenalty(x, y);\n\n  const controller = room.controller;\n  if (controller) {\n    score += distanceScore(controller.pos.getRangeTo(x, y), COLONY_SETTINGS.layout.desiredControllerRange);\n  }\n\n  const sources = room.find(FIND_SOURCES);\n  for (const source of sources) {\n    score += distanceScore(source.pos.getRangeTo(x, y), COLONY_SETTINGS.layout.desiredSourceRange);\n  }\n\n  return score;\n}\n\nfunction bestAnchorCandidate(room: Room): CandidateScore | null {\n  let best: CandidateScore | null = null;\n\n  for (let x = COLONY_SETTINGS.layout.scanMin; x <= COLONY_SETTINGS.layout.scanMax; x += 1) {\n    for (let y = COLONY_SETTINGS.layout.scanMin; y <= COLONY_SETTINGS.layout.scanMax; y += 1) {\n      const score = scoreAnchor(room, x, y);\n      if (!Number.isFinite(score)) continue;\n\n      if (!best || score > best.score) {\n        best = { x, y, score };\n      }\n    }\n  }\n\n  return best;\n}\n\nexport function getRoomAnchor(room: Room): RoomPosition | null {\n  if (!Memory.roomPlans) {\n    Memory.roomPlans = {};\n  }\n\n  const cached = Memory.roomPlans[room.name];\n  if (cached && isWalkable(room, cached.anchorX, cached.anchorY)) {\n    return new RoomPosition(cached.anchorX, cached.anchorY, room.name);\n  }\n\n  const spawn = room.find(FIND_MY_SPAWNS)[0];\n  if (spawn) {\n    Memory.roomPlans[room.name] = {\n      anchorX: spawn.pos.x,\n      anchorY: spawn.pos.y,\n      score: 0,\n      createdAt: Game.time\n    };\n    return spawn.pos;\n  }\n\n  const candidate = bestAnchorCandidate(room);\n  if (!candidate) return null;\n\n  Memory.roomPlans[room.name] = {\n    anchorX: candidate.x,\n    anchorY: candidate.y,\n    score: candidate.score,\n    createdAt: Game.time\n  };\n\n  return new RoomPosition(candidate.x, candidate.y, room.name);\n}\n", "import { COLONY_SETTINGS } from \"../config/settings\";\n\nexport function moveToTarget(creep: Creep, target: RoomPosition | { pos: RoomPosition }, range = 1): void {\n  creep.moveTo(target, {\n    reusePath: 10,\n    maxRooms: COLONY_SETTINGS.movement.maxRoomsPerPath,\n    range: range ?? COLONY_SETTINGS.movement.defaultRange,\n    visualizePathStyle: { stroke: \"#8ecae6\" }\n  });\n}\n\nexport function moveToRoomCenter(creep: Creep, roomName: string): void {\n  const target = new RoomPosition(25, 25, roomName);\n  moveToTarget(creep, target, 20);\n}\r\n", "import { COLONY_SETTINGS } from \"../config/settings\";\nimport { moveToTarget } from \"./movement\";\n\nfunction nonEnergyResourcesInStore(store: StoreDefinition): ResourceConstant[] {\n  const keys = Object.keys(store) as ResourceConstant[];\n  return keys.filter((resource) => resource !== RESOURCE_ENERGY && store.getUsedCapacity(resource) > 0);\n}\n\nexport function roomMineral(room: Room): Mineral | null {\n  return room.find(FIND_MINERALS)[0] ?? null;\n}\n\nexport function roomMineralExtractor(room: Room): StructureExtractor | null {\n  const mineral = roomMineral(room);\n  if (!mineral) return null;\n\n  const structure = mineral.pos\n    .lookFor(LOOK_STRUCTURES)\n    .find((entry) => entry.structureType === STRUCTURE_EXTRACTOR) as StructureExtractor | undefined;\n\n  return structure ?? null;\n}\n\nexport function roomMineralContainer(room: Room): StructureContainer | null {\n  const mineral = roomMineral(room);\n  if (!mineral) return null;\n\n  const containers = mineral.pos.findInRange(FIND_STRUCTURES, 1, {\n    filter: (structure: Structure) => structure.structureType === STRUCTURE_CONTAINER\n  }) as StructureContainer[];\n\n  return containers[0] ?? null;\n}\n\nexport function harvestMineral(creep: Creep): boolean {\n  const mineral = roomMineral(creep.room);\n  if (!mineral || mineral.mineralAmount <= 0) return false;\n\n  const extractor = roomMineralExtractor(creep.room);\n  if (!extractor || extractor.cooldown > 0) return false;\n\n  const result = creep.harvest(mineral);\n  if (result === ERR_NOT_IN_RANGE) {\n    moveToTarget(creep, mineral);\n    return true;\n  }\n\n  return result === OK;\n}\n\nexport function withdrawMineralsFromContainer(creep: Creep): boolean {\n  const container = creep.pos.findClosestByPath(FIND_STRUCTURES, {\n    filter: (structure: Structure) => {\n      if (structure.structureType !== STRUCTURE_CONTAINER) return false;\n      const store = (structure as StructureContainer).store;\n      const nonEnergyAmount = store.getUsedCapacity() - store.getUsedCapacity(RESOURCE_ENERGY);\n      return nonEnergyAmount >= COLONY_SETTINGS.minerals.containerWithdrawMin;\n    }\n  }) as StructureContainer | null;\n\n  if (!container) return false;\n\n  const resources = nonEnergyResourcesInStore(container.store);\n  const resource = resources[0];\n  if (!resource) return false;\n\n  const result = creep.withdraw(container, resource);\n  if (result === ERR_NOT_IN_RANGE) {\n    moveToTarget(creep, container);\n    return true;\n  }\n\n  return result === OK;\n}\n\nexport function pickupDroppedMinerals(creep: Creep): boolean {\n  const dropped = creep.pos.findClosestByPath(FIND_DROPPED_RESOURCES, {\n    filter: (resource: Resource) => resource.resourceType !== RESOURCE_ENERGY && resource.amount > 0\n  });\n\n  if (!dropped) return false;\n\n  const result = creep.pickup(dropped);\n  if (result === ERR_NOT_IN_RANGE) {\n    moveToTarget(creep, dropped);\n    return true;\n  }\n\n  return result === OK;\n}\n\nexport function transferCarriedMinerals(creep: Creep): boolean {\n  const target =\n    creep.room.storage ??\n    (COLONY_SETTINGS.minerals.allowTerminalFallback ? creep.room.terminal : null) ??\n    (COLONY_SETTINGS.minerals.allowContainerFallback\n      ? (creep.pos.findClosestByPath(FIND_STRUCTURES, {\n          filter: (structure: Structure) => structure.structureType === STRUCTURE_CONTAINER\n        }) as StructureContainer | null)\n      : null);\n\n  if (!target) return false;\n\n  const resources = nonEnergyResourcesInStore(creep.store);\n  const resource = resources[0];\n  if (!resource) return false;\n\n  const result = creep.transfer(target, resource);\n  if (result === ERR_NOT_IN_RANGE) {\n    moveToTarget(creep, target);\n    return true;\n  }\n\n  return result === OK;\n}\n", "import { COLONY_SETTINGS } from \"../config/settings\";\nimport { getRoomAnchor } from \"../colony/layoutPlanner\";\nimport { getOwnedRooms } from \"../runtime/tickCache\";\nimport { roomMineral } from \"../tasks/minerals\";\n\nconst CORE_RESERVED_OFFSETS = new Set<string>([\n  // Tower anchors (already managed by placeTowers).\n  \"3,0\",\n  \"-3,0\",\n  \"0,3\",\n  \"0,-3\",\n  // Endgame core anchors.\n  \"1,1\",\n  \"1,-1\",\n  \"-1,1\",\n  \"-1,-1\",\n  \"0,2\",\n  \"2,0\",\n  // Future lab corridor (kept clear intentionally).\n  \"4,-1\",\n  \"4,0\",\n  \"4,1\",\n  \"5,-1\",\n  \"5,0\",\n  \"5,1\",\n  \"6,-1\",\n  \"6,0\",\n  \"6,1\",\n  \"5,2\"\n]);\n\nconst CORE_EXTENSION_OFFSETS: Array<[number, number]> = [\n  [2, 0],\n  [-2, 0],\n  [0, 2],\n  [0, -2],\n  [2, 2],\n  [2, -2],\n  [-2, 2],\n  [-2, -2],\n  [1, 3],\n  [-1, 3],\n  [1, -3],\n  [-1, -3],\n  [3, 1],\n  [3, -1],\n  [-3, 1],\n  [-3, -1],\n  [2, 3],\n  [-2, 3],\n  [2, -3],\n  [-2, -3],\n  [3, 2],\n  [3, -2],\n  [-3, 2],\n  [-3, -2],\n  [1, 4],\n  [-1, 4],\n  [1, -4],\n  [-1, -4],\n  [4, 2],\n  [4, -2],\n  [-4, 2],\n  [-4, -2]\n];\n\nfunction placeIfFree(room: Room, x: number, y: number, structureType: BuildableStructureConstant): boolean {\n  if (x < 1 || x > 48 || y < 1 || y > 48) return false;\n  if (room.getTerrain().get(x, y) === TERRAIN_MASK_WALL) return false;\n\n  const look = room.lookForAt(LOOK_STRUCTURES, x, y);\n  if (look.length > 0) return false;\n\n  const sites = room.lookForAt(LOOK_CONSTRUCTION_SITES, x, y);\n  if (sites.length > 0) return false;\n\n  return room.createConstructionSite(x, y, structureType) === OK;\n}\n\nfunction extensionBuiltAndSiteCount(room: Room): number {\n  const max = CONTROLLER_STRUCTURES[STRUCTURE_EXTENSION][room.controller?.level ?? 0] ?? 0;\n  if (max === 0) return 0;\n\n  const built = room.find(FIND_MY_STRUCTURES, {\n    filter: (structure: Structure) => structure.structureType === STRUCTURE_EXTENSION\n  }).length;\n  const sites = room.find(FIND_MY_CONSTRUCTION_SITES, {\n    filter: (site: ConstructionSite) => site.structureType === STRUCTURE_EXTENSION\n  }).length;\n\n  return built + sites;\n}\n\nfunction sourceExtensionBuiltAndSiteCount(room: Room): number {\n  const built = room.find(FIND_MY_STRUCTURES, {\n    filter: (structure: Structure) => isSourceExtensionPosition(room, structure)\n  }).length;\n  const sites = room.find(FIND_MY_CONSTRUCTION_SITES, {\n    filter: (site: ConstructionSite) => {\n      if (site.structureType !== STRUCTURE_EXTENSION) return false;\n      const sources = room.find(FIND_SOURCES);\n      return sources.some((source) => site.pos.getRangeTo(source) <= 2);\n    }\n  }).length;\n  return built + sites;\n}\n\nfunction maxExtensions(room: Room): number {\n  return CONTROLLER_STRUCTURES[STRUCTURE_EXTENSION][room.controller?.level ?? 0] ?? 0;\n}\n\nfunction structureBuiltAndSiteCount(room: Room, structureType: BuildableStructureConstant): number {\n  const built = room.find(FIND_MY_STRUCTURES, {\n    filter: (structure: Structure) => structure.structureType === structureType\n  }).length;\n  const sites = room.find(FIND_MY_CONSTRUCTION_SITES, {\n    filter: (site: ConstructionSite) => site.structureType === structureType\n  }).length;\n  return built + sites;\n}\n\nfunction structureRemainingCapacity(room: Room, structureType: BuildableStructureConstant): number {\n  const max = CONTROLLER_STRUCTURES[structureType][room.controller?.level ?? 0] ?? 0;\n  if (max <= 0) return 0;\n  const used = structureBuiltAndSiteCount(room, structureType);\n  return Math.max(0, max - used);\n}\n\nfunction isFreeBuildTile(room: Room, x: number, y: number): boolean {\n  if (x < 1 || x > 48 || y < 1 || y > 48) return false;\n  if (room.getTerrain().get(x, y) === TERRAIN_MASK_WALL) return false;\n  if (room.lookForAt(LOOK_STRUCTURES, x, y).length > 0) return false;\n  if (room.lookForAt(LOOK_CONSTRUCTION_SITES, x, y).length > 0) return false;\n  return true;\n}\n\nfunction hasPendingSourceExtensionCandidates(room: Room, anchor: RoomPosition): boolean {\n  const perSource = Math.max(0, COLONY_SETTINGS.construction.sourceExtensionsPerSource);\n  if (perSource === 0) return false;\n\n  const sources = room.find(FIND_SOURCES);\n  for (const source of sources) {\n    const existing = source.pos.findInRange(FIND_MY_STRUCTURES, 2, {\n      filter: (structure: Structure) => structure.structureType === STRUCTURE_EXTENSION\n    }).length;\n    const pending = source.pos.findInRange(FIND_MY_CONSTRUCTION_SITES, 2, {\n      filter: (site: ConstructionSite) => site.structureType === STRUCTURE_EXTENSION\n    }).length;\n\n    if (existing + pending >= perSource) continue;\n\n    const candidates = extensionCandidatesNearSource(room, anchor, source);\n    if (candidates.some(([x, y]) => isFreeBuildTile(room, x, y))) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction sourceExtensionTargetCount(room: Room): number {\n  const perSource = Math.max(0, COLONY_SETTINGS.construction.sourceExtensionsPerSource);\n  if (perSource === 0) return 0;\n  return room.find(FIND_SOURCES).length * perSource;\n}\n\nfunction placeCoreExtensions(room: Room, anchor: RoomPosition): void {\n  const max = maxExtensions(room);\n  if (max === 0) return;\n\n  const sourceTarget = Math.min(max, sourceExtensionTargetCount(room));\n  const sourcePlaced = sourceExtensionBuiltAndSiteCount(room);\n  const sourceCanStillGrow = shouldPlaceSourceExtensions(room) && hasPendingSourceExtensionCandidates(room, anchor);\n  const reservedForSources = sourceCanStillGrow ? sourceTarget : sourcePlaced;\n  const coreCap = Math.max(0, max - reservedForSources);\n\n  let used = extensionBuiltAndSiteCount(room);\n  if (used >= coreCap) return;\n\n  for (const [dx, dy] of CORE_EXTENSION_OFFSETS) {\n    if (used >= coreCap) break;\n    if (CORE_RESERVED_OFFSETS.has(`${dx},${dy}`)) continue;\n\n    placeIfFree(room, anchor.x + dx, anchor.y + dy, STRUCTURE_EXTENSION);\n    used = extensionBuiltAndSiteCount(room);\n  }\n}\n\nfunction isSourceExtensionPosition(room: Room, structure: Structure): boolean {\n  if (structure.structureType !== STRUCTURE_EXTENSION) return false;\n  const sources = room.find(FIND_SOURCES);\n  return sources.some((source) => structure.pos.getRangeTo(source) <= 2);\n}\n\nfunction sourceExtensionAvgFill(room: Room): number {\n  const sourceExtensions = room.find(FIND_MY_STRUCTURES, {\n    filter: (structure: Structure) => isSourceExtensionPosition(room, structure)\n  }) as StructureExtension[];\n\n  if (sourceExtensions.length === 0) return 0;\n\n  const ratios = sourceExtensions.map((extension) => {\n    const used = extension.store.getUsedCapacity(RESOURCE_ENERGY);\n    const total = extension.store.getCapacity(RESOURCE_ENERGY);\n    if (!total) return 0;\n    return used / total;\n  });\n\n  return ratios.reduce((sum, ratio) => sum + ratio, 0) / ratios.length;\n}\n\nfunction shouldPlaceSourceExtensions(room: Room): boolean {\n  const rcl = room.controller?.level ?? 0;\n  if (rcl < COLONY_SETTINGS.construction.sourceExtensionsMinRcl) return false;\n\n  if (COLONY_SETTINGS.construction.requireEnergyCapForSourceExtensions) {\n    if (room.energyAvailable < room.energyCapacityAvailable) return false;\n  }\n\n  return sourceExtensionAvgFill(room) <= COLONY_SETTINGS.construction.sourceExtensionMaxAvgFillRatioToExpand;\n}\n\nfunction extensionCandidatesNearSource(room: Room, anchor: RoomPosition, source: Source): Array<[number, number]> {\n  const terrain = room.getTerrain();\n  const positions: Array<[number, number]> = [];\n\n  for (let dx = -2; dx <= 2; dx += 1) {\n    for (let dy = -2; dy <= 2; dy += 1) {\n      const x = source.pos.x + dx;\n      const y = source.pos.y + dy;\n      if (x < 1 || x > 48 || y < 1 || y > 48) continue;\n\n      const rangeToSource = Math.max(Math.abs(dx), Math.abs(dy));\n      if (rangeToSource < 1 || rangeToSource > 2) continue;\n      if (terrain.get(x, y) === TERRAIN_MASK_WALL) continue;\n      if (room.controller && room.controller.pos.getRangeTo(x, y) <= 2) continue;\n\n      positions.push([x, y]);\n    }\n  }\n\n  positions.sort((a, b) => anchor.getRangeTo(a[0], a[1]) - anchor.getRangeTo(b[0], b[1]));\n  return positions;\n}\n\nfunction containerCandidatesNearSource(room: Room, anchor: RoomPosition, source: Source): Array<[number, number]> {\n  const terrain = room.getTerrain();\n  const positions: Array<[number, number]> = [];\n\n  for (let dx = -1; dx <= 1; dx += 1) {\n    for (let dy = -1; dy <= 1; dy += 1) {\n      if (dx === 0 && dy === 0) continue;\n\n      const x = source.pos.x + dx;\n      const y = source.pos.y + dy;\n      if (x < 1 || x > 48 || y < 1 || y > 48) continue;\n      if (terrain.get(x, y) === TERRAIN_MASK_WALL) continue;\n\n      positions.push([x, y]);\n    }\n  }\n\n  positions.sort((a, b) => anchor.getRangeTo(a[0], a[1]) - anchor.getRangeTo(b[0], b[1]));\n  return positions;\n}\n\nfunction placeSourceExtensions(room: Room, anchor: RoomPosition): void {\n  const max = maxExtensions(room);\n  if (max === 0) return;\n  if (!shouldPlaceSourceExtensions(room)) return;\n\n  const perSource = Math.max(0, COLONY_SETTINGS.construction.sourceExtensionsPerSource);\n  if (perSource === 0) return;\n\n  let used = extensionBuiltAndSiteCount(room);\n  if (used >= max) return;\n\n  const sources = room.find(FIND_SOURCES);\n  for (const source of sources) {\n    if (used >= max) break;\n\n    const candidates = extensionCandidatesNearSource(room, anchor, source);\n    for (const [x, y] of candidates) {\n      if (used >= max) break;\n\n      const existing = source.pos.findInRange(FIND_MY_STRUCTURES, 2, {\n        filter: (structure: Structure) => structure.structureType === STRUCTURE_EXTENSION\n      }).length;\n      const pending = source.pos.findInRange(FIND_MY_CONSTRUCTION_SITES, 2, {\n        filter: (site: ConstructionSite) => site.structureType === STRUCTURE_EXTENSION\n      }).length;\n\n      if (existing + pending >= perSource) break;\n\n      placeIfFree(room, x, y, STRUCTURE_EXTENSION);\n      used = extensionBuiltAndSiteCount(room);\n    }\n  }\n}\n\nfunction placeRoadsFromAnchor(room: Room, anchor: RoomPosition): void {\n  const controller = room.controller;\n  if (controller) {\n    const path = anchor.findPathTo(controller.pos, { ignoreCreeps: true });\n    for (const step of path) {\n      placeIfFree(room, step.x, step.y, STRUCTURE_ROAD);\n    }\n  }\n\n  const sources = room.find(FIND_SOURCES);\n  for (const source of sources) {\n    const path = anchor.findPathTo(source.pos, { ignoreCreeps: true });\n    for (const step of path) {\n      placeIfFree(room, step.x, step.y, STRUCTURE_ROAD);\n    }\n  }\n}\n\nfunction placeSourceContainers(room: Room, anchor: RoomPosition): void {\n  const sources = room.find(FIND_SOURCES);\n  for (const source of sources) {\n    const hasContainer = source.pos.findInRange(FIND_STRUCTURES, 1, {\n      filter: (structure: Structure) => structure.structureType === STRUCTURE_CONTAINER\n    }).length;\n    const hasContainerSite = source.pos.findInRange(FIND_CONSTRUCTION_SITES, 1, {\n      filter: (site: ConstructionSite) => site.structureType === STRUCTURE_CONTAINER\n    }).length;\n\n    if (hasContainer + hasContainerSite > 0) continue;\n\n    const candidates = containerCandidatesNearSource(room, anchor, source);\n    for (const [x, y] of candidates) {\n      if (placeIfFree(room, x, y, STRUCTURE_CONTAINER)) {\n        break;\n      }\n    }\n  }\n}\n\nfunction sourceContainerDeficit(room: Room): number {\n  const sources = room.find(FIND_SOURCES);\n  let deficit = 0;\n\n  for (const source of sources) {\n    const hasContainer = source.pos.findInRange(FIND_STRUCTURES, 1, {\n      filter: (structure: Structure) => structure.structureType === STRUCTURE_CONTAINER\n    }).length;\n    const hasContainerSite = source.pos.findInRange(FIND_CONSTRUCTION_SITES, 1, {\n      filter: (site: ConstructionSite) => site.structureType === STRUCTURE_CONTAINER\n    }).length;\n    if (hasContainer + hasContainerSite === 0) {\n      deficit += 1;\n    }\n  }\n\n  return deficit;\n}\n\nfunction placeTowers(room: Room, anchor: RoomPosition): void {\n  const max = CONTROLLER_STRUCTURES[STRUCTURE_TOWER][room.controller?.level ?? 0] ?? 0;\n  if (max === 0) return;\n\n  const built = room.find(FIND_MY_STRUCTURES, {\n    filter: (structure: Structure) => structure.structureType === STRUCTURE_TOWER\n  }).length;\n  const sites = room.find(FIND_MY_CONSTRUCTION_SITES, {\n    filter: (site: ConstructionSite) => site.structureType === STRUCTURE_TOWER\n  }).length;\n\n  if (built + sites >= max) return;\n\n  placeIfFree(room, anchor.x + 3, anchor.y, STRUCTURE_TOWER);\n  placeIfFree(room, anchor.x - 3, anchor.y, STRUCTURE_TOWER);\n  placeIfFree(room, anchor.x, anchor.y + 3, STRUCTURE_TOWER);\n}\n\nfunction placeCoreLogistics(room: Room, anchor: RoomPosition): void {\n  if (structureRemainingCapacity(room, STRUCTURE_STORAGE) > 0) {\n    placeIfFree(room, anchor.x + 1, anchor.y + 1, STRUCTURE_STORAGE);\n  }\n\n  if (structureRemainingCapacity(room, STRUCTURE_TERMINAL) > 0) {\n    placeIfFree(room, anchor.x + 1, anchor.y - 1, STRUCTURE_TERMINAL);\n  }\n\n  if (structureRemainingCapacity(room, STRUCTURE_FACTORY) > 0) {\n    placeIfFree(room, anchor.x - 1, anchor.y + 1, STRUCTURE_FACTORY);\n  }\n\n  if (structureRemainingCapacity(room, STRUCTURE_LINK) > 0) {\n    placeIfFree(room, anchor.x - 1, anchor.y - 1, STRUCTURE_LINK);\n  }\n}\n\nfunction placeLabCluster(room: Room, anchor: RoomPosition): void {\n  let remaining = structureRemainingCapacity(room, STRUCTURE_LAB);\n  if (remaining <= 0) return;\n\n  const offsets: Array<[number, number]> = [\n    [4, -1],\n    [4, 0],\n    [4, 1],\n    [5, -1],\n    [5, 0],\n    [5, 1],\n    [6, -1],\n    [6, 0],\n    [6, 1],\n    [5, 2]\n  ];\n\n  for (const [dx, dy] of offsets) {\n    if (remaining <= 0) break;\n    if (placeIfFree(room, anchor.x + dx, anchor.y + dy, STRUCTURE_LAB)) {\n      remaining -= 1;\n    }\n  }\n}\n\nfunction placeSourceAndControllerLinks(room: Room, anchor: RoomPosition): void {\n  let remaining = structureRemainingCapacity(room, STRUCTURE_LINK);\n  if (remaining <= 0) return;\n\n  if (room.controller) {\n    const existingNearController = room.controller.pos.findInRange(FIND_MY_STRUCTURES, 2, {\n      filter: (structure: Structure) => structure.structureType === STRUCTURE_LINK\n    }).length;\n    const sitesNearController = room.controller.pos.findInRange(FIND_MY_CONSTRUCTION_SITES, 2, {\n      filter: (site: ConstructionSite) => site.structureType === STRUCTURE_LINK\n    }).length;\n\n    if (existingNearController + sitesNearController === 0) {\n      const path = anchor.findPathTo(room.controller.pos, { ignoreCreeps: true });\n      const finalStep = path[path.length - 1];\n      if (finalStep) {\n        if (placeIfFree(room, finalStep.x, finalStep.y, STRUCTURE_LINK)) {\n          remaining -= 1;\n        }\n      }\n    }\n  }\n\n  if (remaining <= 0) return;\n\n  const sources = room.find(FIND_SOURCES);\n  for (const source of sources) {\n    if (remaining <= 0) break;\n    const existing = source.pos.findInRange(FIND_MY_STRUCTURES, 2, {\n      filter: (structure: Structure) => structure.structureType === STRUCTURE_LINK\n    }).length;\n    const sites = source.pos.findInRange(FIND_MY_CONSTRUCTION_SITES, 2, {\n      filter: (site: ConstructionSite) => site.structureType === STRUCTURE_LINK\n    }).length;\n    if (existing + sites > 0) continue;\n\n    const path = anchor.findPathTo(source.pos, { ignoreCreeps: true });\n    const finalStep = path[path.length - 1];\n    if (!finalStep) continue;\n\n    if (placeIfFree(room, finalStep.x, finalStep.y, STRUCTURE_LINK)) {\n      remaining -= 1;\n    }\n  }\n}\n\nfunction placeMineralInfrastructure(room: Room, anchor: RoomPosition): void {\n  if (!COLONY_SETTINGS.minerals.enabled) return;\n  if ((room.controller?.level ?? 0) < COLONY_SETTINGS.minerals.minRcl) return;\n\n  const mineral = roomMineral(room);\n  if (!mineral) return;\n\n  const extractorExists = mineral.pos.lookFor(LOOK_STRUCTURES).some((structure) => structure.structureType === STRUCTURE_EXTRACTOR);\n  const extractorSiteExists = mineral.pos\n    .lookFor(LOOK_CONSTRUCTION_SITES)\n    .some((site) => site.structureType === STRUCTURE_EXTRACTOR);\n\n  if (!extractorExists && !extractorSiteExists) {\n    room.createConstructionSite(mineral.pos, STRUCTURE_EXTRACTOR);\n  }\n\n  const hasContainer = mineral.pos.findInRange(FIND_STRUCTURES, 1, {\n    filter: (structure: Structure) => structure.structureType === STRUCTURE_CONTAINER\n  }).length;\n  const hasContainerSite = mineral.pos.findInRange(FIND_CONSTRUCTION_SITES, 1, {\n    filter: (site: ConstructionSite) => site.structureType === STRUCTURE_CONTAINER\n  }).length;\n\n  if (hasContainer + hasContainerSite === 0) {\n    const path = anchor.findPathTo(mineral.pos, { ignoreCreeps: true });\n    const finalStep = path[path.length - 1];\n    if (finalStep) {\n      placeIfFree(room, finalStep.x, finalStep.y, STRUCTURE_CONTAINER);\n    }\n  }\n\n  if (Memory.strategy?.[room.name]?.capabilities.allowRoads) {\n    const path = anchor.findPathTo(mineral.pos, { ignoreCreeps: true });\n    for (const step of path) {\n      placeIfFree(room, step.x, step.y, STRUCTURE_ROAD);\n    }\n  }\n}\n\nfunction placeDefensiveRing(room: Room, anchor: RoomPosition): void {\n  for (let dx = -4; dx <= 4; dx += 1) {\n    for (let dy = -4; dy <= 4; dy += 1) {\n      const onEdge = Math.abs(dx) === 4 || Math.abs(dy) === 4;\n      if (!onEdge) continue;\n      placeIfFree(room, anchor.x + dx, anchor.y + dy, STRUCTURE_WALL);\n    }\n  }\n}\n\nexport function runConstructionManager(): void {\n  if (Game.time % COLONY_SETTINGS.construction.runInterval !== 0) return;\n\n  for (const room of getOwnedRooms()) {\n\n    const strategy = Memory.strategy?.[room.name];\n    if (!strategy) continue;\n\n    const anchor = getRoomAnchor(room);\n    if (!anchor) continue;\n\n    const maxSites = COLONY_SETTINGS.construction.maxRoomConstructionSites;\n\n    if (COLONY_SETTINGS.construction.autoPlaceSpawnInClaimedRooms) {\n      const hasSpawn = room.find(FIND_MY_SPAWNS).length > 0;\n      const hasSpawnSite = room.find(FIND_MY_CONSTRUCTION_SITES, {\n        filter: (site: ConstructionSite) => site.structureType === STRUCTURE_SPAWN\n      }).length;\n\n      if (!hasSpawn && hasSpawnSite === 0 && room.find(FIND_CONSTRUCTION_SITES).length < maxSites) {\n        placeIfFree(room, anchor.x, anchor.y, STRUCTURE_SPAWN);\n      }\n    }\n\n    // Reserve construction-site budget for one source container per source before expanding other queues.\n    const reservedContainerSlots = Math.max(0, sourceContainerDeficit(room));\n    const nonContainerSiteBudget = Math.max(0, maxSites - reservedContainerSlots);\n\n    placeSourceContainers(room, anchor);\n\n    const siteCountAfterContainers = room.find(FIND_CONSTRUCTION_SITES).length;\n    if (siteCountAfterContainers >= nonContainerSiteBudget) continue;\n    if (siteCountAfterContainers >= maxSites) continue;\n\n    placeSourceExtensions(room, anchor);\n    if (room.find(FIND_CONSTRUCTION_SITES).length >= maxSites) continue;\n    placeCoreExtensions(room, anchor);\n    if (room.find(FIND_CONSTRUCTION_SITES).length >= maxSites) continue;\n    placeCoreLogistics(room, anchor);\n    if (room.find(FIND_CONSTRUCTION_SITES).length >= maxSites) continue;\n    placeLabCluster(room, anchor);\n    if (room.find(FIND_CONSTRUCTION_SITES).length >= maxSites) continue;\n    placeSourceAndControllerLinks(room, anchor);\n    if (room.find(FIND_CONSTRUCTION_SITES).length >= maxSites) continue;\n    placeMineralInfrastructure(room, anchor);\n\n    if (strategy.capabilities.allowRoads) {\n      if (room.find(FIND_CONSTRUCTION_SITES).length >= maxSites) continue;\n      placeRoadsFromAnchor(room, anchor);\n    }\n\n    if (strategy.capabilities.allowTowers) {\n      if (room.find(FIND_CONSTRUCTION_SITES).length >= maxSites) continue;\n      placeTowers(room, anchor);\n    }\n\n    if (strategy.capabilities.allowWalls) {\n      if (room.find(FIND_CONSTRUCTION_SITES).length >= maxSites) continue;\n      placeDefensiveRing(room, anchor);\n    }\n  }\n}\n", "import { COLONY_SETTINGS } from \"../config/settings\";\n\nfunction pickPriorityHostile(tower: StructureTower): Creep | null {\n  const hostiles = tower.room.find(FIND_HOSTILE_CREEPS);\n  if (hostiles.length === 0) return null;\n\n  const healers = hostiles.filter((hostile) => hostile.getActiveBodyparts(HEAL) > 0);\n  if (healers.length > 0) {\n    return tower.pos.findClosestByRange(healers);\n  }\n\n  const ranged = hostiles.filter((hostile) => hostile.getActiveBodyparts(RANGED_ATTACK) > 0);\n  if (ranged.length > 0) {\n    return tower.pos.findClosestByRange(ranged);\n  }\n\n  const attackers = hostiles.filter((hostile) => hostile.getActiveBodyparts(ATTACK) > 0);\n  if (attackers.length > 0) {\n    return tower.pos.findClosestByRange(attackers);\n  }\n\n  const workers = hostiles.filter((hostile) => hostile.getActiveBodyparts(WORK) > 0);\n  if (workers.length > 0) {\n    return tower.pos.findClosestByRange(workers);\n  }\n\n  return tower.pos.findClosestByRange(hostiles);\n}\n\nfunction threatLevel(roomName: string): ThreatLevel {\n  const threat = Memory.threat?.[roomName];\n  if (!threat || threat.expiresAt < Game.time) return \"none\";\n  return threat.level;\n}\n\nexport function runDefenseManager(): void {\n  const towers = _.filter(\n    Object.values(Game.structures),\n    (structure): structure is StructureTower => structure.structureType === STRUCTURE_TOWER && structure.my\n  );\n\n  for (const tower of towers) {\n    const roomThreat = threatLevel(tower.room.name);\n    const inCombat = roomThreat !== \"none\";\n\n    const hostileTarget = roomThreat === \"high\" || roomThreat === \"critical\" ? pickPriorityHostile(tower) : tower.pos.findClosestByRange(FIND_HOSTILE_CREEPS);\n    if (hostileTarget) {\n      tower.attack(hostileTarget);\n      continue;\n    }\n\n    const wounded = tower.pos.findClosestByRange(FIND_MY_CREEPS, {\n      filter: (creep: Creep) => creep.hits < creep.hitsMax\n    });\n\n    if (wounded) {\n      tower.heal(wounded);\n      continue;\n    }\n\n    if (inCombat) continue;\n\n    const repairTarget = tower.pos.findClosestByRange(FIND_STRUCTURES, {\n      filter: (structure: Structure) => {\n        if (structure.structureType === STRUCTURE_WALL || structure.structureType === STRUCTURE_RAMPART) {\n          return structure.hits < COLONY_SETTINGS.defense.wallRepairCap;\n        }\n\n        return structure.hits < structure.hitsMax && structure.hits < COLONY_SETTINGS.defense.structureRepairCap;\n      }\n    });\n\n    if (repairTarget) {\n      tower.repair(repairTarget);\n    }\n  }\n}\r\n", "import { COLONY_SETTINGS } from \"../config/settings\";\nimport { getRoomAnchor } from \"../colony/layoutPlanner\";\nimport { getOwnedRooms } from \"../runtime/tickCache\";\n\nfunction myLinks(room: Room): StructureLink[] {\n  return room.find(FIND_MY_STRUCTURES, {\n    filter: (structure: Structure) => structure.structureType === STRUCTURE_LINK\n  }) as StructureLink[];\n}\n\nfunction controllerLinks(room: Room, links: StructureLink[]): StructureLink[] {\n  const controller = room.controller;\n  if (!controller) return [];\n  return links.filter((link) => link.pos.getRangeTo(controller) <= 2);\n}\n\nfunction sourceLinks(room: Room, links: StructureLink[], controller: StructureLink[]): StructureLink[] {\n  const sources = room.find(FIND_SOURCES);\n  const controllerIds = new Set(controller.map((link) => link.id));\n  return links.filter((link) => !controllerIds.has(link.id) && sources.some((source) => link.pos.getRangeTo(source) <= 2));\n}\n\nfunction coreLinks(room: Room, links: StructureLink[], controller: StructureLink[], source: StructureLink[]): StructureLink[] {\n  const excluded = new Set([...controller.map((link) => link.id), ...source.map((link) => link.id)]);\n  const roomAnchor = getRoomAnchor(room);\n\n  const remaining = links.filter((link) => !excluded.has(link.id));\n  if (!roomAnchor) return remaining;\n\n  return remaining.sort((a, b) => a.pos.getRangeTo(roomAnchor) - b.pos.getRangeTo(roomAnchor));\n}\n\nfunction canSend(link: StructureLink): boolean {\n  if (link.cooldown > 0) return false;\n  return link.store.getUsedCapacity(RESOURCE_ENERGY) >= COLONY_SETTINGS.links.senderMinEnergy;\n}\n\nfunction pickReceiver(receivers: StructureLink[], senderId?: Id<StructureLink>): StructureLink | null {\n  const viable = receivers.filter(\n    (link) =>\n      link.id !== senderId && link.store.getFreeCapacity(RESOURCE_ENERGY) >= COLONY_SETTINGS.links.receiverMinFreeCapacity\n  );\n  if (viable.length === 0) return null;\n  viable.sort(\n    (a, b) => b.store.getFreeCapacity(RESOURCE_ENERGY) - a.store.getFreeCapacity(RESOURCE_ENERGY)\n  );\n  return viable[0];\n}\n\nfunction runRoomLinks(room: Room): void {\n  const rcl = room.controller?.level ?? 0;\n  if (rcl < COLONY_SETTINGS.links.minRcl) return;\n\n  const links = myLinks(room);\n  if (links.length < 2) return;\n\n  const controller = controllerLinks(room, links);\n  const source = sourceLinks(room, links, controller);\n  const core = coreLinks(room, links, controller, source);\n\n  const controllerNeedsEnergy = controller.filter(\n    (link) => link.store.getUsedCapacity(RESOURCE_ENERGY) < COLONY_SETTINGS.links.controllerLinkTargetLevel\n  );\n\n  for (const sender of source) {\n    if (!canSend(sender)) continue;\n\n    const preferred = pickReceiver(controllerNeedsEnergy, sender.id) ?? pickReceiver(core, sender.id);\n    if (!preferred) continue;\n\n    sender.transferEnergy(preferred);\n  }\n\n  for (const sender of core) {\n    if (!canSend(sender)) continue;\n\n    const receiver = pickReceiver(controllerNeedsEnergy, sender.id);\n    if (!receiver) continue;\n\n    sender.transferEnergy(receiver);\n  }\n}\n\nexport function runLinkManager(): void {\n  if (!COLONY_SETTINGS.links.enabled) return;\n  for (const room of getOwnedRooms()) {\n    runRoomLinks(room);\n  }\n}\n", "import type { RoleName } from \"./roles\";\n\nexport interface BodyBlueprint {\n  min: BodyPartConstant[];\n  segment: BodyPartConstant[];\n  maxSegments: number;\n}\n\nexport const ROLE_BODIES: Record<RoleName, BodyBlueprint> = {\n  harvester: { min: [WORK, CARRY, MOVE], segment: [WORK, CARRY, MOVE], maxSegments: 6 },\n  hauler: { min: [CARRY, CARRY, MOVE], segment: [CARRY, CARRY, MOVE], maxSegments: 8 },\n  miner: { min: [WORK, WORK, WORK, CARRY, MOVE], segment: [WORK, MOVE], maxSegments: 6 },\n  mineralMiner: { min: [WORK, WORK, CARRY, MOVE], segment: [WORK, WORK, MOVE], maxSegments: 4 },\n  mineralHauler: { min: [CARRY, CARRY, MOVE], segment: [CARRY, CARRY, MOVE], maxSegments: 8 },\n  upgrader: { min: [WORK, CARRY, MOVE], segment: [WORK, CARRY, MOVE], maxSegments: 8 },\n  builder: { min: [WORK, CARRY, MOVE], segment: [WORK, CARRY, MOVE], maxSegments: 6 },\n  repairer: { min: [WORK, CARRY, MOVE], segment: [WORK, CARRY, MOVE], maxSegments: 5 },\n  waller: { min: [WORK, CARRY, MOVE], segment: [WORK, CARRY, MOVE], maxSegments: 7 },\n  scout: { min: [MOVE], segment: [MOVE], maxSegments: 1 },\n  reserver: { min: [CLAIM, MOVE], segment: [CLAIM, MOVE], maxSegments: 2 },\n  claimer: { min: [CLAIM, MOVE], segment: [CLAIM, MOVE], maxSegments: 1 },\n  bootstrapper: { min: [WORK, CARRY, MOVE], segment: [WORK, CARRY, MOVE], maxSegments: 6 },\n  soldier: { min: [TOUGH, MOVE, ATTACK, MOVE], segment: [TOUGH, MOVE, ATTACK, MOVE], maxSegments: 6 }\n};\n", "import type { RoleName } from \"./config/roles\";\n\nconst PART_COST: Record<BodyPartConstant, number> = {\n  move: 50,\n  work: 100,\n  carry: 50,\n  attack: 80,\n  ranged_attack: 150,\n  tough: 10,\n  heal: 250,\n  claim: 600\n};\n\nexport function bodyCost(body: BodyPartConstant[]): number {\n  return body.reduce((sum, part) => sum + PART_COST[part], 0);\n}\n\nexport function countRoleInRoom(roomName: string, role: RoleName): number {\n  let count = 0;\n  for (const creep of Object.values(Game.creeps)) {\n    if (creep.memory.homeRoom === roomName && creep.memory.role === role) {\n      count += 1;\n    }\n  }\n\n  return count;\n}\n\nexport function cleanupMemory(): void {\n  for (const name in Memory.creeps) {\n    if (!Game.creeps[name]) {\n      delete Memory.creeps[name];\n    }\n  }\n}\r\n", "import { ROLE_BODIES } from \"../config/bodyPlans\";\nimport { COLONY_SETTINGS } from \"../config/settings\";\nimport { ROLE_ORDER, type RoleName } from \"../config/roles\";\nimport { getAllCreeps, getCreepsByHomeRoom, getOwnedRooms } from \"../runtime/tickCache\";\nimport { bodyCost } from \"../utils\";\nimport { getEmergencySoldierCount } from \"./threatManager\";\n\ntype RoleCounts = Record<RoleName, number>;\n\nfunction emptyRoleCounts(): RoleCounts {\n  const counts = {} as RoleCounts;\n  for (const role of ROLE_ORDER) {\n    counts[role] = 0;\n  }\n  return counts;\n}\n\nfunction countRoles(creeps: Creep[]): RoleCounts {\n  const counts = emptyRoleCounts();\n  for (const creep of creeps) {\n    counts[creep.memory.role] += 1;\n  }\n  return counts;\n}\n\nfunction effectiveRoleCount(\n  role: RoleName,\n  current: RoleCounts,\n  planned: Partial<Record<RoleName, number>>\n): number {\n  return current[role] + (planned[role] ?? 0);\n}\n\nfunction totalEffectiveCount(current: RoleCounts, planned: Partial<Record<RoleName, number>>): number {\n  let total = 0;\n  for (const role of ROLE_ORDER) {\n    total += effectiveRoleCount(role, current, planned);\n  }\n  return total;\n}\n\nfunction buildBody(role: RoleName, energyBudget: number): BodyPartConstant[] | null {\n  const blueprint = ROLE_BODIES[role];\n  const minCost = bodyCost(blueprint.min);\n  if (energyBudget < minCost) return null;\n\n  const body: BodyPartConstant[] = [...blueprint.min];\n  const segmentCost = bodyCost(blueprint.segment);\n  let currentCost = minCost;\n  let segments = 1;\n\n  while (\n    segments < blueprint.maxSegments &&\n    body.length + blueprint.segment.length <= 50 &&\n    currentCost + segmentCost <= energyBudget\n  ) {\n    body.push(...blueprint.segment);\n    currentCost += segmentCost;\n    segments += 1;\n  }\n\n  return body;\n}\n\nfunction nextRoleToSpawn(\n  spawn: StructureSpawn,\n  currentRoleCounts: RoleCounts,\n  plannedRoleCounts: Partial<Record<RoleName, number>>\n): RoleName | null {\n  const strategy = Memory.strategy?.[spawn.room.name];\n  if (!strategy) return null;\n\n  if (totalEffectiveCount(currentRoleCounts, plannedRoleCounts) === 0) {\n    return \"harvester\";\n  }\n\n  const emergencySoldiers = getEmergencySoldierCount(spawn.room.name);\n  if (emergencySoldiers > 0) {\n    const soldierCount = effectiveRoleCount(\"soldier\", currentRoleCounts, plannedRoleCounts);\n    if (soldierCount < emergencySoldiers) {\n      return \"soldier\";\n    }\n  }\n\n  for (const role of ROLE_ORDER) {\n    const desired = strategy.desiredRoles[role] ?? 0;\n    if (desired <= 0) continue;\n\n    const currentCount = effectiveRoleCount(role, currentRoleCounts, plannedRoleCounts);\n    if (currentCount < desired) {\n      return role;\n    }\n  }\n\n  return null;\n}\n\nfunction shouldBypassEnergyGate(\n  spawn: StructureSpawn,\n  role: RoleName,\n  currentRoleCounts: RoleCounts,\n  plannedRoleCounts: Partial<Record<RoleName, number>>\n): boolean {\n  if (totalEffectiveCount(currentRoleCounts, plannedRoleCounts) === 0) return true;\n\n  if (role === \"harvester\") {\n    if (effectiveRoleCount(\"harvester\", currentRoleCounts, plannedRoleCounts) === 0) return true;\n  }\n\n  if (role === \"hauler\") {\n    if (effectiveRoleCount(\"hauler\", currentRoleCounts, plannedRoleCounts) === 0) return true;\n  }\n\n  if (role === \"soldier\" && getEmergencySoldierCount(spawn.room.name) > 0) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction minimumEnergyForRole(spawn: StructureSpawn, role: RoleName): number {\n  if (role !== \"miner\") return 0;\n  // 400 energy is required for miner baseline body with 3 WORK.\n  return Math.min(spawn.room.energyCapacityAvailable, 400);\n}\n\nfunction pickBootstrapTargetRoom(\n  targets: string[],\n  roomCreeps: Creep[],\n  plannedByTarget: Record<string, number>\n): string | undefined {\n  if (targets.length === 0) return undefined;\n\n  let bestTarget: string | undefined;\n  let bestCount = Number.MAX_SAFE_INTEGER;\n\n  for (const target of targets) {\n    const currentCount = roomCreeps.filter(\n      (creep) => creep.memory.role === \"bootstrapper\" && creep.memory.targetRoom === target\n    ).length;\n    const count = currentCount + (plannedByTarget[target] ?? 0);\n\n    if (count < bestCount) {\n      bestCount = count;\n      bestTarget = target;\n    }\n  }\n\n  return bestTarget;\n}\n\nfunction reinforcementNeedForRoom(roomName: string): number {\n  const threat = Memory.threat?.[roomName];\n  if (!threat || threat.expiresAt < Game.time) return 0;\n  return getEmergencySoldierCount(roomName);\n}\n\nfunction currentDefendersAssigned(\n  roomName: string,\n  allCreeps: Creep[],\n  plannedByTargetRoom: Record<string, number>\n): number {\n  const assigned = allCreeps.filter((creep) => {\n    if (creep.memory.role !== \"soldier\") return false;\n    if (creep.memory.homeRoom === roomName) return true;\n    return creep.memory.targetRoom === roomName;\n  }).length;\n\n  return assigned + (plannedByTargetRoom[roomName] ?? 0);\n}\n\nfunction pickReinforcementTarget(\n  homeRoom: string,\n  allCreeps: Creep[],\n  plannedByTargetRoom: Record<string, number>\n): string | undefined {\n  const candidateRooms = getOwnedRooms().filter((room) => room.name !== homeRoom);\n  let bestTarget: string | undefined;\n  let bestScore = Number.NEGATIVE_INFINITY;\n\n  for (const room of candidateRooms) {\n    const need = reinforcementNeedForRoom(room.name);\n    if (need <= 0) continue;\n\n    const assigned = currentDefendersAssigned(room.name, allCreeps, plannedByTargetRoom);\n    const deficit = need - assigned;\n    if (deficit <= 0) continue;\n\n    const distance = Game.map.getRoomLinearDistance(homeRoom, room.name);\n    const score = deficit * 100 - distance * 10;\n    if (score > bestScore) {\n      bestScore = score;\n      bestTarget = room.name;\n    }\n  }\n\n  return bestTarget;\n}\n\nfunction sourceIdsInHomeRoom(homeRoom: string): Id<Source>[] {\n  const room = Game.rooms[homeRoom];\n  if (!room) return [];\n  return room.find(FIND_SOURCES).map((source) => source.id);\n}\n\nfunction assignedSourceWorkerCount(\n  roomCreeps: Creep[],\n  role: \"miner\" | \"hauler\",\n  sourceId: Id<Source>,\n  onlyLocked: boolean\n): number {\n  return roomCreeps.filter((creep) => {\n    if (creep.memory.role !== role) return false;\n    if (creep.memory.sourceId !== sourceId) return false;\n    if (onlyLocked && !creep.memory.lockSource) return false;\n    return true;\n  }).length;\n}\n\nfunction pickDedicatedSource(\n  homeRoom: string,\n  role: \"miner\" | \"hauler\",\n  desiredPerSource: number,\n  onlyLocked: boolean,\n  roomCreeps: Creep[]\n): Id<Source> | undefined {\n  const sourceIds = sourceIdsInHomeRoom(homeRoom);\n  if (sourceIds.length === 0 || desiredPerSource <= 0) return undefined;\n\n  let bestSourceId: Id<Source> | undefined;\n  let bestCount = Number.MAX_SAFE_INTEGER;\n  for (const sourceId of sourceIds) {\n    const count = assignedSourceWorkerCount(roomCreeps, role, sourceId, onlyLocked);\n    if (count < bestCount) {\n      bestCount = count;\n      bestSourceId = sourceId;\n    }\n  }\n\n  if (bestCount >= desiredPerSource) return undefined;\n  return bestSourceId;\n}\n\nfunction uniqueSpawnName(spawn: StructureSpawn, role: RoleName): string {\n  const base = `${role}-${spawn.name}-${Game.time}`;\n  if (!Game.creeps[base]) return base;\n\n  for (let attempt = 1; attempt <= 20; attempt += 1) {\n    const candidate = `${base}-${attempt}`;\n    if (!Game.creeps[candidate]) return candidate;\n  }\n\n  return `${base}-${Math.random().toString(36).slice(2, 6)}`;\n}\n\nexport function runSpawnManager(): void {\n  const spawns = Object.values(Game.spawns);\n  const allCreeps = getAllCreeps();\n  const roomRoleCounts: Record<string, RoleCounts> = {};\n  const plannedRoleCountsByRoom: Record<string, Partial<Record<RoleName, number>>> = {};\n  const plannedBootstrappersByRoomTarget: Record<string, Record<string, number>> = {};\n  const plannedDefendersByTargetRoom: Record<string, number> = {};\n\n  for (const spawn of spawns) {\n    if (spawn.spawning) continue;\n    const strategy = Memory.strategy?.[spawn.room.name];\n    if (!strategy) continue;\n\n    const roomName = spawn.room.name;\n    if (!roomRoleCounts[roomName]) {\n      roomRoleCounts[roomName] = countRoles(getCreepsByHomeRoom(roomName));\n    }\n    if (!plannedRoleCountsByRoom[roomName]) {\n      plannedRoleCountsByRoom[roomName] = {};\n    }\n    if (!plannedBootstrappersByRoomTarget[roomName]) {\n      plannedBootstrappersByRoomTarget[roomName] = {};\n    }\n\n    const roomCreeps = getCreepsByHomeRoom(roomName);\n    const role = nextRoleToSpawn(spawn, roomRoleCounts[roomName], plannedRoleCountsByRoom[roomName]);\n    if (!role) continue;\n\n    const bootstrapTargetRoom =\n      role === \"bootstrapper\"\n        ? pickBootstrapTargetRoom(\n            strategy.bootstrapTargetRooms,\n            roomCreeps,\n            plannedBootstrappersByRoomTarget[roomName]\n          )\n        : undefined;\n    if (role === \"bootstrapper\" && !bootstrapTargetRoom) continue;\n\n    const localEmergency = getEmergencySoldierCount(roomName);\n    const reinforcementTargetRoom =\n      role === \"soldier\" && localEmergency === 0\n        ? pickReinforcementTarget(roomName, allCreeps, plannedDefendersByTargetRoom)\n        : undefined;\n\n    const targetRoom = bootstrapTargetRoom ?? reinforcementTargetRoom;\n\n    const reserveRatio = Math.max(0, Math.min(0.95, COLONY_SETTINGS.spawn.reserveEnergyRatio));\n    const minFillRatio = 1 - reserveRatio;\n    const requiredEnergy = Math.ceil(spawn.room.energyCapacityAvailable * minFillRatio);\n    const roleMinEnergy = minimumEnergyForRole(spawn, role);\n    const bypassEnergyGate = shouldBypassEnergyGate(\n      spawn,\n      role,\n      roomRoleCounts[roomName],\n      plannedRoleCountsByRoom[roomName]\n    );\n    if (!bypassEnergyGate && spawn.room.energyAvailable < Math.max(requiredEnergy, roleMinEnergy)) continue;\n\n    const body = buildBody(role, spawn.room.energyAvailable);\n    if (!body) continue;\n\n    const sourceId =\n      role === \"miner\"\n        ? pickDedicatedSource(\n            roomName,\n            \"miner\",\n            Math.max(1, COLONY_SETTINGS.planner.minersPerSource),\n            false,\n            roomCreeps\n          )\n        : role === \"hauler\"\n          ? pickDedicatedSource(\n              roomName,\n              \"hauler\",\n              Math.max(0, COLONY_SETTINGS.planner.dedicatedHaulersPerSource),\n              true,\n              roomCreeps\n            )\n          : undefined;\n    const lockSource = sourceId !== undefined;\n\n    const name = uniqueSpawnName(spawn, role);\n    const result = spawn.spawnCreep(body, name, {\n      memory: {\n        role,\n        homeRoom: roomName,\n        working: false,\n        targetRoom,\n        sourceId,\n        lockSource\n      }\n    });\n\n    if (result === OK) {\n      plannedRoleCountsByRoom[roomName][role] = (plannedRoleCountsByRoom[roomName][role] ?? 0) + 1;\n      if (role === \"bootstrapper\" && targetRoom) {\n        plannedBootstrappersByRoomTarget[roomName][targetRoom] =\n          (plannedBootstrappersByRoomTarget[roomName][targetRoom] ?? 0) + 1;\n      }\n      if (role === \"soldier\" && targetRoom) {\n        plannedDefendersByTargetRoom[targetRoom] = (plannedDefendersByTargetRoom[targetRoom] ?? 0) + 1;\n      }\n      continue;\n    }\n\n    if (result !== ERR_BUSY && result !== ERR_NOT_ENOUGH_ENERGY && result !== ERR_NAME_EXISTS) {\n      console.log(`[spawn][${spawn.name}] failed role=${role} code=${result}`);\n    }\n  }\n}\n", "import { COLONY_SETTINGS } from \"../config/settings\";\nimport { countCreepsByHomeRoomAndRole, getOwnedRooms } from \"../runtime/tickCache\";\n\nfunction summarizeThreat(roomName: string): string {\n  const threat = Memory.threat?.[roomName];\n  if (!threat || threat.expiresAt < Game.time) return \"none\";\n  return `${threat.level}:${threat.score}`;\n}\n\nexport function runTelemetryManager(): void {\n  if (!COLONY_SETTINGS.telemetry.enabled) return;\n  if (Game.time % COLONY_SETTINGS.telemetry.interval !== 0) return;\n\n  for (const room of getOwnedRooms()) {\n    const state = Memory.roomState?.[room.name] ?? \"unknown\";\n    const threat = summarizeThreat(room.name);\n    const strategy = Memory.strategy?.[room.name];\n    const claim = strategy?.claimTargetRooms[0] ?? \"-\";\n    const bootstrap = strategy?.bootstrapTargetRooms.join(\",\") ?? \"-\";\n    const soldiers = countCreepsByHomeRoomAndRole(room.name, \"soldier\");\n\n    console.log(\n      `[telemetry][${room.name}] state=${state} threat=${threat} soldiers=${soldiers} claim=${claim} bootstrap=${bootstrap}`\n    );\n  }\n}\n", "import { isUpgradingPaused } from \"../config/settings\";\nimport { moveToTarget } from \"./movement\";\n\nexport function upgradeController(creep: Creep): boolean {\n  const controller = creep.room.controller;\n  if (!controller) return false;\n  if (isUpgradingPaused(creep.room)) return false;\n\n  const result = creep.upgradeController(controller);\n  if (result === ERR_NOT_IN_RANGE) {\n    moveToTarget(creep, controller);\n    return true;\n  }\n\n  return result === OK;\n}\n\nexport function buildNearestSite(creep: Creep): boolean {\n  const site = creep.pos.findClosestByPath(FIND_CONSTRUCTION_SITES);\n  if (!site) return false;\n\n  const result = creep.build(site);\n  if (result === ERR_NOT_IN_RANGE) {\n    moveToTarget(creep, site);\n    return true;\n  }\n\n  return result === OK;\n}\n\nexport function repairInfrastructure(creep: Creep): boolean {\n  const target = creep.pos.findClosestByPath(FIND_STRUCTURES, {\n    filter: (structure: Structure) => {\n      if (structure.hits >= structure.hitsMax) return false;\n      return structure.structureType === STRUCTURE_ROAD || structure.structureType === STRUCTURE_CONTAINER;\n    }\n  });\n\n  if (!target) return false;\n\n  const result = creep.repair(target);\n  if (result === ERR_NOT_IN_RANGE) {\n    moveToTarget(creep, target);\n    return true;\n  }\n\n  return result === OK;\n}\n\nexport function fortifyDefenses(creep: Creep, minWallHits: number): boolean {\n  const target = creep.pos.findClosestByPath(FIND_STRUCTURES, {\n    filter: (structure: Structure) => {\n      if (structure.structureType !== STRUCTURE_WALL && structure.structureType !== STRUCTURE_RAMPART) return false;\n      return structure.hits < minWallHits;\n    }\n  });\n\n  if (!target) return false;\n\n  const result = creep.repair(target);\n  if (result === ERR_NOT_IN_RANGE) {\n    moveToTarget(creep, target);\n    return true;\n  }\n\n  return result === OK;\n}\r\n", "import { COLONY_SETTINGS } from \"../config/settings\";\nimport { getCreepsByHomeRoom } from \"../runtime/tickCache\";\nimport { moveToTarget } from \"./movement\";\n\nfunction isSourceWorker(creep: Creep): boolean {\n  return creep.memory.role === \"harvester\" || creep.memory.role === \"miner\";\n}\n\nfunction sourceLoad(roomName: string, sourceId: Id<Source>, excludeCreepName: string): number {\n  let load = 0;\n\n  for (const other of getCreepsByHomeRoom(roomName)) {\n    if (other.name === excludeCreepName) continue;\n    if (!isSourceWorker(other)) continue;\n    if (other.memory.sourceId === sourceId) {\n      load += 1;\n    }\n  }\n\n  return load;\n}\n\nfunction assignSource(creep: Creep): Source | null {\n  const sources = creep.room.find(FIND_SOURCES_ACTIVE);\n  if (sources.length === 0) return null;\n\n  if (!isSourceWorker(creep)) {\n    if (creep.memory.sourceId) {\n      const existing = Game.getObjectById(creep.memory.sourceId as Id<Source>);\n      if (existing) return existing;\n    }\n\n    const nearest = creep.pos.findClosestByPath(sources) ?? sources[0];\n    creep.memory.sourceId = nearest.id;\n    return nearest;\n  }\n\n  const existing =\n    creep.memory.sourceId !== undefined ? Game.getObjectById(creep.memory.sourceId as Id<Source>) : null;\n  if (existing && creep.memory.lockSource) {\n    return existing;\n  }\n\n  const shouldRebalance = Game.time % 25 === 0;\n  if (existing && !shouldRebalance) {\n    return existing;\n  }\n\n  let best: Source | null = null;\n  let bestLoad = Number.MAX_SAFE_INTEGER;\n  let bestRange = Number.MAX_SAFE_INTEGER;\n\n  for (const source of sources) {\n    const load = sourceLoad(creep.memory.homeRoom, source.id, creep.name);\n    const range = creep.pos.getRangeTo(source);\n\n    if (load < bestLoad || (load === bestLoad && range < bestRange)) {\n      best = source;\n      bestLoad = load;\n      bestRange = range;\n    }\n  }\n\n  const selected = best ?? sources[0];\n  creep.memory.sourceId = selected.id;\n  return selected;\n}\n\nexport function harvestEnergy(creep: Creep): boolean {\n  const source = assignSource(creep);\n  if (!source) return false;\n\n  const result = creep.harvest(source);\n  if (result === ERR_NOT_IN_RANGE) {\n    moveToTarget(creep, source);\n    return true;\n  }\n\n  return result === OK;\n}\n\nexport function withdrawStoredEnergy(creep: Creep): boolean {\n  const target = creep.pos.findClosestByPath(FIND_STRUCTURES, {\n    filter: (structure: Structure) => {\n      if (\n        structure.structureType === STRUCTURE_STORAGE ||\n        structure.structureType === STRUCTURE_CONTAINER ||\n        structure.structureType === STRUCTURE_EXTENSION\n      ) {\n        return (structure as StructureStorage | StructureContainer | StructureExtension).store.getUsedCapacity(RESOURCE_ENERGY) > 0;\n      }\n      return false;\n    }\n  }) as StructureStorage | StructureContainer | StructureExtension | null;\n\n  if (!target) return false;\n\n  const result = creep.withdraw(target, RESOURCE_ENERGY);\n  if (result === ERR_NOT_IN_RANGE) {\n    moveToTarget(creep, target);\n    return true;\n  }\n\n  return result === OK;\n}\n\nexport function pickupDroppedEnergy(creep: Creep): boolean {\n  const resource = creep.pos.findClosestByPath(FIND_DROPPED_RESOURCES, {\n    filter: (dropped: Resource) =>\n      dropped.resourceType === RESOURCE_ENERGY && dropped.amount > COLONY_SETTINGS.energy.pickupDroppedEnergyMinAmount\n  });\n\n  if (!resource) return false;\n\n  const result = creep.pickup(resource);\n  if (result === ERR_NOT_IN_RANGE) {\n    moveToTarget(creep, resource);\n    return true;\n  }\n\n  return result === OK;\n}\n\nexport function fillPriorityEnergyTargets(creep: Creep): boolean {\n  const target = creep.pos.findClosestByPath(FIND_STRUCTURES, {\n    filter: (structure: Structure) => {\n      if (\n        structure.structureType === STRUCTURE_SPAWN ||\n        structure.structureType === STRUCTURE_EXTENSION ||\n        structure.structureType === STRUCTURE_TOWER\n      ) {\n        return (structure as StructureSpawn | StructureExtension | StructureTower).store.getFreeCapacity(RESOURCE_ENERGY) > 0;\n      }\n      return false;\n    }\n  }) as StructureSpawn | StructureExtension | StructureTower | null;\n\n  if (!target) return false;\n\n  const result = creep.transfer(target, RESOURCE_ENERGY);\n  if (result === ERR_NOT_IN_RANGE) {\n    moveToTarget(creep, target);\n    return true;\n  }\n\n  return result === OK;\n}\r\n", "import { harvestEnergy, pickupDroppedEnergy, withdrawStoredEnergy } from \"../tasks/energy\";\n\ntype WorkingResourceMode = ResourceConstant | \"any\";\n\nexport function updateWorkingState(creep: Creep, mode: WorkingResourceMode = RESOURCE_ENERGY): void {\n  const usedCapacity = mode === \"any\" ? creep.store.getUsedCapacity() : creep.store.getUsedCapacity(mode);\n  if (creep.memory.working && usedCapacity === 0) {\n    creep.memory.working = false;\n  }\n\n  if (!creep.memory.working && creep.store.getFreeCapacity() === 0) {\n    creep.memory.working = true;\n  }\n}\n\nexport function acquireEnergy(creep: Creep): boolean {\n  return withdrawStoredEnergy(creep) || pickupDroppedEnergy(creep) || harvestEnergy(creep);\n}\r\n", "import { buildNearestSite, upgradeController } from \"../tasks/work\";\nimport { updateWorkingState, acquireEnergy } from \"./common\";\n\nexport function runBuilder(creep: Creep): void {\n  updateWorkingState(creep);\n\n  if (!creep.memory.working) {\n    acquireEnergy(creep);\n    return;\n  }\n\n  if (buildNearestSite(creep)) return;\n  upgradeController(creep);\n}\r\n", "import { moveToRoomCenter, moveToTarget } from \"../tasks/movement\";\nimport { fillPriorityEnergyTargets } from \"../tasks/energy\";\nimport { buildNearestSite, upgradeController } from \"../tasks/work\";\nimport { acquireEnergy, updateWorkingState } from \"./common\";\n\nfunction buildSpawnFirst(creep: Creep): boolean {\n  const spawnSite = creep.pos.findClosestByPath(FIND_MY_CONSTRUCTION_SITES, {\n    filter: (site: ConstructionSite) => site.structureType === STRUCTURE_SPAWN\n  });\n\n  if (!spawnSite) return false;\n\n  const result = creep.build(spawnSite);\n  if (result === ERR_NOT_IN_RANGE) {\n    moveToTarget(creep, spawnSite);\n    return true;\n  }\n\n  return result === OK;\n}\n\nexport function runBootstrapper(creep: Creep): void {\n  const targetRoom = creep.memory.targetRoom;\n  if (!targetRoom) return;\n\n  if (creep.room.name !== targetRoom) {\n    moveToRoomCenter(creep, targetRoom);\n    return;\n  }\n\n  updateWorkingState(creep);\n\n  if (!creep.memory.working) {\n    acquireEnergy(creep);\n    return;\n  }\n\n  if (buildSpawnFirst(creep)) return;\n  if (buildNearestSite(creep)) return;\n  if (fillPriorityEnergyTargets(creep)) return;\n  upgradeController(creep);\n}\n", "import { moveToRoomCenter, moveToTarget } from \"./movement\";\nimport { COLONY_SETTINGS, isAttackAllowed } from \"../config/settings\";\n\nexport function reserveRoomController(creep: Creep, roomName: string): boolean {\n  if (creep.room.name !== roomName) {\n    moveToRoomCenter(creep, roomName);\n    return true;\n  }\n\n  const controller = creep.room.controller;\n  if (!controller) return false;\n\n  const result = creep.reserveController(controller);\n  if (result === ERR_NOT_IN_RANGE) {\n    moveToTarget(creep, controller);\n    return true;\n  }\n\n  return result === OK;\n}\n\nexport function claimRoomController(creep: Creep, roomName: string): boolean {\n  if (creep.room.name !== roomName) {\n    moveToRoomCenter(creep, roomName);\n    return true;\n  }\n\n  const controller = creep.room.controller;\n  if (!controller) return false;\n\n  const result = creep.claimController(controller);\n  if (result === ERR_NOT_IN_RANGE) {\n    moveToTarget(creep, controller);\n    return true;\n  }\n\n  return result === OK;\n}\n\nexport function attackInRoom(creep: Creep, roomName: string): boolean {\n  const targetRoom = Game.rooms[roomName];\n  const defendingOwnedRoom = Boolean(targetRoom?.controller?.my);\n\n  if (defendingOwnedRoom) {\n    if (!COLONY_SETTINGS.combat.defenseEnabled) return false;\n    if (!COLONY_SETTINGS.combat.defendEvenIfOffenseDisabled && !isAttackAllowed(creep.memory.homeRoom, roomName)) {\n      return false;\n    }\n  } else if (!isAttackAllowed(creep.memory.homeRoom, roomName)) {\n    return false;\n  }\n\n  if (creep.room.name !== roomName) {\n    moveToRoomCenter(creep, roomName);\n    return true;\n  }\n\n  const hostile = creep.pos.findClosestByPath(FIND_HOSTILE_CREEPS);\n  if (hostile) {\n    const result = creep.attack(hostile);\n    if (result === ERR_NOT_IN_RANGE) {\n      moveToTarget(creep, hostile);\n      return true;\n    }\n\n    return result === OK;\n  }\n\n  const hostileStructure = creep.pos.findClosestByPath(FIND_HOSTILE_STRUCTURES, {\n    filter: (structure: Structure) => structure.structureType !== STRUCTURE_CONTROLLER\n  });\n\n  if (!hostileStructure) return false;\n\n  const result = creep.attack(hostileStructure);\n  if (result === ERR_NOT_IN_RANGE) {\n    moveToTarget(creep, hostileStructure);\n    return true;\n  }\n\n  return result === OK;\n}\r\n", "import { claimRoomController } from \"../tasks/combat\";\nimport { markManualTargetClaimed } from \"../config/settings\";\n\nexport function runClaimer(creep: Creep): void {\n  const targets = Memory.strategy?.[creep.memory.homeRoom]?.claimTargetRooms ?? [];\n  if (targets.length === 0) return;\n\n  const targetRoom = targets[0];\n  if (claimRoomController(creep, targetRoom)) {\n    if (creep.room.name === targetRoom && creep.room.controller?.my) {\n      markManualTargetClaimed(creep.memory.homeRoom, targetRoom);\n    }\n  }\n}\n", "import { fillPriorityEnergyTargets } from \"../tasks/energy\";\nimport { upgradeController } from \"../tasks/work\";\nimport { updateWorkingState, acquireEnergy } from \"./common\";\n\nexport function runHarvester(creep: Creep): void {\n  updateWorkingState(creep);\n\n  if (!creep.memory.working) {\n    acquireEnergy(creep);\n    return;\n  }\n\n  if (fillPriorityEnergyTargets(creep)) return;\n  upgradeController(creep);\n}\r\n", "import { fillPriorityEnergyTargets, pickupDroppedEnergy, withdrawStoredEnergy } from \"../tasks/energy\";\nimport { COLONY_SETTINGS } from \"../config/settings\";\nimport { moveToTarget } from \"../tasks/movement\";\nimport { updateWorkingState } from \"./common\";\n\nfunction isNearSourcePosition(pos: RoomPosition, source: Source | null, range: number): boolean {\n  if (!source) return false;\n  return pos.getRangeTo(source) <= range;\n}\n\nfunction isNearAnySource(room: Room, pos: RoomPosition, range = 2): boolean {\n  const sources = room.find(FIND_SOURCES);\n  return sources.some((source) => pos.getRangeTo(source) <= range);\n}\n\nfunction withdrawFromSourceExtensions(creep: Creep, assignedSource: Source | null): boolean {\n  const target = creep.pos.findClosestByPath(FIND_MY_STRUCTURES, {\n    filter: (structure: Structure) => {\n      if (structure.structureType !== STRUCTURE_EXTENSION) return false;\n      const isValidSourceExtension = assignedSource\n        ? isNearSourcePosition(structure.pos, assignedSource, 2)\n        : isNearAnySource(creep.room, structure.pos, 2);\n      if (!isValidSourceExtension) return false;\n      const extension = structure as StructureExtension;\n      return extension.store.getUsedCapacity(RESOURCE_ENERGY) > 0;\n    }\n  }) as StructureExtension | null;\n\n  if (!target) return false;\n\n  const result = creep.withdraw(target, RESOURCE_ENERGY);\n  if (result === ERR_NOT_IN_RANGE) {\n    moveToTarget(creep, target);\n    return true;\n  }\n\n  return result === OK;\n}\n\nfunction withdrawFromSourceContainers(creep: Creep, assignedSource: Source | null): boolean {\n  const target = creep.pos.findClosestByPath(FIND_STRUCTURES, {\n    filter: (structure: Structure) => {\n      if (structure.structureType !== STRUCTURE_CONTAINER) return false;\n      const isValidSourceContainer = assignedSource\n        ? isNearSourcePosition(structure.pos, assignedSource, 1)\n        : isNearAnySource(creep.room, structure.pos, 1);\n      if (!isValidSourceContainer) return false;\n      const container = structure as StructureContainer;\n      return container.store.getUsedCapacity(RESOURCE_ENERGY) >= COLONY_SETTINGS.energy.haulerContainerWithdrawMinEnergy;\n    }\n  }) as StructureContainer | null;\n\n  if (!target) return false;\n\n  const result = creep.withdraw(target, RESOURCE_ENERGY);\n  if (result === ERR_NOT_IN_RANGE) {\n    moveToTarget(creep, target);\n    return true;\n  }\n\n  return result === OK;\n}\n\nfunction fillCoreEnergyTargets(creep: Creep): boolean {\n  const homeRoom = Game.rooms[creep.memory.homeRoom];\n  const anchor = homeRoom?.find(FIND_MY_SPAWNS)[0]?.pos;\n\n  const target = creep.pos.findClosestByPath(FIND_STRUCTURES, {\n    filter: (structure: Structure) => {\n      if (structure.structureType === STRUCTURE_SPAWN || structure.structureType === STRUCTURE_TOWER) {\n        return (structure as StructureSpawn | StructureTower).store.getFreeCapacity(RESOURCE_ENERGY) > 0;\n      }\n\n      if (structure.structureType !== STRUCTURE_EXTENSION) return false;\n      if (anchor && structure.pos.getRangeTo(anchor) > COLONY_SETTINGS.logistics.coreDeliveryRangeFromSpawn) return false;\n      return (structure as StructureExtension).store.getFreeCapacity(RESOURCE_ENERGY) > 0;\n    }\n  }) as StructureSpawn | StructureExtension | StructureTower | null;\n\n  if (!target) return false;\n\n  const result = creep.transfer(target, RESOURCE_ENERGY);\n  if (result === ERR_NOT_IN_RANGE) {\n    moveToTarget(creep, target);\n    return true;\n  }\n\n  return result === OK;\n}\n\nexport function runHauler(creep: Creep): void {\n  updateWorkingState(creep);\n  const assignedSource =\n    creep.memory.lockSource && creep.memory.sourceId\n      ? Game.getObjectById(creep.memory.sourceId as Id<Source>)\n      : null;\n  const isDedicated = Boolean(assignedSource);\n\n  if (!creep.memory.working) {\n    if (withdrawFromSourceExtensions(creep, assignedSource)) return;\n    if (withdrawFromSourceContainers(creep, assignedSource)) return;\n\n    if (!isDedicated) {\n      if (withdrawStoredEnergy(creep)) return;\n      pickupDroppedEnergy(creep);\n    }\n\n    return;\n  }\n\n  if (fillCoreEnergyTargets(creep)) return;\n  fillPriorityEnergyTargets(creep);\n}\n", "import { harvestEnergy } from \"../tasks/energy\";\nimport { moveToTarget } from \"../tasks/movement\";\n\nfunction sourceExtensions(creep: Creep): StructureExtension[] {\n  const source = creep.memory.sourceId ? Game.getObjectById(creep.memory.sourceId) : null;\n  if (!source) return [];\n\n  return source.pos.findInRange(FIND_MY_STRUCTURES, 2, {\n    filter: (structure: Structure) =>\n      structure.structureType === STRUCTURE_EXTENSION &&\n      (structure as StructureExtension).store.getFreeCapacity(RESOURCE_ENERGY) > 0\n  }) as StructureExtension[];\n}\n\nfunction sourceContainer(creep: Creep): StructureContainer | null {\n  const source = creep.memory.sourceId ? Game.getObjectById(creep.memory.sourceId) : null;\n  if (!source) return null;\n\n  const containers = source.pos.findInRange(FIND_STRUCTURES, 1, {\n    filter: (structure: Structure) => structure.structureType === STRUCTURE_CONTAINER\n  }) as StructureContainer[];\n\n  return containers[0] ?? null;\n}\n\nexport function runMiner(creep: Creep): void {\n  if (creep.store.getUsedCapacity(RESOURCE_ENERGY) > 0) {\n    const extension = creep.pos.findClosestByRange(sourceExtensions(creep));\n    if (extension) {\n      const result = creep.transfer(extension, RESOURCE_ENERGY);\n      if (result === ERR_NOT_IN_RANGE) {\n        moveToTarget(creep, extension);\n      }\n      return;\n    }\n  }\n\n  const container = sourceContainer(creep);\n  if (container && creep.store.getUsedCapacity(RESOURCE_ENERGY) > 0) {\n    const transfer = creep.transfer(container, RESOURCE_ENERGY);\n    if (transfer === ERR_NOT_IN_RANGE) {\n      moveToTarget(creep, container);\n    }\n    return;\n  }\n\n  if (container && creep.pos.getRangeTo(container) > 0) {\n    moveToTarget(creep, container, 0);\n    return;\n  }\n\n  harvestEnergy(creep);\n}\n", "import { pickupDroppedMinerals, transferCarriedMinerals, withdrawMineralsFromContainer } from \"../tasks/minerals\";\nimport { updateWorkingState } from \"./common\";\n\nexport function runMineralHauler(creep: Creep): void {\n  updateWorkingState(creep, \"any\");\n\n  if (!creep.memory.working) {\n    if (withdrawMineralsFromContainer(creep)) return;\n    pickupDroppedMinerals(creep);\n    return;\n  }\n\n  transferCarriedMinerals(creep);\n}\n", "import { harvestMineral, roomMineral, roomMineralContainer, transferCarriedMinerals } from \"../tasks/minerals\";\nimport { moveToTarget } from \"../tasks/movement\";\n\nexport function runMineralMiner(creep: Creep): void {\n  const mineral = roomMineral(creep.room);\n  if (!mineral || mineral.mineralAmount <= 0) return;\n\n  const container = roomMineralContainer(creep.room);\n  if (container && creep.pos.getRangeTo(container) > 0) {\n    moveToTarget(creep, container, 0);\n    return;\n  }\n\n  if (creep.store.getFreeCapacity() === 0) {\n    if (container) {\n      const resource = (Object.keys(creep.store) as ResourceConstant[]).find(\n        (entry) => entry !== RESOURCE_ENERGY && creep.store.getUsedCapacity(entry) > 0\n      );\n      if (!resource) return;\n\n      const result = creep.transfer(container, resource);\n      if (result === ERR_NOT_IN_RANGE) {\n        moveToTarget(creep, container);\n      }\n      return;\n    }\n\n    transferCarriedMinerals(creep);\n    return;\n  }\n\n  harvestMineral(creep);\n}\n", "import { repairInfrastructure, upgradeController } from \"../tasks/work\";\nimport { updateWorkingState, acquireEnergy } from \"./common\";\n\nexport function runRepairer(creep: Creep): void {\n  updateWorkingState(creep);\n\n  if (!creep.memory.working) {\n    acquireEnergy(creep);\n    return;\n  }\n\n  if (repairInfrastructure(creep)) return;\n  upgradeController(creep);\n}\r\n", "import { reserveRoomController } from \"../tasks/combat\";\n\nfunction stableTargetRoom(creep: Creep, targets: string[]): string {\n  const saved = creep.memory.targetRoom;\n  if (saved && targets.includes(saved)) {\n    return saved;\n  }\n\n  const hash = creep.name.split(\"\").reduce((sum, ch) => sum + ch.charCodeAt(0), 0);\n  const target = targets[hash % targets.length];\n  creep.memory.targetRoom = target;\n  return target;\n}\n\nexport function runReserver(creep: Creep): void {\n  const targets = Memory.strategy?.[creep.memory.homeRoom]?.reserveTargetRooms ?? [];\n  if (targets.length === 0) return;\n\n  const targetRoom = stableTargetRoom(creep, targets);\n  reserveRoomController(creep, targetRoom);\n}\n", "import { moveToRoomCenter } from \"../tasks/movement\";\n\nfunction stableTargetRoom(creep: Creep, targets: string[]): string {\n  const saved = creep.memory.targetRoom;\n  if (saved && targets.includes(saved)) {\n    return saved;\n  }\n\n  const hash = creep.name.split(\"\").reduce((sum, ch) => sum + ch.charCodeAt(0), 0);\n  const target = targets[hash % targets.length];\n  creep.memory.targetRoom = target;\n  return target;\n}\n\nexport function runScout(creep: Creep): void {\n  const targets = Memory.strategy?.[creep.memory.homeRoom]?.scoutTargetRooms ?? [];\n  if (targets.length === 0) return;\n\n  const targetRoom = stableTargetRoom(creep, targets);\n  if (creep.room.name !== targetRoom) {\n    moveToRoomCenter(creep, targetRoom);\n    return;\n  }\n\n  creep.moveTo(25, 25, { reusePath: 5 });\n}\r\n", "import { attackInRoom } from \"../tasks/combat\";\n\nfunction hasActiveThreat(roomName: string): boolean {\n  const threat = Memory.threat?.[roomName];\n  return Boolean(threat && threat.expiresAt >= Game.time && threat.level !== \"none\");\n}\n\nfunction roomStillNeedsCombat(roomName: string): boolean {\n  const room = Game.rooms[roomName];\n  if (!room) return true;\n  if (room.find(FIND_HOSTILE_CREEPS).length > 0) return true;\n\n  if (room.controller?.my && hasActiveThreat(roomName)) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction stableTargetRoom(creep: Creep, targets: string[]): string {\n  const saved = creep.memory.targetRoom;\n  if (saved && targets.includes(saved)) {\n    return saved;\n  }\n\n  const hash = creep.name.split(\"\").reduce((sum, ch) => sum + ch.charCodeAt(0), 0);\n  const target = targets[hash % targets.length];\n  creep.memory.targetRoom = target;\n  return target;\n}\n\nexport function runSoldier(creep: Creep): void {\n  if (creep.memory.targetRoom) {\n    const pinned = creep.memory.targetRoom;\n    const stillRelevant = roomStillNeedsCombat(pinned);\n    if (stillRelevant) {\n      if (attackInRoom(creep, pinned)) return;\n    } else {\n      delete creep.memory.targetRoom;\n    }\n  }\n\n  const targets = Memory.strategy?.[creep.memory.homeRoom]?.attackTargetRooms ?? [];\n  if (targets.length === 0) return;\n\n  const targetRoom = stableTargetRoom(creep, targets);\n  attackInRoom(creep, targetRoom);\n}\n", "import { upgradeController } from \"../tasks/work\";\nimport { updateWorkingState, acquireEnergy } from \"./common\";\n\nexport function runUpgrader(creep: Creep): void {\n  updateWorkingState(creep);\n\n  if (!creep.memory.working) {\n    acquireEnergy(creep);\n    return;\n  }\n\n  upgradeController(creep);\n}\r\n", "import { getWallTargetHits } from \"../config/settings\";\nimport { fortifyDefenses, upgradeController } from \"../tasks/work\";\nimport { updateWorkingState, acquireEnergy } from \"./common\";\n\nexport function runWaller(creep: Creep): void {\n  updateWorkingState(creep);\n\n  if (!creep.memory.working) {\n    acquireEnergy(creep);\n    return;\n  }\n\n  const rcl = creep.room.controller?.level ?? 1;\n  if (fortifyDefenses(creep, getWallTargetHits(rcl))) return;\n  upgradeController(creep);\n}\n", "import { runBuilder } from \"./builder\";\nimport { runBootstrapper } from \"./bootstrapper\";\nimport { runClaimer } from \"./claimer\";\nimport { runHarvester } from \"./harvester\";\nimport { runHauler } from \"./hauler\";\nimport { runMiner } from \"./miner\";\nimport { runMineralHauler } from \"./mineralHauler\";\nimport { runMineralMiner } from \"./mineralMiner\";\nimport { runRepairer } from \"./repairer\";\nimport { runReserver } from \"./reserver\";\nimport { runScout } from \"./scout\";\nimport { runSoldier } from \"./soldier\";\nimport { runUpgrader } from \"./upgrader\";\nimport { runWaller } from \"./waller\";\n\nexport function runRole(creep: Creep): void {\n  switch (creep.memory.role) {\n    case \"harvester\":\n      runHarvester(creep);\n      return;\n    case \"hauler\":\n      runHauler(creep);\n      return;\n    case \"miner\":\n      runMiner(creep);\n      return;\n    case \"mineralMiner\":\n      runMineralMiner(creep);\n      return;\n    case \"mineralHauler\":\n      runMineralHauler(creep);\n      return;\n    case \"upgrader\":\n      runUpgrader(creep);\n      return;\n    case \"builder\":\n      runBuilder(creep);\n      return;\n    case \"bootstrapper\":\n      runBootstrapper(creep);\n      return;\n    case \"repairer\":\n      runRepairer(creep);\n      return;\n    case \"waller\":\n      runWaller(creep);\n      return;\n    case \"scout\":\n      runScout(creep);\n      return;\n    case \"reserver\":\n      runReserver(creep);\n      return;\n    case \"claimer\":\n      runClaimer(creep);\n      return;\n    case \"soldier\":\n      runSoldier(creep);\n      return;\n  }\n}\r\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAO,IAAM,aAAa;AAAA,EACxB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF;;;ACRA,IAAI,aAAa;AACjB,IAAI,YAAqB,CAAC;AAC1B,IAAI,aAAqB,CAAC;AAC1B,IAAI,mBAAqD,CAAC;AAE1D,SAAS,mBAA8C;AACrD,QAAM,SAAS,CAAC;AAChB,aAAW,QAAQ,YAAY;AAC7B,WAAO,IAAI,IAAI,CAAC;AAAA,EAClB;AACA,SAAO;AACT;AAEA,SAAS,uBAA6B;AApBtC;AAqBE,MAAI,eAAe,KAAK,KAAM;AAE9B,eAAa,KAAK;AAClB,cAAY,OAAO,OAAO,KAAK,MAAM;AACrC,eAAa,OAAO,OAAO,KAAK,KAAK,EAAE,OAAO,CAAC,SAAM;AAzBvD,QAAAA;AAyB0D,YAAAA,MAAA,KAAK,eAAL,gBAAAA,IAAiB;AAAA,GAAE;AAC3E,qBAAmB,CAAC;AAEpB,aAAW,SAAS,WAAW;AAC7B,UAAM,YAAW,WAAM,OAAO,aAAb,YAAyB,MAAM,KAAK;AACrD,QAAI,CAAC,iBAAiB,QAAQ,GAAG;AAC/B,uBAAiB,QAAQ,IAAI;AAAA,QAC3B,QAAQ,CAAC;AAAA,QACT,QAAQ,iBAAiB;AAAA,MAC3B;AAAA,IACF;AAEA,UAAM,SAAS,iBAAiB,QAAQ;AACxC,WAAO,OAAO,KAAK,KAAK;AACxB,WAAO,OAAO,MAAM,OAAO,IAAI,EAAE,KAAK,KAAK;AAAA,EAC7C;AACF;AAEO,SAAS,eAAwB;AACtC,uBAAqB;AACrB,SAAO;AACT;AAEO,SAAS,gBAAwB;AACtC,uBAAqB;AACrB,SAAO;AACT;AAEO,SAAS,oBAAoB,UAA2B;AArD/D;AAsDE,uBAAqB;AACrB,UAAO,4BAAiB,QAAQ,MAAzB,mBAA4B,WAA5B,YAAsC,CAAC;AAChD;AAEO,SAAS,2BAA2B,UAAkB,MAAyB;AA1DtF;AA2DE,uBAAqB;AACrB,UAAO,4BAAiB,QAAQ,MAAzB,mBAA4B,OAAO,UAAnC,YAA4C,CAAC;AACtD;AAEO,SAAS,6BAA6B,UAAkB,MAAwB;AACrF,SAAO,2BAA2B,UAAU,IAAI,EAAE;AACpD;;;AC7DA,SAAS,kBAA4C;AACnD,QAAM,SAAS,CAAC;AAChB,aAAW,QAAQ,YAAY;AAC7B,WAAO,IAAI,IAAI;AAAA,EACjB;AACA,SAAO;AACT;AAEO,SAAS,oBAAoB,MAA0B;AAZ9D;AAaE,QAAM,eAAe,gBAAgB;AACrC,aAAW,SAAS,oBAAoB,KAAK,IAAI,GAAG;AAClD,iBAAa,MAAM,OAAO,IAAI,KAAK;AAAA,EACrC;AAEA,QAAM,aAAa,KAAK,KAAK,eAAe;AAC5C,QAAM,mBAA+D,CAAC;AACtE,aAAW,aAAa,YAAY;AAClC,qBAAiB,UAAU,aAAa,MAAK,sBAAiB,UAAU,aAAa,MAAxC,YAA6C,KAAK;AAAA,EACjG;AAEA,QAAM,iBAAgB,gBAAK,YAAL,mBAAc,MAAM,gBAAgB,qBAApC,YAAwD;AAC9E,QAAM,aAAa,KAAK;AAExB,SAAO;AAAA,IACL,UAAU,KAAK;AAAA,IACf,MAAK,8CAAY,UAAZ,YAAqB;AAAA,IAC1B,iBAAiB,KAAK;AAAA,IACtB,yBAAyB,KAAK;AAAA,IAC9B,aAAa,KAAK,KAAK,YAAY,EAAE;AAAA,IACrC,uBAAuB,KAAK,KAAK,uBAAuB,EAAE;AAAA,IAC1D,cAAc,KAAK,KAAK,mBAAmB,EAAE;AAAA,IAC7C;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;;;AChBO,IAAM,kBAAkB;AAAA,EAC7B,KAAK;AAAA,IACH,SAAS;AAAA,IACT,eAAe,CAAC;AAAA,EAClB;AAAA,EACA,QAAQ;AAAA,IACN,gBAAgB;AAAA,IAChB,gBAAgB;AAAA,IAChB,6BAA6B;AAAA,IAC7B,kBAAkB;AAAA,IAClB,gBAAgB;AAAA,IAChB,mBAAmB;AAAA,IACnB,iBAAiB;AAAA,IACjB,qBAAqB;AAAA,IACrB,2BAA2B;AAAA,IAC3B,yBAAyB;AAAA,IACzB,6BAA6B;AAAA,IAC7B,qBAAqB;AAAA,EACvB;AAAA,EACA,OAAO;AAAA,IACL,cAAc;AAAA,IACd,aAAa;AAAA,IACb,qBAAqB;AAAA,IACrB,oBAAoB;AAAA,IACpB,+BAA+B;AAAA,IAC/B,iBAAiB;AAAA,IACjB,eAAe;AAAA,IACf,yBAAyB;AAAA,EAC3B;AAAA,EACA,SAAS;AAAA,IACP,eAAe;AAAA,IACf,aAAa;AAAA,IACb,iBAAiB;AAAA,IACjB,2BAA2B;AAAA,IAC3B,aAAa;AAAA,IACb,eAAe;AAAA,IACf,wBAAwB;AAAA,IACxB,qBAAqB;AAAA,IACrB,yBAAyB;AAAA,IACzB,mBAAmB;AAAA,IACnB,kBAAkB;AAAA,MAChB,WAAW;AAAA,MACX,OAAO;AAAA,MACP,KAAK;AAAA,MACL,MAAM;AAAA,IACR;AAAA,IACA,0BAA0B;AAAA,IAC1B,YAAY;AAAA,IACZ,eAAe;AAAA,IACf,cAAc;AAAA,IACd,aAAa;AAAA,IACb,oBAAoB;AAAA,EACtB;AAAA,EACA,OAAO;AAAA,IACL,oBAAoB;AAAA,EACtB;AAAA,EACA,WAAW;AAAA,IACT,6BAA6B;AAAA,IAC7B,6BAA6B;AAAA,EAC/B;AAAA,EACA,cAAc;AAAA,IACZ,aAAa;AAAA,IACb,0BAA0B;AAAA,IAC1B,8BAA8B;AAAA,IAC9B,2BAA2B;AAAA,IAC3B,wBAAwB;AAAA,IACxB,qCAAqC;AAAA,IACrC,wCAAwC;AAAA,EAC1C;AAAA,EACA,SAAS;AAAA,IACP,eAAe;AAAA,IACf,oBAAoB;AAAA,EACtB;AAAA,EACA,OAAO;AAAA,IACL,iBAAiB;AAAA,MACf,GAAG;AAAA,MACH,GAAG;AAAA,MACH,GAAG;AAAA,MACH,GAAG;AAAA,MACH,GAAG;AAAA,MACH,GAAG;AAAA,MACH,GAAG;AAAA,MACH,GAAG;AAAA,IACL;AAAA,EACF;AAAA,EACA,QAAQ;AAAA,IACN,8BAA8B;AAAA,IAC9B,kCAAkC;AAAA,EACpC;AAAA,EACA,UAAU;AAAA,IACR,SAAS;AAAA,IACT,QAAQ;AAAA,IACR,gBAAgB;AAAA,IAChB,YAAY;AAAA,IACZ,aAAa;AAAA,IACb,sBAAsB;AAAA,IACtB,uBAAuB;AAAA,IACvB,wBAAwB;AAAA,EAC1B;AAAA,EACA,UAAU;AAAA,IACR,iBAAiB;AAAA,IACjB,cAAc;AAAA,EAChB;AAAA,EACA,WAAW;AAAA,IACT,4BAA4B;AAAA,EAC9B;AAAA,EACA,OAAO;AAAA,IACL,SAAS;AAAA,IACT,QAAQ;AAAA,IACR,iBAAiB;AAAA,IACjB,yBAAyB;AAAA,IACzB,2BAA2B;AAAA,EAC7B;AAAA,EACA,WAAW;AAAA,IACT,SAAS;AAAA,IACT,UAAU;AAAA,EACZ;AAAA,EACA,QAAQ;AAAA,IACN,SAAS;AAAA,IACT,SAAS;AAAA,IACT,iBAAiB;AAAA,IACjB,wBAAwB;AAAA,IACxB,oBAAoB;AAAA,EACtB;AAAA,EACA,WAAW;AAAA,IACT,oBAAoB;AAAA,IACpB,oCAAoC;AAAA,IACpC,gCAAgC;AAAA,IAChC,0BAA0B;AAAA,MACxB,OAAO,CAAC;AAAA,IACV;AAAA,EACF;AAAA,EACA,aAAa;AAAA,IACX,SAAS,CAAC;AAAA,IACV,SAAS;AAAA,MACP,WAAW,CAAC;AAAA,MACZ,OAAO,CAAC;AAAA,MACR,KAAK,CAAC;AAAA,MACN,MAAM,CAAC;AAAA,IACT;AAAA,EACF;AAAA,EACA,OAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQP;AACF;AAEA,SAAS,OAAO,QAA4B;AAC1C,SAAO,CAAC,GAAG,IAAI,IAAI,MAAM,CAAC;AAC5B;AAEO,SAAS,oBAAoB,UAA+C;AAnLnF;AAoLE,QAAM,eAAe,gBAAgB,MAAM,QAAQ;AAEnD,SAAO;AAAA,IACL,cAAa,kDAAc,gBAAd,YAA6B,CAAC;AAAA,IAC3C,qBAAoB,kDAAc,uBAAd,YAAoC,CAAC;AAAA,IACzD,aAAY,kDAAc,eAAd,YAA4B;AAAA,IACxC,eAAe,OAAO,CAAC,IAAI,qBAAgB,IAAI,kBAApB,YAAqC,CAAC,GAAI,IAAI,kDAAc,kBAAd,YAA+B,CAAC,CAAE,CAAC;AAAA,IAC5G,qBAAqB,6CAAc;AAAA,IACnC,sBAAqB,kDAAc,wBAAd,YAAqC,CAAC;AAAA,EAC7D;AACF;AAEO,SAAS,gBAAgB,UAAkB,YAA6B;AAC7E,QAAM,eAAe,oBAAoB,QAAQ;AACjD,QAAM,iBAAiB,gBAAgB,OAAO,kBAAkB,gBAAgB,IAAI;AACpF,MAAI,CAAC,kBAAkB,aAAa,WAAY,QAAO;AACvD,SAAO,CAAC,aAAa,cAAc,SAAS,UAAU;AACxD;AAEO,SAAS,oBAAoB,UAAkB,YAA6B;AACjF,QAAM,eAAe,oBAAoB,QAAQ;AACjD,MAAI,aAAa,oBAAoB,SAAS,UAAU,EAAG,QAAO;AAClE,MAAI,aAAa,uBAAuB,aAAa,oBAAoB,SAAS,GAAG;AACnF,WAAO,aAAa,oBAAoB,SAAS,UAAU;AAAA,EAC7D;AACA,SAAO;AACT;AAaO,SAAS,sBAAsB,UAA4B;AA3NlE;AA4NE,SAAO,QAAO,qBAAgB,UAAU,yBAAyB,QAAQ,MAA3D,YAAgE,CAAC,CAAC;AAClF;AAEA,SAAS,qBAAqB,UAA0F;AACtH,MAAI,CAAC,OAAO,gBAAgB;AAC1B,WAAO,iBAAiB,CAAC;AAAA,EAC3B;AAEA,MAAI,CAAC,OAAO,eAAe,QAAQ,GAAG;AACpC,WAAO,eAAe,QAAQ,IAAI,CAAC;AAAA,EACrC;AAEA,SAAO,OAAO,eAAe,QAAQ;AACvC;AAEA,SAAS,oBAAoB,YAAmF;AAC9G,QAAM,OAAO,KAAK,MAAM,UAAU;AAClC,MAAI,EAAC,6BAAM,YAAY,QAAO;AAC9B,MAAI,CAAC,KAAK,WAAW,GAAI,QAAO;AAChC,SAAO,KAAK,KAAK,cAAc,EAAE,SAAS,IAAI,qBAAqB;AACrE;AAEO,SAAS,0BAA0B,UAAwB;AAChE,QAAM,QAAQ,qBAAqB,QAAQ;AAC3C,QAAM,UAAU,sBAAsB,QAAQ;AAE9C,aAAW,cAAc,SAAS;AAChC,QAAI,CAAC,MAAM,UAAU,GAAG;AACtB,YAAM,UAAU,IAAI;AAAA,IACtB;AAEA,UAAM,WAAW,oBAAoB,UAAU;AAC/C,QAAI,CAAC,SAAU;AACf,UAAM,UAAU,IAAI;AAAA,EACtB;AACF;AAEO,SAAS,wBAAwB,UAAkB,YAA0B;AAClF,QAAM,QAAQ,qBAAqB,QAAQ;AAC3C,QAAM,UAAU,IAAI;AACtB;AAEO,SAAS,6BAA6B,UAA4B;AACvE,4BAA0B,QAAQ;AAClC,QAAM,QAAQ,qBAAqB,QAAQ;AAC3C,SAAO,sBAAsB,QAAQ,EAAE,OAAO,CAAC,aAAa,MAAM,QAAQ,MAAM,cAAc;AAChG;AAEO,SAAS,wBAAwB,UAA4B;AAClE,4BAA0B,QAAQ;AAClC,QAAM,QAAQ,qBAAqB,QAAQ;AAC3C,QAAM,UAAU,sBAAsB,QAAQ,EAAE,OAAO,CAAC,aAAa,MAAM,QAAQ,MAAM,gBAAgB;AACzG,QAAM,QAAQ,KAAK,IAAI,GAAG,gBAAgB,UAAU,kCAAkC;AACtF,MAAI,UAAU,EAAG,QAAO,CAAC;AACzB,SAAO,QAAQ,MAAM,GAAG,KAAK;AAC/B;AAEO,SAAS,kBAAkB,KAAqB;AACrD,QAAM,SAAS,gBAAgB,MAAM,gBAAgB,GAAG;AACxD,MAAI,OAAQ,QAAO;AACnB,SAAO,OAAO,IAAI,gBAAgB,MAAM,gBAAgB,CAAC,IAAI,gBAAgB,MAAM,gBAAgB,CAAC;AACtG;AAEO,SAAS,kBAAkB,MAAqB;AACrD,QAAM,YAAY,KAAK,IAAI,GAAG,KAAK,IAAI,GAAG,gBAAgB,UAAU,2BAA2B,CAAC;AAChG,QAAM,iBAAiB,KAAK,KAAK,KAAK,0BAA0B,SAAS;AAEzE,QAAM,mBAAmB,KAAK,IAAI,GAAG,gBAAgB,UAAU,2BAA2B;AAC1F,MAAI,KAAK,WAAW,mBAAmB,GAAG;AACxC,UAAM,gBAAgB,KAAK,QAAQ,MAAM,gBAAgB,eAAe;AACxE,QAAI,iBAAiB,iBAAkB,QAAO;AAE9C,WAAO,KAAK,kBAAkB;AAAA,EAChC;AAEA,SAAO,KAAK,kBAAkB;AAChC;;;ACrSA,SAAS,WAAW,MAAgC;AAClD,UAAQ,MAAM;AAAA,IACZ,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT;AACE,aAAO;AAAA,EACX;AACF;AAEA,SAAS,aAAa,SAMpB;AACA,MAAI,QAAQ;AACZ,MAAI,cAAc;AAClB,MAAI,cAAc;AAClB,MAAI,YAAY;AAChB,MAAI,YAAY;AAEhB,aAAW,YAAY,QAAQ,MAAM;AACnC,QAAI,SAAS,QAAQ,EAAG;AACxB,aAAS,WAAW,SAAS,IAAI;AACjC,QAAI,SAAS,SAAS,OAAQ,gBAAe;AAC7C,QAAI,SAAS,SAAS,cAAe,gBAAe;AACpD,QAAI,SAAS,SAAS,KAAM,cAAa;AACzC,QAAI,SAAS,SAAS,KAAM,cAAa;AAAA,EAC3C;AAEA,SAAO,EAAE,OAAO,aAAa,aAAa,WAAW,UAAU;AACjE;AAEA,SAAS,qBAAqB,OAA4B;AACxD,MAAI,SAAS,gBAAgB,OAAO,oBAAqB,QAAO;AAChE,MAAI,SAAS,gBAAgB,OAAO,gBAAiB,QAAO;AAC5D,MAAI,SAAS,gBAAgB,OAAO,kBAAmB,QAAO;AAC9D,MAAI,SAAS,gBAAgB,OAAO,eAAgB,QAAO;AAC3D,SAAO;AACT;AAEA,SAAS,gBAAgB,OAA4B;AACnD,UAAQ,OAAO;AAAA,IACb,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT;AACE,aAAO;AAAA,EACX;AACF;AAEA,SAAS,qBAYP;AACA,MAAI,CAAC,OAAO,QAAQ;AAClB,WAAO,SAAS,CAAC;AAAA,EACnB;AACA,SAAO,OAAO;AAChB;AAEA,SAAS,wBAA4D;AACnE,MAAI,CAAC,OAAO,WAAW;AACrB,WAAO,YAAY,CAAC;AAAA,EACtB;AACA,SAAO,OAAO;AAChB;AAEA,SAAS,aAAa,MAAYC,cAAgC;AAhGlE;AAiGE,QAAM,YAAY,sBAAsB;AAExC,MAAIA,iBAAgB,UAAUA,iBAAgB,YAAY;AACxD,cAAU,KAAK,IAAI,IAAI;AACvB;AAAA,EACF;AAEA,MAAIA,iBAAgB,YAAYA,iBAAgB,OAAO;AACrD,cAAU,KAAK,IAAI,IAAI;AACvB;AAAA,EACF;AAEA,QAAM,OAAM,gBAAK,eAAL,mBAAiB,UAAjB,YAA0B;AACtC,MAAI,OAAO,GAAG;AACZ,cAAU,KAAK,IAAI,IAAI;AAAA,EACzB,WAAW,OAAO,GAAG;AACnB,cAAU,KAAK,IAAI,IAAI;AAAA,EACzB,OAAO;AACL,cAAU,KAAK,IAAI,IAAI;AAAA,EACzB;AACF;AAEA,SAAS,qBAAqB,MAAkB;AAC9C,QAAM,WAAW,KAAK,KAAK,mBAAmB;AAC9C,QAAM,SAAS,mBAAmB;AAClC,QAAM,WAAW,OAAO,KAAK,IAAI;AAEjC,MAAI,SAAS,WAAW,GAAG;AACzB,QAAI,YAAY,SAAS,YAAY,KAAK,MAAM;AAC9C,mBAAa,MAAM,SAAS,KAAK;AACjC;AAAA,IACF;AAEA,WAAO,KAAK,IAAI,IAAI;AAAA,MAClB,OAAO;AAAA,MACP,OAAO;AAAA,MACP,cAAc;AAAA,MACd,aAAa;AAAA,MACb,aAAa;AAAA,MACb,WAAW;AAAA,MACX,WAAW;AAAA,MACX,WAAW,KAAK;AAAA,IAClB;AACA,iBAAa,MAAM,MAAM;AACzB;AAAA,EACF;AAEA,MAAI,QAAQ;AACZ,MAAI,cAAc;AAClB,MAAI,cAAc;AAClB,MAAI,YAAY;AAChB,MAAI,YAAY;AAEhB,aAAW,WAAW,UAAU;AAC9B,UAAM,eAAe,aAAa,OAAO;AACzC,aAAS,aAAa;AACtB,mBAAe,aAAa;AAC5B,mBAAe,aAAa;AAC5B,iBAAa,aAAa;AAC1B,iBAAa,aAAa;AAAA,EAC5B;AAEA,QAAM,QAAQ,qBAAqB,KAAK;AACxC,SAAO,KAAK,IAAI,IAAI;AAAA,IAClB;AAAA,IACA;AAAA,IACA,cAAc,SAAS;AAAA,IACvB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,WAAW,KAAK,OAAO,gBAAgB,OAAO;AAAA,EAChD;AAEA,QAAM,wBAAwB,gBAAgB,OAAO;AACrD,MACE,gBAAgB,KAAK,KAAK,gBAAgB,qBAAqB,KAC/D,KAAK,cACL,CAAC,KAAK,WAAW,YACjB,KAAK,WAAW,oBAAoB,KACpC,KAAK,WAAW,qBAAqB,QACrC;AACA,UAAM,4BAA4B,SAAS,KAAK,CAAC,YAAY;AAC3D,YAAM,YAAY,KAAK,KAAK,cAAc,EAAE,KAAK,CAAC,UAAU,QAAQ,IAAI,WAAW,KAAK,KAAK,CAAC;AAC9F,YAAM,iBAAiB,QAAQ,IAAI,WAAW,KAAK,UAAiC,KAAK;AACzF,aAAO,aAAa;AAAA,IACtB,CAAC;AAED,QAAI,2BAA2B;AAC7B,WAAK,WAAW,iBAAiB;AAAA,IACnC;AAAA,EACF;AAEA,eAAa,MAAM,KAAK;AAC1B;AAEO,SAAS,yBAAyB,UAA0B;AAjMnE;AAkME,QAAM,UAAS,YAAO,WAAP,mBAAgB;AAC/B,MAAI,CAAC,UAAU,OAAO,YAAY,KAAK,KAAM,QAAO;AAEpD,UAAQ,OAAO,OAAO;AAAA,IACpB,KAAK;AACH,aAAO,gBAAgB,OAAO;AAAA,IAChC,KAAK;AACH,aAAO,gBAAgB,OAAO;AAAA,IAChC,KAAK;AACH,aAAO,gBAAgB,OAAO;AAAA,IAChC;AACE,aAAO;AAAA,EACX;AACF;AAEO,SAAS,mBAAyB;AACvC,aAAW,QAAQ,cAAc,GAAG;AAClC,yBAAqB,IAAI;AAAA,EAC3B;AACF;;;ACxMA,SAAS,cAAwC;AAC/C,QAAM,UAAU,CAAC;AACjB,aAAW,QAAQ,YAAY;AAC7B,YAAQ,IAAI,IAAI;AAAA,EAClB;AACA,SAAO;AACT;AAEA,SAAS,mBAAmB,QAAkC,WAAoD;AAChH,aAAW,QAAQ,YAAY;AAC7B,UAAM,UAAU,UAAU,IAAI;AAC9B,QAAI,YAAY,OAAW;AAC3B,WAAO,IAAI,IAAI,KAAK,IAAI,GAAG,OAAO;AAAA,EACpC;AACF;AAEA,SAAS,yBAAyB,UAAiC;AACjE,MAAI,CAAC,gBAAgB,SAAS,QAAS,QAAO;AAC9C,MAAI,SAAS,MAAM,gBAAgB,SAAS,OAAQ,QAAO;AAE3D,QAAM,OAAO,KAAK,MAAM,SAAS,QAAQ;AACzC,MAAI,CAAC,KAAM,QAAO;AAElB,MAAI,gBAAgB,SAAS,kBAAkB,CAAC,KAAK,QAAS,QAAO;AAErE,QAAM,UAAU,KAAK,KAAK,aAAa,EAAE,CAAC;AAC1C,SAAO,QAAQ,WAAW,QAAQ,gBAAgB,CAAC;AACrD;AAEA,SAAS,mBAAmB,UAAiC;AAC3D,MAAI,CAAC,gBAAgB,UAAU,oBAAoB;AACjD,WAAO,6BAA6B,SAAS,QAAQ,EAAE,SAAS;AAAA,EAClE;AAEA,QAAM,QAAQ,KAAK,IAAI,cAAc,SAAS,QAAQ;AACtD,MAAI,CAAC,MAAO,QAAO;AAEnB,QAAM,YAAY,CAAC,GAAG,IAAI,IAAI,OAAO,OAAO,KAAK,CAAC,CAAC;AACnD,aAAW,YAAY,WAAW;AAChC,QAAI,CAAC,oBAAoB,SAAS,UAAU,QAAQ,EAAG;AAEvD,UAAM,OAAO,KAAK,MAAM,QAAQ;AAChC,QAAI,EAAC,6BAAM,YAAY,QAAO;AAC9B,QAAI,CAAC,KAAK,WAAW,SAAS,CAAC,KAAK,WAAW,YAAa,QAAO;AAAA,EACrE;AAEA,SAAO;AACT;AAEO,SAAS,mBACd,UACA,OACA,cAC0B;AAlE5B;AAmEE,QAAM,UAAU,YAAY;AAC5B,QAAM,eAAe,oBAAoB,SAAS,QAAQ;AAC1D,QAAM,aAAY,kBAAO,cAAP,mBAAmB,SAAS,cAA5B,YAAyC;AAG3D,UAAQ,YAAY,KAAK,IAAI,gBAAgB,QAAQ,eAAe,SAAS,WAAW;AACxF,UAAQ,SAAS,gBAAgB,QAAQ;AACzC,UAAQ,WAAW,gBAAgB,QAAQ;AAC3C,UAAQ,UACN,SAAS,wBAAwB,IAC7B,gBAAgB,QAAQ,yBACxB,gBAAgB,QAAQ;AAE9B,MAAI,UAAU,aAAa;AACzB,UAAM,wBAAwB,SAAS,2BAA2B;AAClE,UAAM,kBAAkB,UAAU,UAAU,IAAI,KAAK,IAAI,GAAG,gBAAgB,QAAQ,eAAe;AACnG,UAAM,4BAA4B,KAAK,IAAI,GAAG,gBAAgB,QAAQ,yBAAyB;AAC/F,UAAM,cAAc,UAAU,UAAU,IAAI,KAAK,IAAI,GAAG,gBAAgB,QAAQ,WAAW;AAC3F,YAAQ,YAAY,wBAChB,KAAK,IAAI,QAAQ,WAAW,CAAC,IAC7B,KAAK,IAAI,gBAAgB,QAAQ,eAAe,SAAS,WAAW;AACxE,YAAQ,QAAQ,wBAAwB,SAAS,cAAc,kBAAkB;AACjF,YAAQ,SAAS,KAAK;AAAA,MACpB,QAAQ;AAAA,MACR,SAAS,cAAc,4BAA4B;AAAA,IACrD;AACA,YAAQ,WAAW,gBAAgB,QAAQ,iBAAiB,KAAK;AACjE,YAAQ,UACN,SAAS,wBAAwB,gBAAgB,QAAQ,0BACrD,gBAAgB,QAAQ,oBACxB,QAAQ;AACd,YAAQ,WAAW,gBAAgB,QAAQ;AAAA,EAC7C;AAEA,MAAI,aAAa,YAAY;AAC3B,YAAQ,SAAS;AAAA,EACnB;AAEA,MAAI,aAAa,mBAAmB;AAClC,YAAQ,QAAQ,gBAAgB,QAAQ;AACxC,YAAQ,WAAW,gBAAgB,QAAQ;AAAA,EAC7C;AAEA,MAAI,aAAa,kBAAkB,mBAAmB,QAAQ,GAAG;AAC/D,YAAQ,UAAU,gBAAgB,QAAQ;AAAA,EAC5C;AAEA,QAAM,mBAAmB,wBAAwB,SAAS,QAAQ;AAClE,MAAI,iBAAiB,SAAS,GAAG;AAC/B,YAAQ,eAAe,iBAAiB,SAAS,gBAAgB,UAAU;AAAA,EAC7E;AAEA,MAAI,aAAa,cAAc;AAC7B,YAAQ,UAAU,KAAK;AAAA,MACrB,gBAAgB,QAAQ;AAAA,MACxB,KAAK,KAAK,SAAS,eAAe,KAAK,IAAI,GAAG,gBAAgB,QAAQ,kBAAkB,CAAC;AAAA,IAC3F;AAAA,EACF;AAEA,MAAI,yBAAyB,QAAQ,GAAG;AACtC,YAAQ,eAAe,gBAAgB,SAAS;AAChD,YAAQ,gBAAgB,gBAAgB,SAAS;AAAA,EACnD;AAEA,QAAM,oBAAoB,yBAAyB,SAAS,QAAQ;AACpE,MAAI,oBAAoB,GAAG;AACzB,YAAQ,UAAU,KAAK,IAAI,QAAQ,SAAS,iBAAiB;AAAA,EAC/D;AAEA,MAAI,cAAc,OAAO;AACvB,YAAQ,WAAW,KAAK,IAAI,QAAQ,UAAU,CAAC;AAC/C,YAAQ,UAAU,KAAK,IAAI,QAAQ,SAAS,CAAC;AAC7C,YAAQ,SAAS,KAAK,IAAI,QAAQ,QAAQ,SAAS,cAAc,CAAC;AAClE,YAAQ,WAAW,KAAK,IAAI,QAAQ,UAAU,CAAC;AAAA,EACjD,WAAW,cAAc,YAAY;AACnC,YAAQ,WAAW,KAAK,IAAI,QAAQ,UAAU,CAAC;AAC/C,YAAQ,WAAW,KAAK,IAAI,QAAQ,UAAU,CAAC;AAAA,EACjD;AAEA,QAAM,OAAO,KAAK,MAAM,SAAS,QAAQ;AACzC,MAAI,QAAQ,kBAAkB,IAAI,GAAG;AACnC,YAAQ,WAAW;AAAA,EACrB;AAEA,qBAAmB,SAAS,gBAAgB,YAAY,OAAO;AAC/D,qBAAmB,UAAS,qBAAgB,YAAY,QAAQ,KAAK,MAAzC,YAA8C,CAAC,CAAC;AAC5E,qBAAmB,SAAS,aAAa,WAAW;AACpD,qBAAmB,UAAS,kBAAa,mBAAmB,KAAK,MAArC,YAA0C,CAAC,CAAC;AAExE,SAAO;AACT;;;ACrJO,IAAM,mBAA2C;AAAA,EACtD,EAAE,OAAO,QAAQ,QAAQ,GAAG,mBAAmB,KAAK;AAAA,EACpD,EAAE,OAAO,OAAO,QAAQ,GAAG,mBAAmB,IAAI;AAAA,EAClD,EAAE,OAAO,SAAS,QAAQ,GAAG,mBAAmB,IAAI;AAAA,EACpD,EAAE,OAAO,aAAa,QAAQ,GAAG,mBAAmB,EAAE;AACxD;;;ACRA,SAAS,YAAY,UAAqC;AACxD,aAAW,aAAa,kBAAkB;AACxC,QAAI,SAAS,OAAO,UAAU,UAAU,SAAS,2BAA2B,UAAU,mBAAmB;AACvG,aAAO,UAAU;AAAA,IACnB;AAAA,EACF;AAEA,SAAO;AACT;AAEA,SAAS,iBAAyB;AAChC,SAAO,cAAc,EAAE;AACzB;AAEA,SAAS,UAAU,UAAiC;AAClD,QAAM,WAAW,KAAK,IAAI;AAC1B,QAAM,UAAU,eAAe;AAC/B,SAAO,SAAS,OAAO,gBAAgB,MAAM,mBAAmB,WAAW;AAC7E;AAEA,SAAS,UAAU,UAAiC;AAClD,QAAM,eAAe,oBAAoB,SAAS,QAAQ;AAC1D,MAAI,CAAC,gBAAgB,OAAO,kBAAkB,CAAC,gBAAgB,IAAI,WAAW,aAAa,WAAY,QAAO;AAC9G,SACE,SAAS,OAAO,gBAAgB,MAAM,iBACtC,SAAS,iBAAiB,gBAAgB,MAAM;AAEpD;AAEO,SAAS,mBAAmB,UAAwB,OAAqC;AAC9F,SAAO;AAAA,IACL,YAAY,UAAU;AAAA,IACtB,aAAa,SAAS,OAAO,gBAAgB,MAAM;AAAA,IACnD,YAAY,SAAS,OAAO,gBAAgB,MAAM;AAAA,IAClD,mBACE,gBAAgB,MAAM,uBACtB,SAAS,OAAO,gBAAgB,MAAM,sBACtC,SAAS,2BAA2B,gBAAgB,MAAM;AAAA,IAC5D,gBAAgB,UAAU,QAAQ;AAAA,IAClC,cAAc,UAAU,QAAQ;AAAA,EAClC;AACF;AAEO,SAAS,2BAA2B,UAA+E;AACxH,QAAM,QAAQ,YAAY,QAAQ;AAClC,QAAM,eAAe,mBAAmB,UAAU,KAAK;AACvD,SAAO,EAAE,OAAO,aAAa;AAC/B;;;AC3CA,SAASC,QAAO,QAA4B;AAC1C,SAAO,CAAC,GAAG,IAAI,IAAI,MAAM,CAAC;AAC5B;AAEA,SAAS,iBAAiB,MAAsB;AAC9C,QAAM,QAAQ,KAAK,IAAI,cAAc,KAAK,IAAI;AAC9C,MAAI,CAAC,MAAO,QAAO,CAAC;AACpB,SAAOA,QAAO,OAAO,OAAO,KAAK,CAAC;AACpC;AAEO,SAAS,kBAAkB,MAAY,UAA0C;AAnBxF;AAoBE,QAAM,mBAAmB,iBAAiB,IAAI;AAC9C,QAAM,yBAAyB,iBAAiB,OAAO,CAAC,SAAS,oBAAoB,KAAK,MAAM,IAAI,CAAC;AAErG,QAAM,mBAAmB;AACzB,QAAM,qBAAqB,SAAS,aAAa,oBAAoB,yBAAyB,CAAC;AAE/F,QAAM,uBAAuB,uBAAuB,OAAO,CAAC,SAAS;AACnE,UAAM,aAAa,KAAK,MAAM,IAAI;AAClC,QAAI,EAAC,yCAAY,YAAY,QAAO;AACpC,WAAO,CAAC,WAAW,WAAW,SAAS,CAAC,WAAW,WAAW;AAAA,EAChE,CAAC;AAED,QAAM,yBAAyB,6BAA6B,KAAK,IAAI;AACrE,QAAM,uBAAuB,wBAAwB,KAAK,IAAI;AAC9D,QAAM,mBAAmB,gBAAgB,UAAU,qBAAqB,uBAAuB;AAC/F,QAAM,mBAAmB,SAAS,aAAa,kBAAkB,iBAAiB,SAAS,IAAI,CAAC,iBAAiB,CAAC,CAAC,IAAI,CAAC;AAExH,QAAM,oBAAoB,SAAS,aAAa,eAC5C,iBAAiB,OAAO,CAAC,SAAS;AAChC,QAAI,CAAC,gBAAgB,KAAK,MAAM,IAAI,EAAG,QAAO;AAC9C,UAAM,aAAa,KAAK,MAAM,IAAI;AAClC,QAAI,CAAC,WAAY,QAAO;AACxB,WAAO,WAAW,KAAK,mBAAmB,EAAE,SAAS;AAAA,EACvD,CAAC,IACD,CAAC;AAEL,QAAM,eAAc,YAAO,WAAP,mBAAgB,KAAK;AACzC,QAAM,wBACJ,gBAAgB,OAAO,kBACvB,gBAAgB,UAChB,YAAY,aAAa,KAAK,QAC9B,YAAY,UAAU;AACxB,MAAI,yBAAyB,CAAC,kBAAkB,SAAS,KAAK,IAAI,GAAG;AACnE,sBAAkB,QAAQ,KAAK,IAAI;AAAA,EACrC;AAEA,SAAO;AAAA,IACL,GAAG;AAAA,IACH;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;;;ACxDO,SAAS,mBAAyB;AACvC,aAAW,QAAQ,cAAc,GAAG;AAClC,8BAA0B,KAAK,IAAI;AAEnC,UAAM,WAAW,oBAAoB,IAAI;AACzC,UAAM,EAAE,OAAO,aAAa,IAAI,2BAA2B,QAAQ;AACnE,UAAM,eAAe,mBAAmB,UAAU,OAAO,YAAY;AAErE,UAAM,eAA+B;AAAA,MACnC;AAAA,MACA;AAAA,MACA;AAAA,MACA,kBAAkB,CAAC;AAAA,MACnB,oBAAoB,CAAC;AAAA,MACrB,kBAAkB,CAAC;AAAA,MACnB,sBAAsB,CAAC;AAAA,MACvB,mBAAmB,CAAC;AAAA,IACtB;AAEA,UAAM,WAAW,kBAAkB,MAAM,YAAY;AAErD,QAAI,CAAC,OAAO,UAAU;AACpB,aAAO,WAAW,CAAC;AAAA,IACrB;AAEA,WAAO,SAAS,KAAK,IAAI,IAAI;AAAA,EAC/B;AACF;;;AC3BA,SAAS,WAAW,MAAY,GAAW,GAAoB;AAC7D,MAAI,IAAI,KAAK,IAAI,MAAM,IAAI,KAAK,IAAI,GAAI,QAAO;AAC/C,SAAO,KAAK,WAAW,EAAE,IAAI,GAAG,CAAC,MAAM;AACzC;AAEA,SAAS,YAAY,GAAW,GAAmB;AACjD,QAAM,iBAAiB,KAAK,IAAI,GAAG,KAAK,GAAG,GAAG,KAAK,CAAC;AACpD,MAAI,kBAAkB,gBAAgB,OAAO,gBAAiB,QAAO;AACrE,UAAQ,gBAAgB,OAAO,kBAAkB,kBAAkB;AACrE;AAEA,SAAS,kBAAkB,MAAY,GAAW,GAAmB;AACnE,MAAI,WAAW;AAEf,WAAS,KAAK,IAAI,MAAM,GAAG,MAAM,GAAG;AAClC,aAAS,KAAK,IAAI,MAAM,GAAG,MAAM,GAAG;AAClC,UAAI,WAAW,MAAM,IAAI,IAAI,IAAI,EAAE,GAAG;AACpC,oBAAY;AAAA,MACd;AAAA,IACF;AAAA,EACF;AAEA,SAAO,WAAW;AACpB;AAEA,SAAS,cAAc,UAAkB,SAAyB;AAChE,SAAO,KAAK,IAAI,GAAG,KAAK,KAAK,IAAI,WAAW,OAAO,IAAI,CAAC;AAC1D;AAEA,SAAS,YAAY,MAAY,GAAW,GAAmB;AAC7D,MAAI,CAAC,WAAW,MAAM,GAAG,CAAC,EAAG,QAAO,OAAO;AAE3C,QAAM,OAAO,KAAK,UAAU,iBAAiB,GAAG,CAAC;AACjD,MAAI,KAAK,SAAS,EAAG,QAAO,OAAO;AAEnC,MAAI,QAAQ,kBAAkB,MAAM,GAAG,CAAC;AACxC,WAAS,YAAY,GAAG,CAAC;AAEzB,QAAM,aAAa,KAAK;AACxB,MAAI,YAAY;AACd,aAAS,cAAc,WAAW,IAAI,WAAW,GAAG,CAAC,GAAG,gBAAgB,OAAO,sBAAsB;AAAA,EACvG;AAEA,QAAM,UAAU,KAAK,KAAK,YAAY;AACtC,aAAW,UAAU,SAAS;AAC5B,aAAS,cAAc,OAAO,IAAI,WAAW,GAAG,CAAC,GAAG,gBAAgB,OAAO,kBAAkB;AAAA,EAC/F;AAEA,SAAO;AACT;AAEA,SAAS,oBAAoB,MAAmC;AAC9D,MAAI,OAA8B;AAElC,WAAS,IAAI,gBAAgB,OAAO,SAAS,KAAK,gBAAgB,OAAO,SAAS,KAAK,GAAG;AACxF,aAAS,IAAI,gBAAgB,OAAO,SAAS,KAAK,gBAAgB,OAAO,SAAS,KAAK,GAAG;AACxF,YAAM,QAAQ,YAAY,MAAM,GAAG,CAAC;AACpC,UAAI,CAAC,OAAO,SAAS,KAAK,EAAG;AAE7B,UAAI,CAAC,QAAQ,QAAQ,KAAK,OAAO;AAC/B,eAAO,EAAE,GAAG,GAAG,MAAM;AAAA,MACvB;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AACT;AAEO,SAAS,cAAc,MAAiC;AAC7D,MAAI,CAAC,OAAO,WAAW;AACrB,WAAO,YAAY,CAAC;AAAA,EACtB;AAEA,QAAM,SAAS,OAAO,UAAU,KAAK,IAAI;AACzC,MAAI,UAAU,WAAW,MAAM,OAAO,SAAS,OAAO,OAAO,GAAG;AAC9D,WAAO,IAAI,aAAa,OAAO,SAAS,OAAO,SAAS,KAAK,IAAI;AAAA,EACnE;AAEA,QAAM,QAAQ,KAAK,KAAK,cAAc,EAAE,CAAC;AACzC,MAAI,OAAO;AACT,WAAO,UAAU,KAAK,IAAI,IAAI;AAAA,MAC5B,SAAS,MAAM,IAAI;AAAA,MACnB,SAAS,MAAM,IAAI;AAAA,MACnB,OAAO;AAAA,MACP,WAAW,KAAK;AAAA,IAClB;AACA,WAAO,MAAM;AAAA,EACf;AAEA,QAAM,YAAY,oBAAoB,IAAI;AAC1C,MAAI,CAAC,UAAW,QAAO;AAEvB,SAAO,UAAU,KAAK,IAAI,IAAI;AAAA,IAC5B,SAAS,UAAU;AAAA,IACnB,SAAS,UAAU;AAAA,IACnB,OAAO,UAAU;AAAA,IACjB,WAAW,KAAK;AAAA,EAClB;AAEA,SAAO,IAAI,aAAa,UAAU,GAAG,UAAU,GAAG,KAAK,IAAI;AAC7D;;;AC1GO,SAAS,aAAa,OAAc,QAA8C,QAAQ,GAAS;AACxG,QAAM,OAAO,QAAQ;AAAA,IACnB,WAAW;AAAA,IACX,UAAU,gBAAgB,SAAS;AAAA,IACnC,OAAO,wBAAS,gBAAgB,SAAS;AAAA,IACzC,oBAAoB,EAAE,QAAQ,UAAU;AAAA,EAC1C,CAAC;AACH;AAEO,SAAS,iBAAiB,OAAc,UAAwB;AACrE,QAAM,SAAS,IAAI,aAAa,IAAI,IAAI,QAAQ;AAChD,eAAa,OAAO,QAAQ,EAAE;AAChC;;;ACXA,SAAS,0BAA0B,OAA4C;AAC7E,QAAM,OAAO,OAAO,KAAK,KAAK;AAC9B,SAAO,KAAK,OAAO,CAAC,aAAa,aAAa,mBAAmB,MAAM,gBAAgB,QAAQ,IAAI,CAAC;AACtG;AAEO,SAAS,YAAY,MAA4B;AARxD;AASE,UAAO,UAAK,KAAK,aAAa,EAAE,CAAC,MAA1B,YAA+B;AACxC;AAEO,SAAS,qBAAqB,MAAuC;AAC1E,QAAM,UAAU,YAAY,IAAI;AAChC,MAAI,CAAC,QAAS,QAAO;AAErB,QAAM,YAAY,QAAQ,IACvB,QAAQ,eAAe,EACvB,KAAK,CAAC,UAAU,MAAM,kBAAkB,mBAAmB;AAE9D,SAAO,gCAAa;AACtB;AAEO,SAAS,qBAAqB,MAAuC;AAvB5E;AAwBE,QAAM,UAAU,YAAY,IAAI;AAChC,MAAI,CAAC,QAAS,QAAO;AAErB,QAAM,aAAa,QAAQ,IAAI,YAAY,iBAAiB,GAAG;AAAA,IAC7D,QAAQ,CAAC,cAAyB,UAAU,kBAAkB;AAAA,EAChE,CAAC;AAED,UAAO,gBAAW,CAAC,MAAZ,YAAiB;AAC1B;AAEO,SAAS,eAAe,OAAuB;AACpD,QAAM,UAAU,YAAY,MAAM,IAAI;AACtC,MAAI,CAAC,WAAW,QAAQ,iBAAiB,EAAG,QAAO;AAEnD,QAAM,YAAY,qBAAqB,MAAM,IAAI;AACjD,MAAI,CAAC,aAAa,UAAU,WAAW,EAAG,QAAO;AAEjD,QAAM,SAAS,MAAM,QAAQ,OAAO;AACpC,MAAI,WAAW,kBAAkB;AAC/B,iBAAa,OAAO,OAAO;AAC3B,WAAO;AAAA,EACT;AAEA,SAAO,WAAW;AACpB;AAEO,SAAS,8BAA8B,OAAuB;AACnE,QAAM,YAAY,MAAM,IAAI,kBAAkB,iBAAiB;AAAA,IAC7D,QAAQ,CAAC,cAAyB;AAChC,UAAI,UAAU,kBAAkB,oBAAqB,QAAO;AAC5D,YAAM,QAAS,UAAiC;AAChD,YAAM,kBAAkB,MAAM,gBAAgB,IAAI,MAAM,gBAAgB,eAAe;AACvF,aAAO,mBAAmB,gBAAgB,SAAS;AAAA,IACrD;AAAA,EACF,CAAC;AAED,MAAI,CAAC,UAAW,QAAO;AAEvB,QAAM,YAAY,0BAA0B,UAAU,KAAK;AAC3D,QAAM,WAAW,UAAU,CAAC;AAC5B,MAAI,CAAC,SAAU,QAAO;AAEtB,QAAM,SAAS,MAAM,SAAS,WAAW,QAAQ;AACjD,MAAI,WAAW,kBAAkB;AAC/B,iBAAa,OAAO,SAAS;AAC7B,WAAO;AAAA,EACT;AAEA,SAAO,WAAW;AACpB;AAEO,SAAS,sBAAsB,OAAuB;AAC3D,QAAM,UAAU,MAAM,IAAI,kBAAkB,wBAAwB;AAAA,IAClE,QAAQ,CAAC,aAAuB,SAAS,iBAAiB,mBAAmB,SAAS,SAAS;AAAA,EACjG,CAAC;AAED,MAAI,CAAC,QAAS,QAAO;AAErB,QAAM,SAAS,MAAM,OAAO,OAAO;AACnC,MAAI,WAAW,kBAAkB;AAC/B,iBAAa,OAAO,OAAO;AAC3B,WAAO;AAAA,EACT;AAEA,SAAO,WAAW;AACpB;AAEO,SAAS,wBAAwB,OAAuB;AA3F/D;AA4FE,QAAM,UACJ,iBAAM,KAAK,YAAX,YACC,gBAAgB,SAAS,wBAAwB,MAAM,KAAK,WAAW,SADxE,YAEC,gBAAgB,SAAS,yBACrB,MAAM,IAAI,kBAAkB,iBAAiB;AAAA,IAC5C,QAAQ,CAAC,cAAyB,UAAU,kBAAkB;AAAA,EAChE,CAAC,IACD;AAEN,MAAI,CAAC,OAAQ,QAAO;AAEpB,QAAM,YAAY,0BAA0B,MAAM,KAAK;AACvD,QAAM,WAAW,UAAU,CAAC;AAC5B,MAAI,CAAC,SAAU,QAAO;AAEtB,QAAM,SAAS,MAAM,SAAS,QAAQ,QAAQ;AAC9C,MAAI,WAAW,kBAAkB;AAC/B,iBAAa,OAAO,MAAM;AAC1B,WAAO;AAAA,EACT;AAEA,SAAO,WAAW;AACpB;;;AC7GA,IAAM,wBAAwB,oBAAI,IAAY;AAAA;AAAA,EAE5C;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA;AAAA,EAEA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA;AAAA,EAEA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,CAAC;AAED,IAAM,yBAAkD;AAAA,EACtD,CAAC,GAAG,CAAC;AAAA,EACL,CAAC,IAAI,CAAC;AAAA,EACN,CAAC,GAAG,CAAC;AAAA,EACL,CAAC,GAAG,EAAE;AAAA,EACN,CAAC,GAAG,CAAC;AAAA,EACL,CAAC,GAAG,EAAE;AAAA,EACN,CAAC,IAAI,CAAC;AAAA,EACN,CAAC,IAAI,EAAE;AAAA,EACP,CAAC,GAAG,CAAC;AAAA,EACL,CAAC,IAAI,CAAC;AAAA,EACN,CAAC,GAAG,EAAE;AAAA,EACN,CAAC,IAAI,EAAE;AAAA,EACP,CAAC,GAAG,CAAC;AAAA,EACL,CAAC,GAAG,EAAE;AAAA,EACN,CAAC,IAAI,CAAC;AAAA,EACN,CAAC,IAAI,EAAE;AAAA,EACP,CAAC,GAAG,CAAC;AAAA,EACL,CAAC,IAAI,CAAC;AAAA,EACN,CAAC,GAAG,EAAE;AAAA,EACN,CAAC,IAAI,EAAE;AAAA,EACP,CAAC,GAAG,CAAC;AAAA,EACL,CAAC,GAAG,EAAE;AAAA,EACN,CAAC,IAAI,CAAC;AAAA,EACN,CAAC,IAAI,EAAE;AAAA,EACP,CAAC,GAAG,CAAC;AAAA,EACL,CAAC,IAAI,CAAC;AAAA,EACN,CAAC,GAAG,EAAE;AAAA,EACN,CAAC,IAAI,EAAE;AAAA,EACP,CAAC,GAAG,CAAC;AAAA,EACL,CAAC,GAAG,EAAE;AAAA,EACN,CAAC,IAAI,CAAC;AAAA,EACN,CAAC,IAAI,EAAE;AACT;AAEA,SAAS,YAAY,MAAY,GAAW,GAAW,eAAoD;AACzG,MAAI,IAAI,KAAK,IAAI,MAAM,IAAI,KAAK,IAAI,GAAI,QAAO;AAC/C,MAAI,KAAK,WAAW,EAAE,IAAI,GAAG,CAAC,MAAM,kBAAmB,QAAO;AAE9D,QAAM,OAAO,KAAK,UAAU,iBAAiB,GAAG,CAAC;AACjD,MAAI,KAAK,SAAS,EAAG,QAAO;AAE5B,QAAM,QAAQ,KAAK,UAAU,yBAAyB,GAAG,CAAC;AAC1D,MAAI,MAAM,SAAS,EAAG,QAAO;AAE7B,SAAO,KAAK,uBAAuB,GAAG,GAAG,aAAa,MAAM;AAC9D;AAEA,SAAS,2BAA2B,MAAoB;AA/ExD;AAgFE,QAAM,OAAM,2BAAsB,mBAAmB,GAAE,gBAAK,eAAL,mBAAiB,UAAjB,YAA0B,CAAC,MAAtE,YAA2E;AACvF,MAAI,QAAQ,EAAG,QAAO;AAEtB,QAAM,QAAQ,KAAK,KAAK,oBAAoB;AAAA,IAC1C,QAAQ,CAAC,cAAyB,UAAU,kBAAkB;AAAA,EAChE,CAAC,EAAE;AACH,QAAM,QAAQ,KAAK,KAAK,4BAA4B;AAAA,IAClD,QAAQ,CAAC,SAA2B,KAAK,kBAAkB;AAAA,EAC7D,CAAC,EAAE;AAEH,SAAO,QAAQ;AACjB;AAEA,SAAS,iCAAiC,MAAoB;AAC5D,QAAM,QAAQ,KAAK,KAAK,oBAAoB;AAAA,IAC1C,QAAQ,CAAC,cAAyB,0BAA0B,MAAM,SAAS;AAAA,EAC7E,CAAC,EAAE;AACH,QAAM,QAAQ,KAAK,KAAK,4BAA4B;AAAA,IAClD,QAAQ,CAAC,SAA2B;AAClC,UAAI,KAAK,kBAAkB,oBAAqB,QAAO;AACvD,YAAM,UAAU,KAAK,KAAK,YAAY;AACtC,aAAO,QAAQ,KAAK,CAAC,WAAW,KAAK,IAAI,WAAW,MAAM,KAAK,CAAC;AAAA,IAClE;AAAA,EACF,CAAC,EAAE;AACH,SAAO,QAAQ;AACjB;AAEA,SAAS,cAAc,MAAoB;AA3G3C;AA4GE,UAAO,2BAAsB,mBAAmB,GAAE,gBAAK,eAAL,mBAAiB,UAAjB,YAA0B,CAAC,MAAtE,YAA2E;AACpF;AAEA,SAAS,2BAA2B,MAAY,eAAmD;AACjG,QAAM,QAAQ,KAAK,KAAK,oBAAoB;AAAA,IAC1C,QAAQ,CAAC,cAAyB,UAAU,kBAAkB;AAAA,EAChE,CAAC,EAAE;AACH,QAAM,QAAQ,KAAK,KAAK,4BAA4B;AAAA,IAClD,QAAQ,CAAC,SAA2B,KAAK,kBAAkB;AAAA,EAC7D,CAAC,EAAE;AACH,SAAO,QAAQ;AACjB;AAEA,SAAS,2BAA2B,MAAY,eAAmD;AAzHnG;AA0HE,QAAM,OAAM,2BAAsB,aAAa,GAAE,gBAAK,eAAL,mBAAiB,UAAjB,YAA0B,CAAC,MAAhE,YAAqE;AACjF,MAAI,OAAO,EAAG,QAAO;AACrB,QAAM,OAAO,2BAA2B,MAAM,aAAa;AAC3D,SAAO,KAAK,IAAI,GAAG,MAAM,IAAI;AAC/B;AAEA,SAAS,gBAAgB,MAAY,GAAW,GAAoB;AAClE,MAAI,IAAI,KAAK,IAAI,MAAM,IAAI,KAAK,IAAI,GAAI,QAAO;AAC/C,MAAI,KAAK,WAAW,EAAE,IAAI,GAAG,CAAC,MAAM,kBAAmB,QAAO;AAC9D,MAAI,KAAK,UAAU,iBAAiB,GAAG,CAAC,EAAE,SAAS,EAAG,QAAO;AAC7D,MAAI,KAAK,UAAU,yBAAyB,GAAG,CAAC,EAAE,SAAS,EAAG,QAAO;AACrE,SAAO;AACT;AAEA,SAAS,oCAAoC,MAAY,QAA+B;AACtF,QAAM,YAAY,KAAK,IAAI,GAAG,gBAAgB,aAAa,yBAAyB;AACpF,MAAI,cAAc,EAAG,QAAO;AAE5B,QAAM,UAAU,KAAK,KAAK,YAAY;AACtC,aAAW,UAAU,SAAS;AAC5B,UAAM,WAAW,OAAO,IAAI,YAAY,oBAAoB,GAAG;AAAA,MAC7D,QAAQ,CAAC,cAAyB,UAAU,kBAAkB;AAAA,IAChE,CAAC,EAAE;AACH,UAAM,UAAU,OAAO,IAAI,YAAY,4BAA4B,GAAG;AAAA,MACpE,QAAQ,CAAC,SAA2B,KAAK,kBAAkB;AAAA,IAC7D,CAAC,EAAE;AAEH,QAAI,WAAW,WAAW,UAAW;AAErC,UAAM,aAAa,8BAA8B,MAAM,QAAQ,MAAM;AACrE,QAAI,WAAW,KAAK,CAAC,CAAC,GAAG,CAAC,MAAM,gBAAgB,MAAM,GAAG,CAAC,CAAC,GAAG;AAC5D,aAAO;AAAA,IACT;AAAA,EACF;AAEA,SAAO;AACT;AAEA,SAAS,2BAA2B,MAAoB;AACtD,QAAM,YAAY,KAAK,IAAI,GAAG,gBAAgB,aAAa,yBAAyB;AACpF,MAAI,cAAc,EAAG,QAAO;AAC5B,SAAO,KAAK,KAAK,YAAY,EAAE,SAAS;AAC1C;AAEA,SAAS,oBAAoB,MAAY,QAA4B;AACnE,QAAM,MAAM,cAAc,IAAI;AAC9B,MAAI,QAAQ,EAAG;AAEf,QAAM,eAAe,KAAK,IAAI,KAAK,2BAA2B,IAAI,CAAC;AACnE,QAAM,eAAe,iCAAiC,IAAI;AAC1D,QAAM,qBAAqB,4BAA4B,IAAI,KAAK,oCAAoC,MAAM,MAAM;AAChH,QAAM,qBAAqB,qBAAqB,eAAe;AAC/D,QAAM,UAAU,KAAK,IAAI,GAAG,MAAM,kBAAkB;AAEpD,MAAI,OAAO,2BAA2B,IAAI;AAC1C,MAAI,QAAQ,QAAS;AAErB,aAAW,CAAC,IAAI,EAAE,KAAK,wBAAwB;AAC7C,QAAI,QAAQ,QAAS;AACrB,QAAI,sBAAsB,IAAI,GAAG,EAAE,IAAI,EAAE,EAAE,EAAG;AAE9C,gBAAY,MAAM,OAAO,IAAI,IAAI,OAAO,IAAI,IAAI,mBAAmB;AACnE,WAAO,2BAA2B,IAAI;AAAA,EACxC;AACF;AAEA,SAAS,0BAA0B,MAAY,WAA+B;AAC5E,MAAI,UAAU,kBAAkB,oBAAqB,QAAO;AAC5D,QAAM,UAAU,KAAK,KAAK,YAAY;AACtC,SAAO,QAAQ,KAAK,CAAC,WAAW,UAAU,IAAI,WAAW,MAAM,KAAK,CAAC;AACvE;AAEA,SAAS,uBAAuB,MAAoB;AAClD,QAAMC,oBAAmB,KAAK,KAAK,oBAAoB;AAAA,IACrD,QAAQ,CAAC,cAAyB,0BAA0B,MAAM,SAAS;AAAA,EAC7E,CAAC;AAED,MAAIA,kBAAiB,WAAW,EAAG,QAAO;AAE1C,QAAM,SAASA,kBAAiB,IAAI,CAAC,cAAc;AACjD,UAAM,OAAO,UAAU,MAAM,gBAAgB,eAAe;AAC5D,UAAM,QAAQ,UAAU,MAAM,YAAY,eAAe;AACzD,QAAI,CAAC,MAAO,QAAO;AACnB,WAAO,OAAO;AAAA,EAChB,CAAC;AAED,SAAO,OAAO,OAAO,CAAC,KAAK,UAAU,MAAM,OAAO,CAAC,IAAI,OAAO;AAChE;AAEA,SAAS,4BAA4B,MAAqB;AAnN1D;AAoNE,QAAM,OAAM,gBAAK,eAAL,mBAAiB,UAAjB,YAA0B;AACtC,MAAI,MAAM,gBAAgB,aAAa,uBAAwB,QAAO;AAEtE,MAAI,gBAAgB,aAAa,qCAAqC;AACpE,QAAI,KAAK,kBAAkB,KAAK,wBAAyB,QAAO;AAAA,EAClE;AAEA,SAAO,uBAAuB,IAAI,KAAK,gBAAgB,aAAa;AACtE;AAEA,SAAS,8BAA8B,MAAY,QAAsB,QAAyC;AAChH,QAAM,UAAU,KAAK,WAAW;AAChC,QAAM,YAAqC,CAAC;AAE5C,WAAS,KAAK,IAAI,MAAM,GAAG,MAAM,GAAG;AAClC,aAAS,KAAK,IAAI,MAAM,GAAG,MAAM,GAAG;AAClC,YAAM,IAAI,OAAO,IAAI,IAAI;AACzB,YAAM,IAAI,OAAO,IAAI,IAAI;AACzB,UAAI,IAAI,KAAK,IAAI,MAAM,IAAI,KAAK,IAAI,GAAI;AAExC,YAAM,gBAAgB,KAAK,IAAI,KAAK,IAAI,EAAE,GAAG,KAAK,IAAI,EAAE,CAAC;AACzD,UAAI,gBAAgB,KAAK,gBAAgB,EAAG;AAC5C,UAAI,QAAQ,IAAI,GAAG,CAAC,MAAM,kBAAmB;AAC7C,UAAI,KAAK,cAAc,KAAK,WAAW,IAAI,WAAW,GAAG,CAAC,KAAK,EAAG;AAElE,gBAAU,KAAK,CAAC,GAAG,CAAC,CAAC;AAAA,IACvB;AAAA,EACF;AAEA,YAAU,KAAK,CAAC,GAAG,MAAM,OAAO,WAAW,EAAE,CAAC,GAAG,EAAE,CAAC,CAAC,IAAI,OAAO,WAAW,EAAE,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC;AACtF,SAAO;AACT;AAEA,SAAS,8BAA8B,MAAY,QAAsB,QAAyC;AAChH,QAAM,UAAU,KAAK,WAAW;AAChC,QAAM,YAAqC,CAAC;AAE5C,WAAS,KAAK,IAAI,MAAM,GAAG,MAAM,GAAG;AAClC,aAAS,KAAK,IAAI,MAAM,GAAG,MAAM,GAAG;AAClC,UAAI,OAAO,KAAK,OAAO,EAAG;AAE1B,YAAM,IAAI,OAAO,IAAI,IAAI;AACzB,YAAM,IAAI,OAAO,IAAI,IAAI;AACzB,UAAI,IAAI,KAAK,IAAI,MAAM,IAAI,KAAK,IAAI,GAAI;AACxC,UAAI,QAAQ,IAAI,GAAG,CAAC,MAAM,kBAAmB;AAE7C,gBAAU,KAAK,CAAC,GAAG,CAAC,CAAC;AAAA,IACvB;AAAA,EACF;AAEA,YAAU,KAAK,CAAC,GAAG,MAAM,OAAO,WAAW,EAAE,CAAC,GAAG,EAAE,CAAC,CAAC,IAAI,OAAO,WAAW,EAAE,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC;AACtF,SAAO;AACT;AAEA,SAAS,sBAAsB,MAAY,QAA4B;AACrE,QAAM,MAAM,cAAc,IAAI;AAC9B,MAAI,QAAQ,EAAG;AACf,MAAI,CAAC,4BAA4B,IAAI,EAAG;AAExC,QAAM,YAAY,KAAK,IAAI,GAAG,gBAAgB,aAAa,yBAAyB;AACpF,MAAI,cAAc,EAAG;AAErB,MAAI,OAAO,2BAA2B,IAAI;AAC1C,MAAI,QAAQ,IAAK;AAEjB,QAAM,UAAU,KAAK,KAAK,YAAY;AACtC,aAAW,UAAU,SAAS;AAC5B,QAAI,QAAQ,IAAK;AAEjB,UAAM,aAAa,8BAA8B,MAAM,QAAQ,MAAM;AACrE,eAAW,CAAC,GAAG,CAAC,KAAK,YAAY;AAC/B,UAAI,QAAQ,IAAK;AAEjB,YAAM,WAAW,OAAO,IAAI,YAAY,oBAAoB,GAAG;AAAA,QAC7D,QAAQ,CAAC,cAAyB,UAAU,kBAAkB;AAAA,MAChE,CAAC,EAAE;AACH,YAAM,UAAU,OAAO,IAAI,YAAY,4BAA4B,GAAG;AAAA,QACpE,QAAQ,CAAC,SAA2B,KAAK,kBAAkB;AAAA,MAC7D,CAAC,EAAE;AAEH,UAAI,WAAW,WAAW,UAAW;AAErC,kBAAY,MAAM,GAAG,GAAG,mBAAmB;AAC3C,aAAO,2BAA2B,IAAI;AAAA,IACxC;AAAA,EACF;AACF;AAEA,SAAS,qBAAqB,MAAY,QAA4B;AACpE,QAAM,aAAa,KAAK;AACxB,MAAI,YAAY;AACd,UAAM,OAAO,OAAO,WAAW,WAAW,KAAK,EAAE,cAAc,KAAK,CAAC;AACrE,eAAW,QAAQ,MAAM;AACvB,kBAAY,MAAM,KAAK,GAAG,KAAK,GAAG,cAAc;AAAA,IAClD;AAAA,EACF;AAEA,QAAM,UAAU,KAAK,KAAK,YAAY;AACtC,aAAW,UAAU,SAAS;AAC5B,UAAM,OAAO,OAAO,WAAW,OAAO,KAAK,EAAE,cAAc,KAAK,CAAC;AACjE,eAAW,QAAQ,MAAM;AACvB,kBAAY,MAAM,KAAK,GAAG,KAAK,GAAG,cAAc;AAAA,IAClD;AAAA,EACF;AACF;AAEA,SAAS,sBAAsB,MAAY,QAA4B;AACrE,QAAM,UAAU,KAAK,KAAK,YAAY;AACtC,aAAW,UAAU,SAAS;AAC5B,UAAM,eAAe,OAAO,IAAI,YAAY,iBAAiB,GAAG;AAAA,MAC9D,QAAQ,CAAC,cAAyB,UAAU,kBAAkB;AAAA,IAChE,CAAC,EAAE;AACH,UAAM,mBAAmB,OAAO,IAAI,YAAY,yBAAyB,GAAG;AAAA,MAC1E,QAAQ,CAAC,SAA2B,KAAK,kBAAkB;AAAA,IAC7D,CAAC,EAAE;AAEH,QAAI,eAAe,mBAAmB,EAAG;AAEzC,UAAM,aAAa,8BAA8B,MAAM,QAAQ,MAAM;AACrE,eAAW,CAAC,GAAG,CAAC,KAAK,YAAY;AAC/B,UAAI,YAAY,MAAM,GAAG,GAAG,mBAAmB,GAAG;AAChD;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACF;AAEA,SAAS,uBAAuB,MAAoB;AAClD,QAAM,UAAU,KAAK,KAAK,YAAY;AACtC,MAAI,UAAU;AAEd,aAAW,UAAU,SAAS;AAC5B,UAAM,eAAe,OAAO,IAAI,YAAY,iBAAiB,GAAG;AAAA,MAC9D,QAAQ,CAAC,cAAyB,UAAU,kBAAkB;AAAA,IAChE,CAAC,EAAE;AACH,UAAM,mBAAmB,OAAO,IAAI,YAAY,yBAAyB,GAAG;AAAA,MAC1E,QAAQ,CAAC,SAA2B,KAAK,kBAAkB;AAAA,IAC7D,CAAC,EAAE;AACH,QAAI,eAAe,qBAAqB,GAAG;AACzC,iBAAW;AAAA,IACb;AAAA,EACF;AAEA,SAAO;AACT;AAEA,SAAS,YAAY,MAAY,QAA4B;AAtW7D;AAuWE,QAAM,OAAM,2BAAsB,eAAe,GAAE,gBAAK,eAAL,mBAAiB,UAAjB,YAA0B,CAAC,MAAlE,YAAuE;AACnF,MAAI,QAAQ,EAAG;AAEf,QAAM,QAAQ,KAAK,KAAK,oBAAoB;AAAA,IAC1C,QAAQ,CAAC,cAAyB,UAAU,kBAAkB;AAAA,EAChE,CAAC,EAAE;AACH,QAAM,QAAQ,KAAK,KAAK,4BAA4B;AAAA,IAClD,QAAQ,CAAC,SAA2B,KAAK,kBAAkB;AAAA,EAC7D,CAAC,EAAE;AAEH,MAAI,QAAQ,SAAS,IAAK;AAE1B,cAAY,MAAM,OAAO,IAAI,GAAG,OAAO,GAAG,eAAe;AACzD,cAAY,MAAM,OAAO,IAAI,GAAG,OAAO,GAAG,eAAe;AACzD,cAAY,MAAM,OAAO,GAAG,OAAO,IAAI,GAAG,eAAe;AAC3D;AAEA,SAAS,mBAAmB,MAAY,QAA4B;AAClE,MAAI,2BAA2B,MAAM,iBAAiB,IAAI,GAAG;AAC3D,gBAAY,MAAM,OAAO,IAAI,GAAG,OAAO,IAAI,GAAG,iBAAiB;AAAA,EACjE;AAEA,MAAI,2BAA2B,MAAM,kBAAkB,IAAI,GAAG;AAC5D,gBAAY,MAAM,OAAO,IAAI,GAAG,OAAO,IAAI,GAAG,kBAAkB;AAAA,EAClE;AAEA,MAAI,2BAA2B,MAAM,iBAAiB,IAAI,GAAG;AAC3D,gBAAY,MAAM,OAAO,IAAI,GAAG,OAAO,IAAI,GAAG,iBAAiB;AAAA,EACjE;AAEA,MAAI,2BAA2B,MAAM,cAAc,IAAI,GAAG;AACxD,gBAAY,MAAM,OAAO,IAAI,GAAG,OAAO,IAAI,GAAG,cAAc;AAAA,EAC9D;AACF;AAEA,SAAS,gBAAgB,MAAY,QAA4B;AAC/D,MAAI,YAAY,2BAA2B,MAAM,aAAa;AAC9D,MAAI,aAAa,EAAG;AAEpB,QAAM,UAAmC;AAAA,IACvC,CAAC,GAAG,EAAE;AAAA,IACN,CAAC,GAAG,CAAC;AAAA,IACL,CAAC,GAAG,CAAC;AAAA,IACL,CAAC,GAAG,EAAE;AAAA,IACN,CAAC,GAAG,CAAC;AAAA,IACL,CAAC,GAAG,CAAC;AAAA,IACL,CAAC,GAAG,EAAE;AAAA,IACN,CAAC,GAAG,CAAC;AAAA,IACL,CAAC,GAAG,CAAC;AAAA,IACL,CAAC,GAAG,CAAC;AAAA,EACP;AAEA,aAAW,CAAC,IAAI,EAAE,KAAK,SAAS;AAC9B,QAAI,aAAa,EAAG;AACpB,QAAI,YAAY,MAAM,OAAO,IAAI,IAAI,OAAO,IAAI,IAAI,aAAa,GAAG;AAClE,mBAAa;AAAA,IACf;AAAA,EACF;AACF;AAEA,SAAS,8BAA8B,MAAY,QAA4B;AAC7E,MAAI,YAAY,2BAA2B,MAAM,cAAc;AAC/D,MAAI,aAAa,EAAG;AAEpB,MAAI,KAAK,YAAY;AACnB,UAAM,yBAAyB,KAAK,WAAW,IAAI,YAAY,oBAAoB,GAAG;AAAA,MACpF,QAAQ,CAAC,cAAyB,UAAU,kBAAkB;AAAA,IAChE,CAAC,EAAE;AACH,UAAM,sBAAsB,KAAK,WAAW,IAAI,YAAY,4BAA4B,GAAG;AAAA,MACzF,QAAQ,CAAC,SAA2B,KAAK,kBAAkB;AAAA,IAC7D,CAAC,EAAE;AAEH,QAAI,yBAAyB,wBAAwB,GAAG;AACtD,YAAM,OAAO,OAAO,WAAW,KAAK,WAAW,KAAK,EAAE,cAAc,KAAK,CAAC;AAC1E,YAAM,YAAY,KAAK,KAAK,SAAS,CAAC;AACtC,UAAI,WAAW;AACb,YAAI,YAAY,MAAM,UAAU,GAAG,UAAU,GAAG,cAAc,GAAG;AAC/D,uBAAa;AAAA,QACf;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEA,MAAI,aAAa,EAAG;AAEpB,QAAM,UAAU,KAAK,KAAK,YAAY;AACtC,aAAW,UAAU,SAAS;AAC5B,QAAI,aAAa,EAAG;AACpB,UAAM,WAAW,OAAO,IAAI,YAAY,oBAAoB,GAAG;AAAA,MAC7D,QAAQ,CAAC,cAAyB,UAAU,kBAAkB;AAAA,IAChE,CAAC,EAAE;AACH,UAAM,QAAQ,OAAO,IAAI,YAAY,4BAA4B,GAAG;AAAA,MAClE,QAAQ,CAAC,SAA2B,KAAK,kBAAkB;AAAA,IAC7D,CAAC,EAAE;AACH,QAAI,WAAW,QAAQ,EAAG;AAE1B,UAAM,OAAO,OAAO,WAAW,OAAO,KAAK,EAAE,cAAc,KAAK,CAAC;AACjE,UAAM,YAAY,KAAK,KAAK,SAAS,CAAC;AACtC,QAAI,CAAC,UAAW;AAEhB,QAAI,YAAY,MAAM,UAAU,GAAG,UAAU,GAAG,cAAc,GAAG;AAC/D,mBAAa;AAAA,IACf;AAAA,EACF;AACF;AAEA,SAAS,2BAA2B,MAAY,QAA4B;AAjd5E;AAkdE,MAAI,CAAC,gBAAgB,SAAS,QAAS;AACvC,QAAK,gBAAK,eAAL,mBAAiB,UAAjB,YAA0B,KAAK,gBAAgB,SAAS,OAAQ;AAErE,QAAM,UAAU,YAAY,IAAI;AAChC,MAAI,CAAC,QAAS;AAEd,QAAM,kBAAkB,QAAQ,IAAI,QAAQ,eAAe,EAAE,KAAK,CAAC,cAAc,UAAU,kBAAkB,mBAAmB;AAChI,QAAM,sBAAsB,QAAQ,IACjC,QAAQ,uBAAuB,EAC/B,KAAK,CAAC,SAAS,KAAK,kBAAkB,mBAAmB;AAE5D,MAAI,CAAC,mBAAmB,CAAC,qBAAqB;AAC5C,SAAK,uBAAuB,QAAQ,KAAK,mBAAmB;AAAA,EAC9D;AAEA,QAAM,eAAe,QAAQ,IAAI,YAAY,iBAAiB,GAAG;AAAA,IAC/D,QAAQ,CAAC,cAAyB,UAAU,kBAAkB;AAAA,EAChE,CAAC,EAAE;AACH,QAAM,mBAAmB,QAAQ,IAAI,YAAY,yBAAyB,GAAG;AAAA,IAC3E,QAAQ,CAAC,SAA2B,KAAK,kBAAkB;AAAA,EAC7D,CAAC,EAAE;AAEH,MAAI,eAAe,qBAAqB,GAAG;AACzC,UAAM,OAAO,OAAO,WAAW,QAAQ,KAAK,EAAE,cAAc,KAAK,CAAC;AAClE,UAAM,YAAY,KAAK,KAAK,SAAS,CAAC;AACtC,QAAI,WAAW;AACb,kBAAY,MAAM,UAAU,GAAG,UAAU,GAAG,mBAAmB;AAAA,IACjE;AAAA,EACF;AAEA,OAAI,kBAAO,aAAP,mBAAkB,KAAK,UAAvB,mBAA8B,aAAa,YAAY;AACzD,UAAM,OAAO,OAAO,WAAW,QAAQ,KAAK,EAAE,cAAc,KAAK,CAAC;AAClE,eAAW,QAAQ,MAAM;AACvB,kBAAY,MAAM,KAAK,GAAG,KAAK,GAAG,cAAc;AAAA,IAClD;AAAA,EACF;AACF;AAEA,SAAS,mBAAmB,MAAY,QAA4B;AAClE,WAAS,KAAK,IAAI,MAAM,GAAG,MAAM,GAAG;AAClC,aAAS,KAAK,IAAI,MAAM,GAAG,MAAM,GAAG;AAClC,YAAM,SAAS,KAAK,IAAI,EAAE,MAAM,KAAK,KAAK,IAAI,EAAE,MAAM;AACtD,UAAI,CAAC,OAAQ;AACb,kBAAY,MAAM,OAAO,IAAI,IAAI,OAAO,IAAI,IAAI,cAAc;AAAA,IAChE;AAAA,EACF;AACF;AAEO,SAAS,yBAA+B;AAlgB/C;AAmgBE,MAAI,KAAK,OAAO,gBAAgB,aAAa,gBAAgB,EAAG;AAEhE,aAAW,QAAQ,cAAc,GAAG;AAElC,UAAM,YAAW,YAAO,aAAP,mBAAkB,KAAK;AACxC,QAAI,CAAC,SAAU;AAEf,UAAM,SAAS,cAAc,IAAI;AACjC,QAAI,CAAC,OAAQ;AAEb,UAAM,WAAW,gBAAgB,aAAa;AAE9C,QAAI,gBAAgB,aAAa,8BAA8B;AAC7D,YAAM,WAAW,KAAK,KAAK,cAAc,EAAE,SAAS;AACpD,YAAM,eAAe,KAAK,KAAK,4BAA4B;AAAA,QACzD,QAAQ,CAAC,SAA2B,KAAK,kBAAkB;AAAA,MAC7D,CAAC,EAAE;AAEH,UAAI,CAAC,YAAY,iBAAiB,KAAK,KAAK,KAAK,uBAAuB,EAAE,SAAS,UAAU;AAC3F,oBAAY,MAAM,OAAO,GAAG,OAAO,GAAG,eAAe;AAAA,MACvD;AAAA,IACF;AAGA,UAAM,yBAAyB,KAAK,IAAI,GAAG,uBAAuB,IAAI,CAAC;AACvE,UAAM,yBAAyB,KAAK,IAAI,GAAG,WAAW,sBAAsB;AAE5E,0BAAsB,MAAM,MAAM;AAElC,UAAM,2BAA2B,KAAK,KAAK,uBAAuB,EAAE;AACpE,QAAI,4BAA4B,uBAAwB;AACxD,QAAI,4BAA4B,SAAU;AAE1C,0BAAsB,MAAM,MAAM;AAClC,QAAI,KAAK,KAAK,uBAAuB,EAAE,UAAU,SAAU;AAC3D,wBAAoB,MAAM,MAAM;AAChC,QAAI,KAAK,KAAK,uBAAuB,EAAE,UAAU,SAAU;AAC3D,uBAAmB,MAAM,MAAM;AAC/B,QAAI,KAAK,KAAK,uBAAuB,EAAE,UAAU,SAAU;AAC3D,oBAAgB,MAAM,MAAM;AAC5B,QAAI,KAAK,KAAK,uBAAuB,EAAE,UAAU,SAAU;AAC3D,kCAA8B,MAAM,MAAM;AAC1C,QAAI,KAAK,KAAK,uBAAuB,EAAE,UAAU,SAAU;AAC3D,+BAA2B,MAAM,MAAM;AAEvC,QAAI,SAAS,aAAa,YAAY;AACpC,UAAI,KAAK,KAAK,uBAAuB,EAAE,UAAU,SAAU;AAC3D,2BAAqB,MAAM,MAAM;AAAA,IACnC;AAEA,QAAI,SAAS,aAAa,aAAa;AACrC,UAAI,KAAK,KAAK,uBAAuB,EAAE,UAAU,SAAU;AAC3D,kBAAY,MAAM,MAAM;AAAA,IAC1B;AAEA,QAAI,SAAS,aAAa,YAAY;AACpC,UAAI,KAAK,KAAK,uBAAuB,EAAE,UAAU,SAAU;AAC3D,yBAAmB,MAAM,MAAM;AAAA,IACjC;AAAA,EACF;AACF;;;AC7jBA,SAAS,oBAAoB,OAAqC;AAChE,QAAM,WAAW,MAAM,KAAK,KAAK,mBAAmB;AACpD,MAAI,SAAS,WAAW,EAAG,QAAO;AAElC,QAAM,UAAU,SAAS,OAAO,CAAC,YAAY,QAAQ,mBAAmB,IAAI,IAAI,CAAC;AACjF,MAAI,QAAQ,SAAS,GAAG;AACtB,WAAO,MAAM,IAAI,mBAAmB,OAAO;AAAA,EAC7C;AAEA,QAAM,SAAS,SAAS,OAAO,CAAC,YAAY,QAAQ,mBAAmB,aAAa,IAAI,CAAC;AACzF,MAAI,OAAO,SAAS,GAAG;AACrB,WAAO,MAAM,IAAI,mBAAmB,MAAM;AAAA,EAC5C;AAEA,QAAM,YAAY,SAAS,OAAO,CAAC,YAAY,QAAQ,mBAAmB,MAAM,IAAI,CAAC;AACrF,MAAI,UAAU,SAAS,GAAG;AACxB,WAAO,MAAM,IAAI,mBAAmB,SAAS;AAAA,EAC/C;AAEA,QAAM,UAAU,SAAS,OAAO,CAAC,YAAY,QAAQ,mBAAmB,IAAI,IAAI,CAAC;AACjF,MAAI,QAAQ,SAAS,GAAG;AACtB,WAAO,MAAM,IAAI,mBAAmB,OAAO;AAAA,EAC7C;AAEA,SAAO,MAAM,IAAI,mBAAmB,QAAQ;AAC9C;AAEA,SAAS,YAAY,UAA+B;AA7BpD;AA8BE,QAAM,UAAS,YAAO,WAAP,mBAAgB;AAC/B,MAAI,CAAC,UAAU,OAAO,YAAY,KAAK,KAAM,QAAO;AACpD,SAAO,OAAO;AAChB;AAEO,SAAS,oBAA0B;AACxC,QAAM,SAAS,EAAE;AAAA,IACf,OAAO,OAAO,KAAK,UAAU;AAAA,IAC7B,CAAC,cAA2C,UAAU,kBAAkB,mBAAmB,UAAU;AAAA,EACvG;AAEA,aAAW,SAAS,QAAQ;AAC1B,UAAM,aAAa,YAAY,MAAM,KAAK,IAAI;AAC9C,UAAM,WAAW,eAAe;AAEhC,UAAM,gBAAgB,eAAe,UAAU,eAAe,aAAa,oBAAoB,KAAK,IAAI,MAAM,IAAI,mBAAmB,mBAAmB;AACxJ,QAAI,eAAe;AACjB,YAAM,OAAO,aAAa;AAC1B;AAAA,IACF;AAEA,UAAM,UAAU,MAAM,IAAI,mBAAmB,gBAAgB;AAAA,MAC3D,QAAQ,CAAC,UAAiB,MAAM,OAAO,MAAM;AAAA,IAC/C,CAAC;AAED,QAAI,SAAS;AACX,YAAM,KAAK,OAAO;AAClB;AAAA,IACF;AAEA,QAAI,SAAU;AAEd,UAAM,eAAe,MAAM,IAAI,mBAAmB,iBAAiB;AAAA,MACjE,QAAQ,CAAC,cAAyB;AAChC,YAAI,UAAU,kBAAkB,kBAAkB,UAAU,kBAAkB,mBAAmB;AAC/F,iBAAO,UAAU,OAAO,gBAAgB,QAAQ;AAAA,QAClD;AAEA,eAAO,UAAU,OAAO,UAAU,WAAW,UAAU,OAAO,gBAAgB,QAAQ;AAAA,MACxF;AAAA,IACF,CAAC;AAED,QAAI,cAAc;AAChB,YAAM,OAAO,YAAY;AAAA,IAC3B;AAAA,EACF;AACF;;;ACxEA,SAAS,QAAQ,MAA6B;AAC5C,SAAO,KAAK,KAAK,oBAAoB;AAAA,IACnC,QAAQ,CAAC,cAAyB,UAAU,kBAAkB;AAAA,EAChE,CAAC;AACH;AAEA,SAAS,gBAAgB,MAAY,OAAyC;AAC5E,QAAM,aAAa,KAAK;AACxB,MAAI,CAAC,WAAY,QAAO,CAAC;AACzB,SAAO,MAAM,OAAO,CAAC,SAAS,KAAK,IAAI,WAAW,UAAU,KAAK,CAAC;AACpE;AAEA,SAAS,YAAY,MAAY,OAAwB,YAA8C;AACrG,QAAM,UAAU,KAAK,KAAK,YAAY;AACtC,QAAM,gBAAgB,IAAI,IAAI,WAAW,IAAI,CAAC,SAAS,KAAK,EAAE,CAAC;AAC/D,SAAO,MAAM,OAAO,CAAC,SAAS,CAAC,cAAc,IAAI,KAAK,EAAE,KAAK,QAAQ,KAAK,CAAC,WAAW,KAAK,IAAI,WAAW,MAAM,KAAK,CAAC,CAAC;AACzH;AAEA,SAAS,UAAU,MAAY,OAAwB,YAA6B,QAA0C;AAC5H,QAAM,WAAW,oBAAI,IAAI,CAAC,GAAG,WAAW,IAAI,CAAC,SAAS,KAAK,EAAE,GAAG,GAAG,OAAO,IAAI,CAAC,SAAS,KAAK,EAAE,CAAC,CAAC;AACjG,QAAM,aAAa,cAAc,IAAI;AAErC,QAAM,YAAY,MAAM,OAAO,CAAC,SAAS,CAAC,SAAS,IAAI,KAAK,EAAE,CAAC;AAC/D,MAAI,CAAC,WAAY,QAAO;AAExB,SAAO,UAAU,KAAK,CAAC,GAAG,MAAM,EAAE,IAAI,WAAW,UAAU,IAAI,EAAE,IAAI,WAAW,UAAU,CAAC;AAC7F;AAEA,SAAS,QAAQ,MAA8B;AAC7C,MAAI,KAAK,WAAW,EAAG,QAAO;AAC9B,SAAO,KAAK,MAAM,gBAAgB,eAAe,KAAK,gBAAgB,MAAM;AAC9E;AAEA,SAAS,aAAa,WAA4B,UAAoD;AACpG,QAAM,SAAS,UAAU;AAAA,IACvB,CAAC,SACC,KAAK,OAAO,YAAY,KAAK,MAAM,gBAAgB,eAAe,KAAK,gBAAgB,MAAM;AAAA,EACjG;AACA,MAAI,OAAO,WAAW,EAAG,QAAO;AAChC,SAAO;AAAA,IACL,CAAC,GAAG,MAAM,EAAE,MAAM,gBAAgB,eAAe,IAAI,EAAE,MAAM,gBAAgB,eAAe;AAAA,EAC9F;AACA,SAAO,OAAO,CAAC;AACjB;AAEA,SAAS,aAAa,MAAkB;AAjDxC;AAkDE,QAAM,OAAM,gBAAK,eAAL,mBAAiB,UAAjB,YAA0B;AACtC,MAAI,MAAM,gBAAgB,MAAM,OAAQ;AAExC,QAAM,QAAQ,QAAQ,IAAI;AAC1B,MAAI,MAAM,SAAS,EAAG;AAEtB,QAAM,aAAa,gBAAgB,MAAM,KAAK;AAC9C,QAAM,SAAS,YAAY,MAAM,OAAO,UAAU;AAClD,QAAM,OAAO,UAAU,MAAM,OAAO,YAAY,MAAM;AAEtD,QAAM,wBAAwB,WAAW;AAAA,IACvC,CAAC,SAAS,KAAK,MAAM,gBAAgB,eAAe,IAAI,gBAAgB,MAAM;AAAA,EAChF;AAEA,aAAW,UAAU,QAAQ;AAC3B,QAAI,CAAC,QAAQ,MAAM,EAAG;AAEtB,UAAM,aAAY,kBAAa,uBAAuB,OAAO,EAAE,MAA7C,YAAkD,aAAa,MAAM,OAAO,EAAE;AAChG,QAAI,CAAC,UAAW;AAEhB,WAAO,eAAe,SAAS;AAAA,EACjC;AAEA,aAAW,UAAU,MAAM;AACzB,QAAI,CAAC,QAAQ,MAAM,EAAG;AAEtB,UAAM,WAAW,aAAa,uBAAuB,OAAO,EAAE;AAC9D,QAAI,CAAC,SAAU;AAEf,WAAO,eAAe,QAAQ;AAAA,EAChC;AACF;AAEO,SAAS,iBAAuB;AACrC,MAAI,CAAC,gBAAgB,MAAM,QAAS;AACpC,aAAW,QAAQ,cAAc,GAAG;AAClC,iBAAa,IAAI;AAAA,EACnB;AACF;;;AChFO,IAAM,cAA+C;AAAA,EAC1D,WAAW,EAAE,KAAK,CAAC,MAAM,OAAO,IAAI,GAAG,SAAS,CAAC,MAAM,OAAO,IAAI,GAAG,aAAa,EAAE;AAAA,EACpF,QAAQ,EAAE,KAAK,CAAC,OAAO,OAAO,IAAI,GAAG,SAAS,CAAC,OAAO,OAAO,IAAI,GAAG,aAAa,EAAE;AAAA,EACnF,OAAO,EAAE,KAAK,CAAC,MAAM,MAAM,MAAM,OAAO,IAAI,GAAG,SAAS,CAAC,MAAM,IAAI,GAAG,aAAa,EAAE;AAAA,EACrF,cAAc,EAAE,KAAK,CAAC,MAAM,MAAM,OAAO,IAAI,GAAG,SAAS,CAAC,MAAM,MAAM,IAAI,GAAG,aAAa,EAAE;AAAA,EAC5F,eAAe,EAAE,KAAK,CAAC,OAAO,OAAO,IAAI,GAAG,SAAS,CAAC,OAAO,OAAO,IAAI,GAAG,aAAa,EAAE;AAAA,EAC1F,UAAU,EAAE,KAAK,CAAC,MAAM,OAAO,IAAI,GAAG,SAAS,CAAC,MAAM,OAAO,IAAI,GAAG,aAAa,EAAE;AAAA,EACnF,SAAS,EAAE,KAAK,CAAC,MAAM,OAAO,IAAI,GAAG,SAAS,CAAC,MAAM,OAAO,IAAI,GAAG,aAAa,EAAE;AAAA,EAClF,UAAU,EAAE,KAAK,CAAC,MAAM,OAAO,IAAI,GAAG,SAAS,CAAC,MAAM,OAAO,IAAI,GAAG,aAAa,EAAE;AAAA,EACnF,QAAQ,EAAE,KAAK,CAAC,MAAM,OAAO,IAAI,GAAG,SAAS,CAAC,MAAM,OAAO,IAAI,GAAG,aAAa,EAAE;AAAA,EACjF,OAAO,EAAE,KAAK,CAAC,IAAI,GAAG,SAAS,CAAC,IAAI,GAAG,aAAa,EAAE;AAAA,EACtD,UAAU,EAAE,KAAK,CAAC,OAAO,IAAI,GAAG,SAAS,CAAC,OAAO,IAAI,GAAG,aAAa,EAAE;AAAA,EACvE,SAAS,EAAE,KAAK,CAAC,OAAO,IAAI,GAAG,SAAS,CAAC,OAAO,IAAI,GAAG,aAAa,EAAE;AAAA,EACtE,cAAc,EAAE,KAAK,CAAC,MAAM,OAAO,IAAI,GAAG,SAAS,CAAC,MAAM,OAAO,IAAI,GAAG,aAAa,EAAE;AAAA,EACvF,SAAS,EAAE,KAAK,CAAC,OAAO,MAAM,QAAQ,IAAI,GAAG,SAAS,CAAC,OAAO,MAAM,QAAQ,IAAI,GAAG,aAAa,EAAE;AACpG;;;ACrBA,IAAM,YAA8C;AAAA,EAClD,MAAM;AAAA,EACN,MAAM;AAAA,EACN,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,eAAe;AAAA,EACf,OAAO;AAAA,EACP,MAAM;AAAA,EACN,OAAO;AACT;AAEO,SAAS,SAAS,MAAkC;AACzD,SAAO,KAAK,OAAO,CAAC,KAAK,SAAS,MAAM,UAAU,IAAI,GAAG,CAAC;AAC5D;AAaO,SAAS,gBAAsB;AACpC,aAAW,QAAQ,OAAO,QAAQ;AAChC,QAAI,CAAC,KAAK,OAAO,IAAI,GAAG;AACtB,aAAO,OAAO,OAAO,IAAI;AAAA,IAC3B;AAAA,EACF;AACF;;;ACzBA,SAASC,mBAA8B;AACrC,QAAM,SAAS,CAAC;AAChB,aAAW,QAAQ,YAAY;AAC7B,WAAO,IAAI,IAAI;AAAA,EACjB;AACA,SAAO;AACT;AAEA,SAAS,WAAW,QAA6B;AAC/C,QAAM,SAASA,iBAAgB;AAC/B,aAAW,SAAS,QAAQ;AAC1B,WAAO,MAAM,OAAO,IAAI,KAAK;AAAA,EAC/B;AACA,SAAO;AACT;AAEA,SAAS,mBACP,MACA,SACA,SACQ;AA7BV;AA8BE,SAAO,QAAQ,IAAI,MAAK,aAAQ,IAAI,MAAZ,YAAiB;AAC3C;AAEA,SAAS,oBAAoB,SAAqB,SAAoD;AACpG,MAAI,QAAQ;AACZ,aAAW,QAAQ,YAAY;AAC7B,aAAS,mBAAmB,MAAM,SAAS,OAAO;AAAA,EACpD;AACA,SAAO;AACT;AAEA,SAAS,UAAU,MAAgB,cAAiD;AAClF,QAAM,YAAY,YAAY,IAAI;AAClC,QAAM,UAAU,SAAS,UAAU,GAAG;AACtC,MAAI,eAAe,QAAS,QAAO;AAEnC,QAAM,OAA2B,CAAC,GAAG,UAAU,GAAG;AAClD,QAAM,cAAc,SAAS,UAAU,OAAO;AAC9C,MAAI,cAAc;AAClB,MAAI,WAAW;AAEf,SACE,WAAW,UAAU,eACrB,KAAK,SAAS,UAAU,QAAQ,UAAU,MAC1C,cAAc,eAAe,cAC7B;AACA,SAAK,KAAK,GAAG,UAAU,OAAO;AAC9B,mBAAe;AACf,gBAAY;AAAA,EACd;AAEA,SAAO;AACT;AAEA,SAAS,gBACP,OACA,mBACA,mBACiB;AApEnB;AAqEE,QAAM,YAAW,YAAO,aAAP,mBAAkB,MAAM,KAAK;AAC9C,MAAI,CAAC,SAAU,QAAO;AAEtB,MAAI,oBAAoB,mBAAmB,iBAAiB,MAAM,GAAG;AACnE,WAAO;AAAA,EACT;AAEA,QAAM,oBAAoB,yBAAyB,MAAM,KAAK,IAAI;AAClE,MAAI,oBAAoB,GAAG;AACzB,UAAM,eAAe,mBAAmB,WAAW,mBAAmB,iBAAiB;AACvF,QAAI,eAAe,mBAAmB;AACpC,aAAO;AAAA,IACT;AAAA,EACF;AAEA,aAAW,QAAQ,YAAY;AAC7B,UAAM,WAAU,cAAS,aAAa,IAAI,MAA1B,YAA+B;AAC/C,QAAI,WAAW,EAAG;AAElB,UAAM,eAAe,mBAAmB,MAAM,mBAAmB,iBAAiB;AAClF,QAAI,eAAe,SAAS;AAC1B,aAAO;AAAA,IACT;AAAA,EACF;AAEA,SAAO;AACT;AAEA,SAAS,uBACP,OACA,MACA,mBACA,mBACS;AACT,MAAI,oBAAoB,mBAAmB,iBAAiB,MAAM,EAAG,QAAO;AAE5E,MAAI,SAAS,aAAa;AACxB,QAAI,mBAAmB,aAAa,mBAAmB,iBAAiB,MAAM,EAAG,QAAO;AAAA,EAC1F;AAEA,MAAI,SAAS,UAAU;AACrB,QAAI,mBAAmB,UAAU,mBAAmB,iBAAiB,MAAM,EAAG,QAAO;AAAA,EACvF;AAEA,MAAI,SAAS,aAAa,yBAAyB,MAAM,KAAK,IAAI,IAAI,GAAG;AACvE,WAAO;AAAA,EACT;AAEA,SAAO;AACT;AAEA,SAAS,qBAAqB,OAAuB,MAAwB;AAC3E,MAAI,SAAS,QAAS,QAAO;AAE7B,SAAO,KAAK,IAAI,MAAM,KAAK,yBAAyB,GAAG;AACzD;AAEA,SAAS,wBACP,SACA,YACA,iBACoB;AAlItB;AAmIE,MAAI,QAAQ,WAAW,EAAG,QAAO;AAEjC,MAAI;AACJ,MAAI,YAAY,OAAO;AAEvB,aAAW,UAAU,SAAS;AAC5B,UAAM,eAAe,WAAW;AAAA,MAC9B,CAAC,UAAU,MAAM,OAAO,SAAS,kBAAkB,MAAM,OAAO,eAAe;AAAA,IACjF,EAAE;AACF,UAAM,QAAQ,iBAAgB,qBAAgB,MAAM,MAAtB,YAA2B;AAEzD,QAAI,QAAQ,WAAW;AACrB,kBAAY;AACZ,mBAAa;AAAA,IACf;AAAA,EACF;AAEA,SAAO;AACT;AAEA,SAAS,yBAAyB,UAA0B;AAvJ5D;AAwJE,QAAM,UAAS,YAAO,WAAP,mBAAgB;AAC/B,MAAI,CAAC,UAAU,OAAO,YAAY,KAAK,KAAM,QAAO;AACpD,SAAO,yBAAyB,QAAQ;AAC1C;AAEA,SAAS,yBACP,UACAC,YACA,qBACQ;AAjKV;AAkKE,QAAM,WAAWA,WAAU,OAAO,CAAC,UAAU;AAC3C,QAAI,MAAM,OAAO,SAAS,UAAW,QAAO;AAC5C,QAAI,MAAM,OAAO,aAAa,SAAU,QAAO;AAC/C,WAAO,MAAM,OAAO,eAAe;AAAA,EACrC,CAAC,EAAE;AAEH,SAAO,aAAY,yBAAoB,QAAQ,MAA5B,YAAiC;AACtD;AAEA,SAAS,wBACP,UACAA,YACA,qBACoB;AACpB,QAAM,iBAAiB,cAAc,EAAE,OAAO,CAAC,SAAS,KAAK,SAAS,QAAQ;AAC9E,MAAI;AACJ,MAAI,YAAY,OAAO;AAEvB,aAAW,QAAQ,gBAAgB;AACjC,UAAM,OAAO,yBAAyB,KAAK,IAAI;AAC/C,QAAI,QAAQ,EAAG;AAEf,UAAM,WAAW,yBAAyB,KAAK,MAAMA,YAAW,mBAAmB;AACnF,UAAM,UAAU,OAAO;AACvB,QAAI,WAAW,EAAG;AAElB,UAAM,WAAW,KAAK,IAAI,sBAAsB,UAAU,KAAK,IAAI;AACnE,UAAM,QAAQ,UAAU,MAAM,WAAW;AACzC,QAAI,QAAQ,WAAW;AACrB,kBAAY;AACZ,mBAAa,KAAK;AAAA,IACpB;AAAA,EACF;AAEA,SAAO;AACT;AAEA,SAAS,oBAAoB,UAAgC;AAC3D,QAAM,OAAO,KAAK,MAAM,QAAQ;AAChC,MAAI,CAAC,KAAM,QAAO,CAAC;AACnB,SAAO,KAAK,KAAK,YAAY,EAAE,IAAI,CAAC,WAAW,OAAO,EAAE;AAC1D;AAEA,SAAS,0BACP,YACA,MACA,UACA,YACQ;AACR,SAAO,WAAW,OAAO,CAAC,UAAU;AAClC,QAAI,MAAM,OAAO,SAAS,KAAM,QAAO;AACvC,QAAI,MAAM,OAAO,aAAa,SAAU,QAAO;AAC/C,QAAI,cAAc,CAAC,MAAM,OAAO,WAAY,QAAO;AACnD,WAAO;AAAA,EACT,CAAC,EAAE;AACL;AAEA,SAAS,oBACP,UACA,MACA,kBACA,YACA,YACwB;AACxB,QAAM,YAAY,oBAAoB,QAAQ;AAC9C,MAAI,UAAU,WAAW,KAAK,oBAAoB,EAAG,QAAO;AAE5D,MAAI;AACJ,MAAI,YAAY,OAAO;AACvB,aAAW,YAAY,WAAW;AAChC,UAAM,QAAQ,0BAA0B,YAAY,MAAM,UAAU,UAAU;AAC9E,QAAI,QAAQ,WAAW;AACrB,kBAAY;AACZ,qBAAe;AAAA,IACjB;AAAA,EACF;AAEA,MAAI,aAAa,iBAAkB,QAAO;AAC1C,SAAO;AACT;AAEA,SAAS,gBAAgB,OAAuB,MAAwB;AACtE,QAAM,OAAO,GAAG,IAAI,IAAI,MAAM,IAAI,IAAI,KAAK,IAAI;AAC/C,MAAI,CAAC,KAAK,OAAO,IAAI,EAAG,QAAO;AAE/B,WAAS,UAAU,GAAG,WAAW,IAAI,WAAW,GAAG;AACjD,UAAM,YAAY,GAAG,IAAI,IAAI,OAAO;AACpC,QAAI,CAAC,KAAK,OAAO,SAAS,EAAG,QAAO;AAAA,EACtC;AAEA,SAAO,GAAG,IAAI,IAAI,KAAK,OAAO,EAAE,SAAS,EAAE,EAAE,MAAM,GAAG,CAAC,CAAC;AAC1D;AAEO,SAAS,kBAAwB;AA/PxC;AAgQE,QAAM,SAAS,OAAO,OAAO,KAAK,MAAM;AACxC,QAAMA,aAAY,aAAa;AAC/B,QAAM,iBAA6C,CAAC;AACpD,QAAM,0BAA6E,CAAC;AACpF,QAAM,mCAA2E,CAAC;AAClF,QAAM,+BAAuD,CAAC;AAE9D,aAAW,SAAS,QAAQ;AAC1B,QAAI,MAAM,SAAU;AACpB,UAAM,YAAW,YAAO,aAAP,mBAAkB,MAAM,KAAK;AAC9C,QAAI,CAAC,SAAU;AAEf,UAAM,WAAW,MAAM,KAAK;AAC5B,QAAI,CAAC,eAAe,QAAQ,GAAG;AAC7B,qBAAe,QAAQ,IAAI,WAAW,oBAAoB,QAAQ,CAAC;AAAA,IACrE;AACA,QAAI,CAAC,wBAAwB,QAAQ,GAAG;AACtC,8BAAwB,QAAQ,IAAI,CAAC;AAAA,IACvC;AACA,QAAI,CAAC,iCAAiC,QAAQ,GAAG;AAC/C,uCAAiC,QAAQ,IAAI,CAAC;AAAA,IAChD;AAEA,UAAM,aAAa,oBAAoB,QAAQ;AAC/C,UAAM,OAAO,gBAAgB,OAAO,eAAe,QAAQ,GAAG,wBAAwB,QAAQ,CAAC;AAC/F,QAAI,CAAC,KAAM;AAEX,UAAM,sBACJ,SAAS,iBACL;AAAA,MACE,SAAS;AAAA,MACT;AAAA,MACA,iCAAiC,QAAQ;AAAA,IAC3C,IACA;AACN,QAAI,SAAS,kBAAkB,CAAC,oBAAqB;AAErD,UAAM,iBAAiB,yBAAyB,QAAQ;AACxD,UAAM,0BACJ,SAAS,aAAa,mBAAmB,IACrC,wBAAwB,UAAUA,YAAW,4BAA4B,IACzE;AAEN,UAAM,aAAa,oDAAuB;AAE1C,UAAM,eAAe,KAAK,IAAI,GAAG,KAAK,IAAI,MAAM,gBAAgB,MAAM,kBAAkB,CAAC;AACzF,UAAM,eAAe,IAAI;AACzB,UAAM,iBAAiB,KAAK,KAAK,MAAM,KAAK,0BAA0B,YAAY;AAClF,UAAM,gBAAgB,qBAAqB,OAAO,IAAI;AACtD,UAAM,mBAAmB;AAAA,MACvB;AAAA,MACA;AAAA,MACA,eAAe,QAAQ;AAAA,MACvB,wBAAwB,QAAQ;AAAA,IAClC;AACA,QAAI,CAAC,oBAAoB,MAAM,KAAK,kBAAkB,KAAK,IAAI,gBAAgB,aAAa,EAAG;AAE/F,UAAM,OAAO,UAAU,MAAM,MAAM,KAAK,eAAe;AACvD,QAAI,CAAC,KAAM;AAEX,UAAM,WACJ,SAAS,UACL;AAAA,MACE;AAAA,MACA;AAAA,MACA,KAAK,IAAI,GAAG,gBAAgB,QAAQ,eAAe;AAAA,MACnD;AAAA,MACA;AAAA,IACF,IACA,SAAS,WACP;AAAA,MACE;AAAA,MACA;AAAA,MACA,KAAK,IAAI,GAAG,gBAAgB,QAAQ,yBAAyB;AAAA,MAC7D;AAAA,MACA;AAAA,IACF,IACA;AACR,UAAM,aAAa,aAAa;AAEhC,UAAM,OAAO,gBAAgB,OAAO,IAAI;AACxC,UAAM,SAAS,MAAM,WAAW,MAAM,MAAM;AAAA,MAC1C,QAAQ;AAAA,QACN;AAAA,QACA,UAAU;AAAA,QACV,SAAS;AAAA,QACT;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF,CAAC;AAED,QAAI,WAAW,IAAI;AACjB,8BAAwB,QAAQ,EAAE,IAAI,MAAK,6BAAwB,QAAQ,EAAE,IAAI,MAAtC,YAA2C,KAAK;AAC3F,UAAI,SAAS,kBAAkB,YAAY;AACzC,yCAAiC,QAAQ,EAAE,UAAU,MAClD,sCAAiC,QAAQ,EAAE,UAAU,MAArD,YAA0D,KAAK;AAAA,MACpE;AACA,UAAI,SAAS,aAAa,YAAY;AACpC,qCAA6B,UAAU,MAAK,kCAA6B,UAAU,MAAvC,YAA4C,KAAK;AAAA,MAC/F;AACA;AAAA,IACF;AAEA,QAAI,WAAW,YAAY,WAAW,yBAAyB,WAAW,iBAAiB;AACzF,cAAQ,IAAI,WAAW,MAAM,IAAI,iBAAiB,IAAI,SAAS,MAAM,EAAE;AAAA,IACzE;AAAA,EACF;AACF;;;ACzWA,SAAS,gBAAgB,UAA0B;AAHnD;AAIE,QAAM,UAAS,YAAO,WAAP,mBAAgB;AAC/B,MAAI,CAAC,UAAU,OAAO,YAAY,KAAK,KAAM,QAAO;AACpD,SAAO,GAAG,OAAO,KAAK,IAAI,OAAO,KAAK;AACxC;AAEO,SAAS,sBAA4B;AAT5C;AAUE,MAAI,CAAC,gBAAgB,UAAU,QAAS;AACxC,MAAI,KAAK,OAAO,gBAAgB,UAAU,aAAa,EAAG;AAE1D,aAAW,QAAQ,cAAc,GAAG;AAClC,UAAM,SAAQ,kBAAO,cAAP,mBAAmB,KAAK,UAAxB,YAAiC;AAC/C,UAAM,SAAS,gBAAgB,KAAK,IAAI;AACxC,UAAM,YAAW,YAAO,aAAP,mBAAkB,KAAK;AACxC,UAAM,SAAQ,0CAAU,iBAAiB,OAA3B,YAAiC;AAC/C,UAAM,aAAY,0CAAU,qBAAqB,KAAK,SAApC,YAA4C;AAC9D,UAAM,WAAW,6BAA6B,KAAK,MAAM,SAAS;AAElE,YAAQ;AAAA,MACN,eAAe,KAAK,IAAI,WAAW,KAAK,WAAW,MAAM,aAAa,QAAQ,UAAU,KAAK,cAAc,SAAS;AAAA,IACtH;AAAA,EACF;AACF;;;ACtBO,SAAS,kBAAkB,OAAuB;AACvD,QAAM,aAAa,MAAM,KAAK;AAC9B,MAAI,CAAC,WAAY,QAAO;AACxB,MAAI,kBAAkB,MAAM,IAAI,EAAG,QAAO;AAE1C,QAAM,SAAS,MAAM,kBAAkB,UAAU;AACjD,MAAI,WAAW,kBAAkB;AAC/B,iBAAa,OAAO,UAAU;AAC9B,WAAO;AAAA,EACT;AAEA,SAAO,WAAW;AACpB;AAEO,SAAS,iBAAiB,OAAuB;AACtD,QAAM,OAAO,MAAM,IAAI,kBAAkB,uBAAuB;AAChE,MAAI,CAAC,KAAM,QAAO;AAElB,QAAM,SAAS,MAAM,MAAM,IAAI;AAC/B,MAAI,WAAW,kBAAkB;AAC/B,iBAAa,OAAO,IAAI;AACxB,WAAO;AAAA,EACT;AAEA,SAAO,WAAW;AACpB;AAEO,SAAS,qBAAqB,OAAuB;AAC1D,QAAM,SAAS,MAAM,IAAI,kBAAkB,iBAAiB;AAAA,IAC1D,QAAQ,CAAC,cAAyB;AAChC,UAAI,UAAU,QAAQ,UAAU,QAAS,QAAO;AAChD,aAAO,UAAU,kBAAkB,kBAAkB,UAAU,kBAAkB;AAAA,IACnF;AAAA,EACF,CAAC;AAED,MAAI,CAAC,OAAQ,QAAO;AAEpB,QAAM,SAAS,MAAM,OAAO,MAAM;AAClC,MAAI,WAAW,kBAAkB;AAC/B,iBAAa,OAAO,MAAM;AAC1B,WAAO;AAAA,EACT;AAEA,SAAO,WAAW;AACpB;AAEO,SAAS,gBAAgB,OAAc,aAA8B;AAC1E,QAAM,SAAS,MAAM,IAAI,kBAAkB,iBAAiB;AAAA,IAC1D,QAAQ,CAAC,cAAyB;AAChC,UAAI,UAAU,kBAAkB,kBAAkB,UAAU,kBAAkB,kBAAmB,QAAO;AACxG,aAAO,UAAU,OAAO;AAAA,IAC1B;AAAA,EACF,CAAC;AAED,MAAI,CAAC,OAAQ,QAAO;AAEpB,QAAM,SAAS,MAAM,OAAO,MAAM;AAClC,MAAI,WAAW,kBAAkB;AAC/B,iBAAa,OAAO,MAAM;AAC1B,WAAO;AAAA,EACT;AAEA,SAAO,WAAW;AACpB;;;AC9DA,SAAS,eAAe,OAAuB;AAC7C,SAAO,MAAM,OAAO,SAAS,eAAe,MAAM,OAAO,SAAS;AACpE;AAEA,SAAS,WAAW,UAAkB,UAAsB,kBAAkC;AAC5F,MAAI,OAAO;AAEX,aAAW,SAAS,oBAAoB,QAAQ,GAAG;AACjD,QAAI,MAAM,SAAS,iBAAkB;AACrC,QAAI,CAAC,eAAe,KAAK,EAAG;AAC5B,QAAI,MAAM,OAAO,aAAa,UAAU;AACtC,cAAQ;AAAA,IACV;AAAA,EACF;AAEA,SAAO;AACT;AAEA,SAAS,aAAa,OAA6B;AAtBnD;AAuBE,QAAM,UAAU,MAAM,KAAK,KAAK,mBAAmB;AACnD,MAAI,QAAQ,WAAW,EAAG,QAAO;AAEjC,MAAI,CAAC,eAAe,KAAK,GAAG;AAC1B,QAAI,MAAM,OAAO,UAAU;AACzB,YAAMC,YAAW,KAAK,cAAc,MAAM,OAAO,QAAsB;AACvE,UAAIA,UAAU,QAAOA;AAAA,IACvB;AAEA,UAAM,WAAU,WAAM,IAAI,kBAAkB,OAAO,MAAnC,YAAwC,QAAQ,CAAC;AACjE,UAAM,OAAO,WAAW,QAAQ;AAChC,WAAO;AAAA,EACT;AAEA,QAAM,WACJ,MAAM,OAAO,aAAa,SAAY,KAAK,cAAc,MAAM,OAAO,QAAsB,IAAI;AAClG,MAAI,YAAY,MAAM,OAAO,YAAY;AACvC,WAAO;AAAA,EACT;AAEA,QAAM,kBAAkB,KAAK,OAAO,OAAO;AAC3C,MAAI,YAAY,CAAC,iBAAiB;AAChC,WAAO;AAAA,EACT;AAEA,MAAI,OAAsB;AAC1B,MAAI,WAAW,OAAO;AACtB,MAAI,YAAY,OAAO;AAEvB,aAAW,UAAU,SAAS;AAC5B,UAAM,OAAO,WAAW,MAAM,OAAO,UAAU,OAAO,IAAI,MAAM,IAAI;AACpE,UAAM,QAAQ,MAAM,IAAI,WAAW,MAAM;AAEzC,QAAI,OAAO,YAAa,SAAS,YAAY,QAAQ,WAAY;AAC/D,aAAO;AACP,iBAAW;AACX,kBAAY;AAAA,IACd;AAAA,EACF;AAEA,QAAM,WAAW,sBAAQ,QAAQ,CAAC;AAClC,QAAM,OAAO,WAAW,SAAS;AACjC,SAAO;AACT;AAEO,SAAS,cAAc,OAAuB;AACnD,QAAM,SAAS,aAAa,KAAK;AACjC,MAAI,CAAC,OAAQ,QAAO;AAEpB,QAAM,SAAS,MAAM,QAAQ,MAAM;AACnC,MAAI,WAAW,kBAAkB;AAC/B,iBAAa,OAAO,MAAM;AAC1B,WAAO;AAAA,EACT;AAEA,SAAO,WAAW;AACpB;AAEO,SAAS,qBAAqB,OAAuB;AAC1D,QAAM,SAAS,MAAM,IAAI,kBAAkB,iBAAiB;AAAA,IAC1D,QAAQ,CAAC,cAAyB;AAChC,UACE,UAAU,kBAAkB,qBAC5B,UAAU,kBAAkB,uBAC5B,UAAU,kBAAkB,qBAC5B;AACA,eAAQ,UAAyE,MAAM,gBAAgB,eAAe,IAAI;AAAA,MAC5H;AACA,aAAO;AAAA,IACT;AAAA,EACF,CAAC;AAED,MAAI,CAAC,OAAQ,QAAO;AAEpB,QAAM,SAAS,MAAM,SAAS,QAAQ,eAAe;AACrD,MAAI,WAAW,kBAAkB;AAC/B,iBAAa,OAAO,MAAM;AAC1B,WAAO;AAAA,EACT;AAEA,SAAO,WAAW;AACpB;AAEO,SAAS,oBAAoB,OAAuB;AACzD,QAAM,WAAW,MAAM,IAAI,kBAAkB,wBAAwB;AAAA,IACnE,QAAQ,CAAC,YACP,QAAQ,iBAAiB,mBAAmB,QAAQ,SAAS,gBAAgB,OAAO;AAAA,EACxF,CAAC;AAED,MAAI,CAAC,SAAU,QAAO;AAEtB,QAAM,SAAS,MAAM,OAAO,QAAQ;AACpC,MAAI,WAAW,kBAAkB;AAC/B,iBAAa,OAAO,QAAQ;AAC5B,WAAO;AAAA,EACT;AAEA,SAAO,WAAW;AACpB;AAEO,SAAS,0BAA0B,OAAuB;AAC/D,QAAM,SAAS,MAAM,IAAI,kBAAkB,iBAAiB;AAAA,IAC1D,QAAQ,CAAC,cAAyB;AAChC,UACE,UAAU,kBAAkB,mBAC5B,UAAU,kBAAkB,uBAC5B,UAAU,kBAAkB,iBAC5B;AACA,eAAQ,UAAmE,MAAM,gBAAgB,eAAe,IAAI;AAAA,MACtH;AACA,aAAO;AAAA,IACT;AAAA,EACF,CAAC;AAED,MAAI,CAAC,OAAQ,QAAO;AAEpB,QAAM,SAAS,MAAM,SAAS,QAAQ,eAAe;AACrD,MAAI,WAAW,kBAAkB;AAC/B,iBAAa,OAAO,MAAM;AAC1B,WAAO;AAAA,EACT;AAEA,SAAO,WAAW;AACpB;;;AC9IO,SAAS,mBAAmB,OAAc,OAA4B,iBAAuB;AAClG,QAAM,eAAe,SAAS,QAAQ,MAAM,MAAM,gBAAgB,IAAI,MAAM,MAAM,gBAAgB,IAAI;AACtG,MAAI,MAAM,OAAO,WAAW,iBAAiB,GAAG;AAC9C,UAAM,OAAO,UAAU;AAAA,EACzB;AAEA,MAAI,CAAC,MAAM,OAAO,WAAW,MAAM,MAAM,gBAAgB,MAAM,GAAG;AAChE,UAAM,OAAO,UAAU;AAAA,EACzB;AACF;AAEO,SAAS,cAAc,OAAuB;AACnD,SAAO,qBAAqB,KAAK,KAAK,oBAAoB,KAAK,KAAK,cAAc,KAAK;AACzF;;;ACdO,SAAS,WAAW,OAAoB;AAC7C,qBAAmB,KAAK;AAExB,MAAI,CAAC,MAAM,OAAO,SAAS;AACzB,kBAAc,KAAK;AACnB;AAAA,EACF;AAEA,MAAI,iBAAiB,KAAK,EAAG;AAC7B,oBAAkB,KAAK;AACzB;;;ACRA,SAAS,gBAAgB,OAAuB;AAC9C,QAAM,YAAY,MAAM,IAAI,kBAAkB,4BAA4B;AAAA,IACxE,QAAQ,CAAC,SAA2B,KAAK,kBAAkB;AAAA,EAC7D,CAAC;AAED,MAAI,CAAC,UAAW,QAAO;AAEvB,QAAM,SAAS,MAAM,MAAM,SAAS;AACpC,MAAI,WAAW,kBAAkB;AAC/B,iBAAa,OAAO,SAAS;AAC7B,WAAO;AAAA,EACT;AAEA,SAAO,WAAW;AACpB;AAEO,SAAS,gBAAgB,OAAoB;AAClD,QAAM,aAAa,MAAM,OAAO;AAChC,MAAI,CAAC,WAAY;AAEjB,MAAI,MAAM,KAAK,SAAS,YAAY;AAClC,qBAAiB,OAAO,UAAU;AAClC;AAAA,EACF;AAEA,qBAAmB,KAAK;AAExB,MAAI,CAAC,MAAM,OAAO,SAAS;AACzB,kBAAc,KAAK;AACnB;AAAA,EACF;AAEA,MAAI,gBAAgB,KAAK,EAAG;AAC5B,MAAI,iBAAiB,KAAK,EAAG;AAC7B,MAAI,0BAA0B,KAAK,EAAG;AACtC,oBAAkB,KAAK;AACzB;;;ACtCO,SAAS,sBAAsB,OAAc,UAA2B;AAC7E,MAAI,MAAM,KAAK,SAAS,UAAU;AAChC,qBAAiB,OAAO,QAAQ;AAChC,WAAO;AAAA,EACT;AAEA,QAAM,aAAa,MAAM,KAAK;AAC9B,MAAI,CAAC,WAAY,QAAO;AAExB,QAAM,SAAS,MAAM,kBAAkB,UAAU;AACjD,MAAI,WAAW,kBAAkB;AAC/B,iBAAa,OAAO,UAAU;AAC9B,WAAO;AAAA,EACT;AAEA,SAAO,WAAW;AACpB;AAEO,SAAS,oBAAoB,OAAc,UAA2B;AAC3E,MAAI,MAAM,KAAK,SAAS,UAAU;AAChC,qBAAiB,OAAO,QAAQ;AAChC,WAAO;AAAA,EACT;AAEA,QAAM,aAAa,MAAM,KAAK;AAC9B,MAAI,CAAC,WAAY,QAAO;AAExB,QAAM,SAAS,MAAM,gBAAgB,UAAU;AAC/C,MAAI,WAAW,kBAAkB;AAC/B,iBAAa,OAAO,UAAU;AAC9B,WAAO;AAAA,EACT;AAEA,SAAO,WAAW;AACpB;AAEO,SAAS,aAAa,OAAc,UAA2B;AAvCtE;AAwCE,QAAM,aAAa,KAAK,MAAM,QAAQ;AACtC,QAAM,qBAAqB,SAAQ,8CAAY,eAAZ,mBAAwB,EAAE;AAE7D,MAAI,oBAAoB;AACtB,QAAI,CAAC,gBAAgB,OAAO,eAAgB,QAAO;AACnD,QAAI,CAAC,gBAAgB,OAAO,+BAA+B,CAAC,gBAAgB,MAAM,OAAO,UAAU,QAAQ,GAAG;AAC5G,aAAO;AAAA,IACT;AAAA,EACF,WAAW,CAAC,gBAAgB,MAAM,OAAO,UAAU,QAAQ,GAAG;AAC5D,WAAO;AAAA,EACT;AAEA,MAAI,MAAM,KAAK,SAAS,UAAU;AAChC,qBAAiB,OAAO,QAAQ;AAChC,WAAO;AAAA,EACT;AAEA,QAAM,UAAU,MAAM,IAAI,kBAAkB,mBAAmB;AAC/D,MAAI,SAAS;AACX,UAAMC,UAAS,MAAM,OAAO,OAAO;AACnC,QAAIA,YAAW,kBAAkB;AAC/B,mBAAa,OAAO,OAAO;AAC3B,aAAO;AAAA,IACT;AAEA,WAAOA,YAAW;AAAA,EACpB;AAEA,QAAM,mBAAmB,MAAM,IAAI,kBAAkB,yBAAyB;AAAA,IAC5E,QAAQ,CAAC,cAAyB,UAAU,kBAAkB;AAAA,EAChE,CAAC;AAED,MAAI,CAAC,iBAAkB,QAAO;AAE9B,QAAM,SAAS,MAAM,OAAO,gBAAgB;AAC5C,MAAI,WAAW,kBAAkB;AAC/B,iBAAa,OAAO,gBAAgB;AACpC,WAAO;AAAA,EACT;AAEA,SAAO,WAAW;AACpB;;;AC9EO,SAAS,WAAW,OAAoB;AAH/C;AAIE,QAAM,WAAU,wBAAO,aAAP,mBAAkB,MAAM,OAAO,cAA/B,mBAA0C,qBAA1C,YAA8D,CAAC;AAC/E,MAAI,QAAQ,WAAW,EAAG;AAE1B,QAAM,aAAa,QAAQ,CAAC;AAC5B,MAAI,oBAAoB,OAAO,UAAU,GAAG;AAC1C,QAAI,MAAM,KAAK,SAAS,gBAAc,WAAM,KAAK,eAAX,mBAAuB,KAAI;AAC/D,8BAAwB,MAAM,OAAO,UAAU,UAAU;AAAA,IAC3D;AAAA,EACF;AACF;;;ACTO,SAAS,aAAa,OAAoB;AAC/C,qBAAmB,KAAK;AAExB,MAAI,CAAC,MAAM,OAAO,SAAS;AACzB,kBAAc,KAAK;AACnB;AAAA,EACF;AAEA,MAAI,0BAA0B,KAAK,EAAG;AACtC,oBAAkB,KAAK;AACzB;;;ACTA,SAAS,qBAAqB,KAAmB,QAAuB,OAAwB;AAC9F,MAAI,CAAC,OAAQ,QAAO;AACpB,SAAO,IAAI,WAAW,MAAM,KAAK;AACnC;AAEA,SAAS,gBAAgB,MAAY,KAAmB,QAAQ,GAAY;AAC1E,QAAM,UAAU,KAAK,KAAK,YAAY;AACtC,SAAO,QAAQ,KAAK,CAAC,WAAW,IAAI,WAAW,MAAM,KAAK,KAAK;AACjE;AAEA,SAAS,6BAA6B,OAAc,gBAAwC;AAC1F,QAAM,SAAS,MAAM,IAAI,kBAAkB,oBAAoB;AAAA,IAC7D,QAAQ,CAAC,cAAyB;AAChC,UAAI,UAAU,kBAAkB,oBAAqB,QAAO;AAC5D,YAAM,yBAAyB,iBAC3B,qBAAqB,UAAU,KAAK,gBAAgB,CAAC,IACrD,gBAAgB,MAAM,MAAM,UAAU,KAAK,CAAC;AAChD,UAAI,CAAC,uBAAwB,QAAO;AACpC,YAAM,YAAY;AAClB,aAAO,UAAU,MAAM,gBAAgB,eAAe,IAAI;AAAA,IAC5D;AAAA,EACF,CAAC;AAED,MAAI,CAAC,OAAQ,QAAO;AAEpB,QAAM,SAAS,MAAM,SAAS,QAAQ,eAAe;AACrD,MAAI,WAAW,kBAAkB;AAC/B,iBAAa,OAAO,MAAM;AAC1B,WAAO;AAAA,EACT;AAEA,SAAO,WAAW;AACpB;AAEA,SAAS,6BAA6B,OAAc,gBAAwC;AAC1F,QAAM,SAAS,MAAM,IAAI,kBAAkB,iBAAiB;AAAA,IAC1D,QAAQ,CAAC,cAAyB;AAChC,UAAI,UAAU,kBAAkB,oBAAqB,QAAO;AAC5D,YAAM,yBAAyB,iBAC3B,qBAAqB,UAAU,KAAK,gBAAgB,CAAC,IACrD,gBAAgB,MAAM,MAAM,UAAU,KAAK,CAAC;AAChD,UAAI,CAAC,uBAAwB,QAAO;AACpC,YAAM,YAAY;AAClB,aAAO,UAAU,MAAM,gBAAgB,eAAe,KAAK,gBAAgB,OAAO;AAAA,IACpF;AAAA,EACF,CAAC;AAED,MAAI,CAAC,OAAQ,QAAO;AAEpB,QAAM,SAAS,MAAM,SAAS,QAAQ,eAAe;AACrD,MAAI,WAAW,kBAAkB;AAC/B,iBAAa,OAAO,MAAM;AAC1B,WAAO;AAAA,EACT;AAEA,SAAO,WAAW;AACpB;AAEA,SAAS,sBAAsB,OAAuB;AA/DtD;AAgEE,QAAM,WAAW,KAAK,MAAM,MAAM,OAAO,QAAQ;AACjD,QAAM,UAAS,0CAAU,KAAK,gBAAgB,OAA/B,mBAAmC;AAElD,QAAM,SAAS,MAAM,IAAI,kBAAkB,iBAAiB;AAAA,IAC1D,QAAQ,CAAC,cAAyB;AAChC,UAAI,UAAU,kBAAkB,mBAAmB,UAAU,kBAAkB,iBAAiB;AAC9F,eAAQ,UAA8C,MAAM,gBAAgB,eAAe,IAAI;AAAA,MACjG;AAEA,UAAI,UAAU,kBAAkB,oBAAqB,QAAO;AAC5D,UAAI,UAAU,UAAU,IAAI,WAAW,MAAM,IAAI,gBAAgB,UAAU,2BAA4B,QAAO;AAC9G,aAAQ,UAAiC,MAAM,gBAAgB,eAAe,IAAI;AAAA,IACpF;AAAA,EACF,CAAC;AAED,MAAI,CAAC,OAAQ,QAAO;AAEpB,QAAM,SAAS,MAAM,SAAS,QAAQ,eAAe;AACrD,MAAI,WAAW,kBAAkB;AAC/B,iBAAa,OAAO,MAAM;AAC1B,WAAO;AAAA,EACT;AAEA,SAAO,WAAW;AACpB;AAEO,SAAS,UAAU,OAAoB;AAC5C,qBAAmB,KAAK;AACxB,QAAM,iBACJ,MAAM,OAAO,cAAc,MAAM,OAAO,WACpC,KAAK,cAAc,MAAM,OAAO,QAAsB,IACtD;AACN,QAAM,cAAc,QAAQ,cAAc;AAE1C,MAAI,CAAC,MAAM,OAAO,SAAS;AACzB,QAAI,6BAA6B,OAAO,cAAc,EAAG;AACzD,QAAI,6BAA6B,OAAO,cAAc,EAAG;AAEzD,QAAI,CAAC,aAAa;AAChB,UAAI,qBAAqB,KAAK,EAAG;AACjC,0BAAoB,KAAK;AAAA,IAC3B;AAEA;AAAA,EACF;AAEA,MAAI,sBAAsB,KAAK,EAAG;AAClC,4BAA0B,KAAK;AACjC;;;AC7GA,SAAS,iBAAiB,OAAoC;AAC5D,QAAM,SAAS,MAAM,OAAO,WAAW,KAAK,cAAc,MAAM,OAAO,QAAQ,IAAI;AACnF,MAAI,CAAC,OAAQ,QAAO,CAAC;AAErB,SAAO,OAAO,IAAI,YAAY,oBAAoB,GAAG;AAAA,IACnD,QAAQ,CAAC,cACP,UAAU,kBAAkB,uBAC3B,UAAiC,MAAM,gBAAgB,eAAe,IAAI;AAAA,EAC/E,CAAC;AACH;AAEA,SAAS,gBAAgB,OAAyC;AAdlE;AAeE,QAAM,SAAS,MAAM,OAAO,WAAW,KAAK,cAAc,MAAM,OAAO,QAAQ,IAAI;AACnF,MAAI,CAAC,OAAQ,QAAO;AAEpB,QAAM,aAAa,OAAO,IAAI,YAAY,iBAAiB,GAAG;AAAA,IAC5D,QAAQ,CAAC,cAAyB,UAAU,kBAAkB;AAAA,EAChE,CAAC;AAED,UAAO,gBAAW,CAAC,MAAZ,YAAiB;AAC1B;AAEO,SAAS,SAAS,OAAoB;AAC3C,MAAI,MAAM,MAAM,gBAAgB,eAAe,IAAI,GAAG;AACpD,UAAM,YAAY,MAAM,IAAI,mBAAmB,iBAAiB,KAAK,CAAC;AACtE,QAAI,WAAW;AACb,YAAM,SAAS,MAAM,SAAS,WAAW,eAAe;AACxD,UAAI,WAAW,kBAAkB;AAC/B,qBAAa,OAAO,SAAS;AAAA,MAC/B;AACA;AAAA,IACF;AAAA,EACF;AAEA,QAAM,YAAY,gBAAgB,KAAK;AACvC,MAAI,aAAa,MAAM,MAAM,gBAAgB,eAAe,IAAI,GAAG;AACjE,UAAM,WAAW,MAAM,SAAS,WAAW,eAAe;AAC1D,QAAI,aAAa,kBAAkB;AACjC,mBAAa,OAAO,SAAS;AAAA,IAC/B;AACA;AAAA,EACF;AAEA,MAAI,aAAa,MAAM,IAAI,WAAW,SAAS,IAAI,GAAG;AACpD,iBAAa,OAAO,WAAW,CAAC;AAChC;AAAA,EACF;AAEA,gBAAc,KAAK;AACrB;;;ACjDO,SAAS,iBAAiB,OAAoB;AACnD,qBAAmB,OAAO,KAAK;AAE/B,MAAI,CAAC,MAAM,OAAO,SAAS;AACzB,QAAI,8BAA8B,KAAK,EAAG;AAC1C,0BAAsB,KAAK;AAC3B;AAAA,EACF;AAEA,0BAAwB,KAAK;AAC/B;;;ACVO,SAAS,gBAAgB,OAAoB;AAClD,QAAM,UAAU,YAAY,MAAM,IAAI;AACtC,MAAI,CAAC,WAAW,QAAQ,iBAAiB,EAAG;AAE5C,QAAM,YAAY,qBAAqB,MAAM,IAAI;AACjD,MAAI,aAAa,MAAM,IAAI,WAAW,SAAS,IAAI,GAAG;AACpD,iBAAa,OAAO,WAAW,CAAC;AAChC;AAAA,EACF;AAEA,MAAI,MAAM,MAAM,gBAAgB,MAAM,GAAG;AACvC,QAAI,WAAW;AACb,YAAM,WAAY,OAAO,KAAK,MAAM,KAAK,EAAyB;AAAA,QAChE,CAAC,UAAU,UAAU,mBAAmB,MAAM,MAAM,gBAAgB,KAAK,IAAI;AAAA,MAC/E;AACA,UAAI,CAAC,SAAU;AAEf,YAAM,SAAS,MAAM,SAAS,WAAW,QAAQ;AACjD,UAAI,WAAW,kBAAkB;AAC/B,qBAAa,OAAO,SAAS;AAAA,MAC/B;AACA;AAAA,IACF;AAEA,4BAAwB,KAAK;AAC7B;AAAA,EACF;AAEA,iBAAe,KAAK;AACtB;;;AC7BO,SAAS,YAAY,OAAoB;AAC9C,qBAAmB,KAAK;AAExB,MAAI,CAAC,MAAM,OAAO,SAAS;AACzB,kBAAc,KAAK;AACnB;AAAA,EACF;AAEA,MAAI,qBAAqB,KAAK,EAAG;AACjC,oBAAkB,KAAK;AACzB;;;ACXA,SAAS,iBAAiB,OAAc,SAA2B;AACjE,QAAM,QAAQ,MAAM,OAAO;AAC3B,MAAI,SAAS,QAAQ,SAAS,KAAK,GAAG;AACpC,WAAO;AAAA,EACT;AAEA,QAAM,OAAO,MAAM,KAAK,MAAM,EAAE,EAAE,OAAO,CAAC,KAAK,OAAO,MAAM,GAAG,WAAW,CAAC,GAAG,CAAC;AAC/E,QAAM,SAAS,QAAQ,OAAO,QAAQ,MAAM;AAC5C,QAAM,OAAO,aAAa;AAC1B,SAAO;AACT;AAEO,SAAS,YAAY,OAAoB;AAdhD;AAeE,QAAM,WAAU,wBAAO,aAAP,mBAAkB,MAAM,OAAO,cAA/B,mBAA0C,uBAA1C,YAAgE,CAAC;AACjF,MAAI,QAAQ,WAAW,EAAG;AAE1B,QAAM,aAAa,iBAAiB,OAAO,OAAO;AAClD,wBAAsB,OAAO,UAAU;AACzC;;;AClBA,SAASC,kBAAiB,OAAc,SAA2B;AACjE,QAAM,QAAQ,MAAM,OAAO;AAC3B,MAAI,SAAS,QAAQ,SAAS,KAAK,GAAG;AACpC,WAAO;AAAA,EACT;AAEA,QAAM,OAAO,MAAM,KAAK,MAAM,EAAE,EAAE,OAAO,CAAC,KAAK,OAAO,MAAM,GAAG,WAAW,CAAC,GAAG,CAAC;AAC/E,QAAM,SAAS,QAAQ,OAAO,QAAQ,MAAM;AAC5C,QAAM,OAAO,aAAa;AAC1B,SAAO;AACT;AAEO,SAAS,SAAS,OAAoB;AAd7C;AAeE,QAAM,WAAU,wBAAO,aAAP,mBAAkB,MAAM,OAAO,cAA/B,mBAA0C,qBAA1C,YAA8D,CAAC;AAC/E,MAAI,QAAQ,WAAW,EAAG;AAE1B,QAAM,aAAaA,kBAAiB,OAAO,OAAO;AAClD,MAAI,MAAM,KAAK,SAAS,YAAY;AAClC,qBAAiB,OAAO,UAAU;AAClC;AAAA,EACF;AAEA,QAAM,OAAO,IAAI,IAAI,EAAE,WAAW,EAAE,CAAC;AACvC;;;ACvBA,SAAS,gBAAgB,UAA2B;AAFpD;AAGE,QAAM,UAAS,YAAO,WAAP,mBAAgB;AAC/B,SAAO,QAAQ,UAAU,OAAO,aAAa,KAAK,QAAQ,OAAO,UAAU,MAAM;AACnF;AAEA,SAAS,qBAAqB,UAA2B;AAPzD;AAQE,QAAM,OAAO,KAAK,MAAM,QAAQ;AAChC,MAAI,CAAC,KAAM,QAAO;AAClB,MAAI,KAAK,KAAK,mBAAmB,EAAE,SAAS,EAAG,QAAO;AAEtD,QAAI,UAAK,eAAL,mBAAiB,OAAM,gBAAgB,QAAQ,GAAG;AACpD,WAAO;AAAA,EACT;AAEA,SAAO;AACT;AAEA,SAASC,kBAAiB,OAAc,SAA2B;AACjE,QAAM,QAAQ,MAAM,OAAO;AAC3B,MAAI,SAAS,QAAQ,SAAS,KAAK,GAAG;AACpC,WAAO;AAAA,EACT;AAEA,QAAM,OAAO,MAAM,KAAK,MAAM,EAAE,EAAE,OAAO,CAAC,KAAK,OAAO,MAAM,GAAG,WAAW,CAAC,GAAG,CAAC;AAC/E,QAAM,SAAS,QAAQ,OAAO,QAAQ,MAAM;AAC5C,QAAM,OAAO,aAAa;AAC1B,SAAO;AACT;AAEO,SAAS,WAAW,OAAoB;AA/B/C;AAgCE,MAAI,MAAM,OAAO,YAAY;AAC3B,UAAM,SAAS,MAAM,OAAO;AAC5B,UAAM,gBAAgB,qBAAqB,MAAM;AACjD,QAAI,eAAe;AACjB,UAAI,aAAa,OAAO,MAAM,EAAG;AAAA,IACnC,OAAO;AACL,aAAO,MAAM,OAAO;AAAA,IACtB;AAAA,EACF;AAEA,QAAM,WAAU,wBAAO,aAAP,mBAAkB,MAAM,OAAO,cAA/B,mBAA0C,sBAA1C,YAA+D,CAAC;AAChF,MAAI,QAAQ,WAAW,EAAG;AAE1B,QAAM,aAAaA,kBAAiB,OAAO,OAAO;AAClD,eAAa,OAAO,UAAU;AAChC;;;AC5CO,SAAS,YAAY,OAAoB;AAC9C,qBAAmB,KAAK;AAExB,MAAI,CAAC,MAAM,OAAO,SAAS;AACzB,kBAAc,KAAK;AACnB;AAAA,EACF;AAEA,oBAAkB,KAAK;AACzB;;;ACRO,SAAS,UAAU,OAAoB;AAJ9C;AAKE,qBAAmB,KAAK;AAExB,MAAI,CAAC,MAAM,OAAO,SAAS;AACzB,kBAAc,KAAK;AACnB;AAAA,EACF;AAEA,QAAM,OAAM,iBAAM,KAAK,eAAX,mBAAuB,UAAvB,YAAgC;AAC5C,MAAI,gBAAgB,OAAO,kBAAkB,GAAG,CAAC,EAAG;AACpD,oBAAkB,KAAK;AACzB;;;ACAO,SAAS,QAAQ,OAAoB;AAC1C,UAAQ,MAAM,OAAO,MAAM;AAAA,IACzB,KAAK;AACH,mBAAa,KAAK;AAClB;AAAA,IACF,KAAK;AACH,gBAAU,KAAK;AACf;AAAA,IACF,KAAK;AACH,eAAS,KAAK;AACd;AAAA,IACF,KAAK;AACH,sBAAgB,KAAK;AACrB;AAAA,IACF,KAAK;AACH,uBAAiB,KAAK;AACtB;AAAA,IACF,KAAK;AACH,kBAAY,KAAK;AACjB;AAAA,IACF,KAAK;AACH,iBAAW,KAAK;AAChB;AAAA,IACF,KAAK;AACH,sBAAgB,KAAK;AACrB;AAAA,IACF,KAAK;AACH,kBAAY,KAAK;AACjB;AAAA,IACF,KAAK;AACH,gBAAU,KAAK;AACf;AAAA,IACF,KAAK;AACH,eAAS,KAAK;AACd;AAAA,IACF,KAAK;AACH,kBAAY,KAAK;AACjB;AAAA,IACF,KAAK;AACH,iBAAW,KAAK;AAChB;AAAA,IACF,KAAK;AACH,iBAAW,KAAK;AAChB;AAAA,EACJ;AACF;;;AvCjDO,IAAM,OAAO,MAAY;AAC9B,gBAAc;AAEd,mBAAiB;AACjB,mBAAiB;AACjB,kBAAgB;AAChB,yBAAuB;AACvB,iBAAe;AACf,oBAAkB;AAClB,sBAAoB;AAEpB,aAAW,SAAS,aAAa,GAAG;AAClC,YAAQ,KAAK;AAAA,EACf;AACF;",
  "names": ["_a", "threatLevel", "unique", "sourceExtensions", "emptyRoleCounts", "allCreeps", "existing", "result", "stableTargetRoom", "stableTargetRoom"]
}
