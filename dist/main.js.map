{
  "version": 3,
  "sources": ["../src/main.ts", "../src/config/roles.ts", "../src/colony/intel.ts", "../src/colony/spawnPlanner.ts", "../src/config/colonyStages.ts", "../src/colony/stageManager.ts", "../src/colony/strategyManager.ts", "../src/managers/colonyManager.ts", "../src/managers/constructionManager.ts", "../src/managers/defenseManager.ts", "../src/config/bodyPlans.ts", "../src/utils.ts", "../src/managers/spawnManager.ts", "../src/tasks/movement.ts", "../src/tasks/work.ts", "../src/tasks/energy.ts", "../src/roles/common.ts", "../src/roles/builder.ts", "../src/tasks/combat.ts", "../src/roles/claimer.ts", "../src/roles/harvester.ts", "../src/roles/hauler.ts", "../src/roles/miner.ts", "../src/roles/repairer.ts", "../src/roles/reserver.ts", "../src/roles/scout.ts", "../src/roles/soldier.ts", "../src/roles/upgrader.ts", "../src/roles/waller.ts", "../src/roles/index.ts"],
  "sourcesContent": ["import { runColonyManager } from \"./managers/colonyManager\";\nimport { runConstructionManager } from \"./managers/constructionManager\";\nimport { runDefenseManager } from \"./managers/defenseManager\";\nimport { runSpawnManager } from \"./managers/spawnManager\";\nimport { runRole } from \"./roles\";\nimport { cleanupMemory } from \"./utils\";\n\nexport const loop = (): void => {\n  cleanupMemory();\n\n  runColonyManager();\n  runSpawnManager();\n  runConstructionManager();\n  runDefenseManager();\n\n  for (const creep of Object.values(Game.creeps)) {\n    runRole(creep);\n  }\n};\r\n", "export const ROLE_ORDER = [\n  \"harvester\",\n  \"hauler\",\n  \"miner\",\n  \"upgrader\",\n  \"builder\",\n  \"repairer\",\n  \"waller\",\n  \"scout\",\n  \"reserver\",\n  \"claimer\",\n  \"soldier\"\n] as const;\n\nexport type RoleName = (typeof ROLE_ORDER)[number];\n\nexport const CORE_ROLES: RoleName[] = [\"harvester\", \"hauler\", \"upgrader\", \"builder\"];\n\nexport const COMBAT_ROLES: RoleName[] = [\"soldier\"];\r\n", "import { ROLE_ORDER, type RoleName } from \"../config/roles\";\nimport type { RoomSnapshot } from \"./types\";\n\nfunction emptyRoleCounts(): Record<RoleName, number> {\n  const counts = {} as Record<RoleName, number>;\n  for (const role of ROLE_ORDER) {\n    counts[role] = 0;\n  }\n  return counts;\n}\n\nexport function collectRoomSnapshot(room: Room): RoomSnapshot {\n  const creepsByRole = emptyRoleCounts();\n  for (const creep of Object.values(Game.creeps)) {\n    if (creep.memory.homeRoom !== room.name) continue;\n    creepsByRole[creep.memory.role] += 1;\n  }\n\n  const structures = room.find(FIND_STRUCTURES);\n  const structuresByType: Partial<Record<StructureConstant, number>> = {};\n  for (const structure of structures) {\n    structuresByType[structure.structureType] = (structuresByType[structure.structureType] ?? 0) + 1;\n  }\n\n  const storageEnergy = room.storage?.store.getUsedCapacity(RESOURCE_ENERGY) ?? 0;\n  const controller = room.controller;\n\n  return {\n    roomName: room.name,\n    rcl: controller?.level ?? 0,\n    energyAvailable: room.energyAvailable,\n    energyCapacityAvailable: room.energyCapacityAvailable,\n    sourceCount: room.find(FIND_SOURCES).length,\n    constructionSiteCount: room.find(FIND_CONSTRUCTION_SITES).length,\n    hostileCount: room.find(FIND_HOSTILE_CREEPS).length,\n    storageEnergy,\n    structuresByType,\n    creepsByRole\n  };\n}\r\n", "import type { CapabilityFlags, ColonyStage } from \"../config/colonyStages\";\nimport { ROLE_ORDER, type RoleName } from \"../config/roles\";\nimport type { RoomSnapshot } from \"./types\";\n\nfunction baseDesired(): Record<RoleName, number> {\n  const desired = {} as Record<RoleName, number>;\n  for (const role of ROLE_ORDER) {\n    desired[role] = 0;\n  }\n  return desired;\n}\n\nexport function deriveDesiredRoles(\n  snapshot: RoomSnapshot,\n  stage: ColonyStage,\n  capabilities: CapabilityFlags\n): Record<RoleName, number> {\n  const desired = baseDesired();\n\n  // Always keep a minimum survival workforce so a room can recover from wipes.\n  desired.harvester = Math.max(2, snapshot.sourceCount);\n  desired.hauler = 1;\n  desired.upgrader = 1;\n  desired.builder = snapshot.constructionSiteCount > 0 ? 2 : 1;\n\n  if (stage !== \"bootstrap\") {\n    desired.miner = snapshot.sourceCount;\n    desired.hauler = Math.max(desired.hauler, snapshot.sourceCount);\n    desired.upgrader = stage === \"early\" ? 2 : 3;\n    desired.builder = snapshot.constructionSiteCount > 5 ? 3 : desired.builder;\n    desired.repairer = 1;\n  }\n\n  if (capabilities.allowWalls) {\n    desired.waller = 1;\n  }\n\n  if (capabilities.allowRemoteMining) {\n    desired.scout = 1;\n    desired.reserver = 1;\n  }\n\n  if (capabilities.allowExpansion) {\n    desired.claimer = 1;\n  }\n\n  if (capabilities.allowOffense) {\n    desired.soldier = Math.max(2, Math.ceil(snapshot.hostileCount / 2));\n  }\n\n  return desired;\n}\r\n", "export type ColonyStage = \"bootstrap\" | \"early\" | \"mid\" | \"late\";\n\nexport interface StageThresholdConfig {\n  stage: ColonyStage;\n  minRcl: number;\n  minEnergyCapacity: number;\n}\n\nexport const STAGE_THRESHOLDS: StageThresholdConfig[] = [\n  { stage: \"late\", minRcl: 6, minEnergyCapacity: 1800 },\n  { stage: \"mid\", minRcl: 4, minEnergyCapacity: 800 },\n  { stage: \"early\", minRcl: 2, minEnergyCapacity: 450 },\n  { stage: \"bootstrap\", minRcl: 0, minEnergyCapacity: 0 }\n];\n\nexport interface CapabilityFlags {\n  allowRoads: boolean;\n  allowTowers: boolean;\n  allowWalls: boolean;\n  allowRemoteMining: boolean;\n  allowExpansion: boolean;\n  allowOffense: boolean;\n}\r\n", "import { STAGE_THRESHOLDS, type CapabilityFlags, type ColonyStage } from \"../config/colonyStages\";\nimport type { RoomSnapshot } from \"./types\";\n\nfunction deriveStage(snapshot: RoomSnapshot): ColonyStage {\n  for (const threshold of STAGE_THRESHOLDS) {\n    if (snapshot.rcl >= threshold.minRcl && snapshot.energyCapacityAvailable >= threshold.minEnergyCapacity) {\n      return threshold.stage;\n    }\n  }\n\n  return \"bootstrap\";\n}\n\nfunction ownedRoomCount(): number {\n  return Object.values(Game.rooms).filter((room) => room.controller?.my).length;\n}\n\nfunction canExpand(snapshot: RoomSnapshot): boolean {\n  const gclLevel = Game.gcl.level;\n  const myRooms = ownedRoomCount();\n  return snapshot.rcl >= 4 && gclLevel > myRooms;\n}\n\nfunction canAttack(snapshot: RoomSnapshot): boolean {\n  return snapshot.rcl >= 6 && snapshot.storageEnergy >= 100000;\n}\n\nexport function deriveCapabilities(snapshot: RoomSnapshot, stage: ColonyStage): CapabilityFlags {\n  return {\n    allowRoads: stage !== \"bootstrap\",\n    allowTowers: snapshot.rcl >= 3,\n    allowWalls: snapshot.rcl >= 4,\n    allowRemoteMining: snapshot.rcl >= 3 && snapshot.energyCapacityAvailable >= 800,\n    allowExpansion: canExpand(snapshot),\n    allowOffense: canAttack(snapshot)\n  };\n}\n\nexport function deriveStageAndCapabilities(snapshot: RoomSnapshot): { stage: ColonyStage; capabilities: CapabilityFlags } {\n  const stage = deriveStage(snapshot);\n  const capabilities = deriveCapabilities(snapshot, stage);\n  return { stage, capabilities };\n}\r\n", "import type { ColonyStrategy } from \"./types\";\n\nfunction unique(values: string[]): string[] {\n  return [...new Set(values)];\n}\n\nfunction neighboringRooms(room: Room): string[] {\n  const exits = Game.map.describeExits(room.name);\n  if (!exits) return [];\n  return unique(Object.values(exits));\n}\n\nexport function deriveTargetRooms(room: Room, strategy: ColonyStrategy): ColonyStrategy {\n  const visibleNeighbors = neighboringRooms(room);\n\n  const scoutTargetRooms = visibleNeighbors;\n  const reserveTargetRooms = strategy.capabilities.allowRemoteMining ? visibleNeighbors : [];\n\n  const claimTargetRooms = strategy.capabilities.allowExpansion\n    ? visibleNeighbors.filter((name) => {\n        const targetRoom = Game.rooms[name];\n        if (!targetRoom?.controller) return true;\n        return !targetRoom.controller.owner && !targetRoom.controller.reservation;\n      })\n    : [];\n\n  const attackTargetRooms = strategy.capabilities.allowOffense\n    ? visibleNeighbors.filter((name) => {\n        const targetRoom = Game.rooms[name];\n        if (!targetRoom) return false;\n        return targetRoom.find(FIND_HOSTILE_CREEPS).length > 0;\n      })\n    : [];\n\n  return {\n    ...strategy,\n    scoutTargetRooms,\n    reserveTargetRooms,\n    claimTargetRooms,\n    attackTargetRooms\n  };\n}\r\n", "import { collectRoomSnapshot } from \"../colony/intel\";\nimport { deriveDesiredRoles } from \"../colony/spawnPlanner\";\nimport { deriveStageAndCapabilities } from \"../colony/stageManager\";\nimport { deriveTargetRooms } from \"../colony/strategyManager\";\nimport type { ColonyStrategy } from \"../colony/types\";\n\nexport function runColonyManager(): void {\n  for (const room of Object.values(Game.rooms)) {\n    if (!room.controller?.my) continue;\n\n    const snapshot = collectRoomSnapshot(room);\n    const { stage, capabilities } = deriveStageAndCapabilities(snapshot);\n    const desiredRoles = deriveDesiredRoles(snapshot, stage, capabilities);\n\n    const baseStrategy: ColonyStrategy = {\n      stage,\n      capabilities,\n      desiredRoles,\n      scoutTargetRooms: [],\n      reserveTargetRooms: [],\n      claimTargetRooms: [],\n      attackTargetRooms: []\n    };\n\n    const resolved = deriveTargetRooms(room, baseStrategy);\n\n    if (!Memory.strategy) {\n      Memory.strategy = {};\n    }\n\n    Memory.strategy[room.name] = resolved;\n  }\n}\r\n", "function placeIfFree(room: Room, x: number, y: number, structureType: BuildableStructureConstant): void {\n  if (x < 1 || x > 48 || y < 1 || y > 48) return;\n\n  const look = room.lookForAt(LOOK_STRUCTURES, x, y);\n  if (look.length > 0) return;\n\n  const sites = room.lookForAt(LOOK_CONSTRUCTION_SITES, x, y);\n  if (sites.length > 0) return;\n\n  room.createConstructionSite(x, y, structureType);\n}\n\nfunction placeExtensions(room: Room, anchor: RoomPosition): void {\n  const max = CONTROLLER_STRUCTURES[STRUCTURE_EXTENSION][room.controller?.level ?? 0] ?? 0;\n  const built = room.find(FIND_MY_STRUCTURES, {\n    filter: (structure: Structure) => structure.structureType === STRUCTURE_EXTENSION\n  }).length;\n  const sites = room.find(FIND_MY_CONSTRUCTION_SITES, {\n    filter: (site: ConstructionSite) => site.structureType === STRUCTURE_EXTENSION\n  }).length;\n\n  if (built + sites >= max) return;\n\n  const offsets: Array<[number, number]> = [\n    [2, 0],\n    [-2, 0],\n    [0, 2],\n    [0, -2],\n    [2, 2],\n    [2, -2],\n    [-2, 2],\n    [-2, -2],\n    [3, 1],\n    [3, -1],\n    [-3, 1],\n    [-3, -1],\n    [1, 3],\n    [-1, 3],\n    [1, -3],\n    [-1, -3]\n  ];\n\n  for (const [dx, dy] of offsets) {\n    if (built + sites >= max) break;\n    placeIfFree(room, anchor.x + dx, anchor.y + dy, STRUCTURE_EXTENSION);\n  }\n}\n\nfunction placeRoadsFromAnchor(room: Room, anchor: RoomPosition): void {\n  const controller = room.controller;\n  if (controller) {\n    const path = anchor.findPathTo(controller.pos, { ignoreCreeps: true });\n    for (const step of path) {\n      placeIfFree(room, step.x, step.y, STRUCTURE_ROAD);\n    }\n  }\n\n  const sources = room.find(FIND_SOURCES);\n  for (const source of sources) {\n    const path = anchor.findPathTo(source.pos, { ignoreCreeps: true });\n    for (const step of path) {\n      placeIfFree(room, step.x, step.y, STRUCTURE_ROAD);\n    }\n  }\n}\n\nfunction placeSourceContainers(room: Room, anchor: RoomPosition): void {\n  const sources = room.find(FIND_SOURCES);\n  for (const source of sources) {\n    const hasContainer = source.pos.findInRange(FIND_STRUCTURES, 1, {\n      filter: (structure: Structure) => structure.structureType === STRUCTURE_CONTAINER\n    }).length;\n\n    if (hasContainer > 0) continue;\n\n    const path = anchor.findPathTo(source.pos, { ignoreCreeps: true });\n    const finalStep = path[path.length - 1];\n    if (!finalStep) continue;\n\n    placeIfFree(room, finalStep.x, finalStep.y, STRUCTURE_CONTAINER);\n  }\n}\n\nfunction placeTowers(room: Room, anchor: RoomPosition): void {\n  const max = CONTROLLER_STRUCTURES[STRUCTURE_TOWER][room.controller?.level ?? 0] ?? 0;\n  if (max === 0) return;\n\n  const built = room.find(FIND_MY_STRUCTURES, {\n    filter: (structure: Structure) => structure.structureType === STRUCTURE_TOWER\n  }).length;\n  const sites = room.find(FIND_MY_CONSTRUCTION_SITES, {\n    filter: (site: ConstructionSite) => site.structureType === STRUCTURE_TOWER\n  }).length;\n\n  if (built + sites >= max) return;\n\n  placeIfFree(room, anchor.x + 3, anchor.y, STRUCTURE_TOWER);\n  placeIfFree(room, anchor.x - 3, anchor.y, STRUCTURE_TOWER);\n  placeIfFree(room, anchor.x, anchor.y + 3, STRUCTURE_TOWER);\n}\n\nfunction placeDefensiveRing(room: Room, anchor: RoomPosition): void {\n  for (let dx = -4; dx <= 4; dx += 1) {\n    for (let dy = -4; dy <= 4; dy += 1) {\n      const onEdge = Math.abs(dx) === 4 || Math.abs(dy) === 4;\n      if (!onEdge) continue;\n      placeIfFree(room, anchor.x + dx, anchor.y + dy, STRUCTURE_WALL);\n    }\n  }\n}\n\nexport function runConstructionManager(): void {\n  if (Game.time % 37 !== 0) return;\n\n  for (const room of Object.values(Game.rooms)) {\n    if (!room.controller?.my) continue;\n\n    const mySpawn = room.find(FIND_MY_SPAWNS)[0];\n    if (!mySpawn) continue;\n\n    const strategy = Memory.strategy?.[room.name];\n    if (!strategy) continue;\n\n    const siteCount = room.find(FIND_CONSTRUCTION_SITES).length;\n    if (siteCount > 10) continue;\n\n    const anchor = mySpawn.pos;\n    placeExtensions(room, anchor);\n    placeSourceContainers(room, anchor);\n\n    if (strategy.capabilities.allowRoads) {\n      placeRoadsFromAnchor(room, anchor);\n    }\n\n    if (strategy.capabilities.allowTowers) {\n      placeTowers(room, anchor);\n    }\n\n    if (strategy.capabilities.allowWalls) {\n      placeDefensiveRing(room, anchor);\n    }\n  }\n}\r\n", "export function runDefenseManager(): void {\n  const towers = _.filter(\n    Object.values(Game.structures),\n    (structure): structure is StructureTower => structure.structureType === STRUCTURE_TOWER && structure.my\n  );\n\n  for (const tower of towers) {\n    const closestHostile = tower.pos.findClosestByRange(FIND_HOSTILE_CREEPS);\n    if (closestHostile) {\n      tower.attack(closestHostile);\n      continue;\n    }\n\n    const wounded = tower.pos.findClosestByRange(FIND_MY_CREEPS, {\n      filter: (creep: Creep) => creep.hits < creep.hitsMax\n    });\n\n    if (wounded) {\n      tower.heal(wounded);\n      continue;\n    }\n\n    const repairTarget = tower.pos.findClosestByRange(FIND_STRUCTURES, {\n      filter: (structure: Structure) => {\n        if (structure.structureType === STRUCTURE_WALL || structure.structureType === STRUCTURE_RAMPART) {\n          return structure.hits < 200000;\n        }\n\n        return structure.hits < structure.hitsMax && structure.hits < 300000;\n      }\n    });\n\n    if (repairTarget) {\n      tower.repair(repairTarget);\n    }\n  }\n}\r\n", "import type { RoleName } from \"./roles\";\n\nexport interface BodyBlueprint {\n  min: BodyPartConstant[];\n  segment: BodyPartConstant[];\n  maxSegments: number;\n}\n\nexport const ROLE_BODIES: Record<RoleName, BodyBlueprint> = {\n  harvester: { min: [WORK, CARRY, MOVE], segment: [WORK, CARRY, MOVE], maxSegments: 6 },\n  hauler: { min: [CARRY, CARRY, MOVE], segment: [CARRY, CARRY, MOVE], maxSegments: 8 },\n  miner: { min: [WORK, WORK, MOVE], segment: [WORK, WORK, MOVE], maxSegments: 5 },\n  upgrader: { min: [WORK, CARRY, MOVE], segment: [WORK, CARRY, MOVE], maxSegments: 8 },\n  builder: { min: [WORK, CARRY, MOVE], segment: [WORK, CARRY, MOVE], maxSegments: 6 },\n  repairer: { min: [WORK, CARRY, MOVE], segment: [WORK, CARRY, MOVE], maxSegments: 5 },\n  waller: { min: [WORK, CARRY, MOVE], segment: [WORK, CARRY, MOVE], maxSegments: 7 },\n  scout: { min: [MOVE], segment: [MOVE], maxSegments: 1 },\n  reserver: { min: [CLAIM, MOVE], segment: [CLAIM, MOVE], maxSegments: 2 },\n  claimer: { min: [CLAIM, MOVE], segment: [CLAIM, MOVE], maxSegments: 1 },\n  soldier: { min: [TOUGH, MOVE, ATTACK, MOVE], segment: [TOUGH, MOVE, ATTACK, MOVE], maxSegments: 6 }\n};\r\n", "import type { RoleName } from \"./config/roles\";\n\nconst PART_COST: Record<BodyPartConstant, number> = {\n  move: 50,\n  work: 100,\n  carry: 50,\n  attack: 80,\n  ranged_attack: 150,\n  tough: 10,\n  heal: 250,\n  claim: 600\n};\n\nexport function bodyCost(body: BodyPartConstant[]): number {\n  return body.reduce((sum, part) => sum + PART_COST[part], 0);\n}\n\nexport function countRoleInRoom(roomName: string, role: RoleName): number {\n  let count = 0;\n  for (const creep of Object.values(Game.creeps)) {\n    if (creep.memory.homeRoom === roomName && creep.memory.role === role) {\n      count += 1;\n    }\n  }\n\n  return count;\n}\n\nexport function cleanupMemory(): void {\n  for (const name in Memory.creeps) {\n    if (!Game.creeps[name]) {\n      delete Memory.creeps[name];\n    }\n  }\n}\r\n", "import { ROLE_BODIES } from \"../config/bodyPlans\";\nimport { ROLE_ORDER, type RoleName } from \"../config/roles\";\nimport { bodyCost } from \"../utils\";\n\nfunction buildBody(role: RoleName, energyBudget: number): BodyPartConstant[] | null {\n  const blueprint = ROLE_BODIES[role];\n  const minCost = bodyCost(blueprint.min);\n  if (energyBudget < minCost) return null;\n\n  const body: BodyPartConstant[] = [...blueprint.min];\n  const segmentCost = bodyCost(blueprint.segment);\n\n  let segments = 1;\n  while (\n    segments < blueprint.maxSegments &&\n    body.length + blueprint.segment.length <= 50 &&\n    bodyCost(body) + segmentCost <= energyBudget\n  ) {\n    body.push(...blueprint.segment);\n    segments += 1;\n  }\n\n  return body;\n}\n\nfunction nextRoleToSpawn(spawn: StructureSpawn): RoleName | null {\n  const strategy = Memory.strategy?.[spawn.room.name];\n  if (!strategy) return null;\n\n  const current = Object.values(Game.creeps).filter((creep) => creep.memory.homeRoom === spawn.room.name);\n  if (current.length === 0) {\n    return \"harvester\";\n  }\n\n  for (const role of ROLE_ORDER) {\n    const desired = strategy.desiredRoles[role] ?? 0;\n    if (desired <= 0) continue;\n\n    const currentCount = current.filter((creep) => creep.memory.role === role).length;\n    if (currentCount < desired) {\n      return role;\n    }\n  }\n\n  return null;\n}\n\nexport function runSpawnManager(): void {\n  const spawns = Object.values(Game.spawns);\n  for (const spawn of spawns) {\n    if (spawn.spawning) continue;\n\n    const role = nextRoleToSpawn(spawn);\n    if (!role) continue;\n\n    const energyBudget = spawn.room.energyAvailable;\n    const body = buildBody(role, energyBudget);\n    if (!body) continue;\n\n    const name = `${role}-${spawn.room.name}-${Game.time}`;\n    spawn.spawnCreep(body, name, {\n      memory: {\n        role,\n        homeRoom: spawn.room.name,\n        working: false\n      }\n    });\n  }\n}\r\n", "export function moveToTarget(creep: Creep, target: RoomPosition | { pos: RoomPosition }, range = 1): void {\n  creep.moveTo(target, {\n    reusePath: 10,\n    maxRooms: 1,\n    range,\n    visualizePathStyle: { stroke: \"#8ecae6\" }\n  });\n}\n\nexport function moveToRoomCenter(creep: Creep, roomName: string): void {\n  const target = new RoomPosition(25, 25, roomName);\n  moveToTarget(creep, target, 20);\n}\r\n", "import { moveToTarget } from \"./movement\";\n\nexport function upgradeController(creep: Creep): boolean {\n  const controller = creep.room.controller;\n  if (!controller) return false;\n\n  const result = creep.upgradeController(controller);\n  if (result === ERR_NOT_IN_RANGE) {\n    moveToTarget(creep, controller);\n    return true;\n  }\n\n  return result === OK;\n}\n\nexport function buildNearestSite(creep: Creep): boolean {\n  const site = creep.pos.findClosestByPath(FIND_CONSTRUCTION_SITES);\n  if (!site) return false;\n\n  const result = creep.build(site);\n  if (result === ERR_NOT_IN_RANGE) {\n    moveToTarget(creep, site);\n    return true;\n  }\n\n  return result === OK;\n}\n\nexport function repairInfrastructure(creep: Creep): boolean {\n  const target = creep.pos.findClosestByPath(FIND_STRUCTURES, {\n    filter: (structure: Structure) => {\n      if (structure.hits >= structure.hitsMax) return false;\n      return structure.structureType === STRUCTURE_ROAD || structure.structureType === STRUCTURE_CONTAINER;\n    }\n  });\n\n  if (!target) return false;\n\n  const result = creep.repair(target);\n  if (result === ERR_NOT_IN_RANGE) {\n    moveToTarget(creep, target);\n    return true;\n  }\n\n  return result === OK;\n}\n\nexport function fortifyDefenses(creep: Creep, minWallHits: number): boolean {\n  const target = creep.pos.findClosestByPath(FIND_STRUCTURES, {\n    filter: (structure: Structure) => {\n      if (structure.structureType !== STRUCTURE_WALL && structure.structureType !== STRUCTURE_RAMPART) return false;\n      return structure.hits < minWallHits;\n    }\n  });\n\n  if (!target) return false;\n\n  const result = creep.repair(target);\n  if (result === ERR_NOT_IN_RANGE) {\n    moveToTarget(creep, target);\n    return true;\n  }\n\n  return result === OK;\n}\r\n", "import { moveToTarget } from \"./movement\";\n\nfunction assignSource(creep: Creep): Source | null {\n  if (creep.memory.sourceId) {\n    const source = Game.getObjectById(creep.memory.sourceId as Id<Source>);\n    if (source) return source;\n  }\n\n  const sources = creep.room.find(FIND_SOURCES);\n  if (sources.length === 0) return null;\n  const source = sources[Game.time % sources.length];\n  creep.memory.sourceId = source.id;\n  return source;\n}\n\nexport function harvestEnergy(creep: Creep): boolean {\n  const source = assignSource(creep);\n  if (!source) return false;\n\n  const result = creep.harvest(source);\n  if (result === ERR_NOT_IN_RANGE) {\n    moveToTarget(creep, source);\n    return true;\n  }\n\n  return result === OK;\n}\n\nexport function withdrawStoredEnergy(creep: Creep): boolean {\n  const target = creep.pos.findClosestByPath(FIND_STRUCTURES, {\n    filter: (structure: Structure) => {\n      if (structure.structureType === STRUCTURE_STORAGE || structure.structureType === STRUCTURE_CONTAINER) {\n        return (structure as StructureStorage | StructureContainer).store.getUsedCapacity(RESOURCE_ENERGY) > 0;\n      }\n      return false;\n    }\n  }) as StructureStorage | StructureContainer | null;\n\n  if (!target) return false;\n\n  const result = creep.withdraw(target, RESOURCE_ENERGY);\n  if (result === ERR_NOT_IN_RANGE) {\n    moveToTarget(creep, target);\n    return true;\n  }\n\n  return result === OK;\n}\n\nexport function pickupDroppedEnergy(creep: Creep): boolean {\n  const resource = creep.pos.findClosestByPath(FIND_DROPPED_RESOURCES, {\n    filter: (dropped: Resource) => dropped.resourceType === RESOURCE_ENERGY && dropped.amount > 50\n  });\n\n  if (!resource) return false;\n\n  const result = creep.pickup(resource);\n  if (result === ERR_NOT_IN_RANGE) {\n    moveToTarget(creep, resource);\n    return true;\n  }\n\n  return result === OK;\n}\n\nexport function fillPriorityEnergyTargets(creep: Creep): boolean {\n  const target = creep.pos.findClosestByPath(FIND_STRUCTURES, {\n    filter: (structure: Structure) => {\n      if (\n        structure.structureType === STRUCTURE_SPAWN ||\n        structure.structureType === STRUCTURE_EXTENSION ||\n        structure.structureType === STRUCTURE_TOWER\n      ) {\n        return (structure as StructureSpawn | StructureExtension | StructureTower).store.getFreeCapacity(RESOURCE_ENERGY) > 0;\n      }\n      return false;\n    }\n  }) as StructureSpawn | StructureExtension | StructureTower | null;\n\n  if (!target) return false;\n\n  const result = creep.transfer(target, RESOURCE_ENERGY);\n  if (result === ERR_NOT_IN_RANGE) {\n    moveToTarget(creep, target);\n    return true;\n  }\n\n  return result === OK;\n}\r\n", "import { harvestEnergy, pickupDroppedEnergy, withdrawStoredEnergy } from \"../tasks/energy\";\n\nexport function updateWorkingState(creep: Creep): void {\n  if (creep.memory.working && creep.store.getUsedCapacity(RESOURCE_ENERGY) === 0) {\n    creep.memory.working = false;\n  }\n\n  if (!creep.memory.working && creep.store.getFreeCapacity() === 0) {\n    creep.memory.working = true;\n  }\n}\n\nexport function acquireEnergy(creep: Creep): boolean {\n  return withdrawStoredEnergy(creep) || pickupDroppedEnergy(creep) || harvestEnergy(creep);\n}\r\n", "import { buildNearestSite, upgradeController } from \"../tasks/work\";\nimport { updateWorkingState, acquireEnergy } from \"./common\";\n\nexport function runBuilder(creep: Creep): void {\n  updateWorkingState(creep);\n\n  if (!creep.memory.working) {\n    acquireEnergy(creep);\n    return;\n  }\n\n  if (buildNearestSite(creep)) return;\n  upgradeController(creep);\n}\r\n", "import { moveToRoomCenter, moveToTarget } from \"./movement\";\n\nexport function reserveRoomController(creep: Creep, roomName: string): boolean {\n  if (creep.room.name !== roomName) {\n    moveToRoomCenter(creep, roomName);\n    return true;\n  }\n\n  const controller = creep.room.controller;\n  if (!controller) return false;\n\n  const result = creep.reserveController(controller);\n  if (result === ERR_NOT_IN_RANGE) {\n    moveToTarget(creep, controller);\n    return true;\n  }\n\n  return result === OK;\n}\n\nexport function claimRoomController(creep: Creep, roomName: string): boolean {\n  if (creep.room.name !== roomName) {\n    moveToRoomCenter(creep, roomName);\n    return true;\n  }\n\n  const controller = creep.room.controller;\n  if (!controller) return false;\n\n  const result = creep.claimController(controller);\n  if (result === ERR_NOT_IN_RANGE) {\n    moveToTarget(creep, controller);\n    return true;\n  }\n\n  return result === OK;\n}\n\nexport function attackInRoom(creep: Creep, roomName: string): boolean {\n  if (creep.room.name !== roomName) {\n    moveToRoomCenter(creep, roomName);\n    return true;\n  }\n\n  const hostile = creep.pos.findClosestByPath(FIND_HOSTILE_CREEPS);\n  if (hostile) {\n    const result = creep.attack(hostile);\n    if (result === ERR_NOT_IN_RANGE) {\n      moveToTarget(creep, hostile);\n      return true;\n    }\n\n    return result === OK;\n  }\n\n  const hostileStructure = creep.pos.findClosestByPath(FIND_HOSTILE_STRUCTURES, {\n    filter: (structure: Structure) => structure.structureType !== STRUCTURE_CONTROLLER\n  });\n\n  if (!hostileStructure) return false;\n\n  const result = creep.attack(hostileStructure);\n  if (result === ERR_NOT_IN_RANGE) {\n    moveToTarget(creep, hostileStructure);\n    return true;\n  }\n\n  return result === OK;\n}\r\n", "import { claimRoomController } from \"../tasks/combat\";\n\nexport function runClaimer(creep: Creep): void {\n  const targets = Memory.strategy?.[creep.memory.homeRoom]?.claimTargetRooms ?? [];\n  if (targets.length === 0) return;\n\n  const targetRoom = targets[0];\n  claimRoomController(creep, targetRoom);\n}\r\n", "import { fillPriorityEnergyTargets } from \"../tasks/energy\";\nimport { upgradeController } from \"../tasks/work\";\nimport { updateWorkingState, acquireEnergy } from \"./common\";\n\nexport function runHarvester(creep: Creep): void {\n  updateWorkingState(creep);\n\n  if (!creep.memory.working) {\n    acquireEnergy(creep);\n    return;\n  }\n\n  if (fillPriorityEnergyTargets(creep)) return;\n  upgradeController(creep);\n}\r\n", "import { fillPriorityEnergyTargets, pickupDroppedEnergy, withdrawStoredEnergy } from \"../tasks/energy\";\nimport { updateWorkingState } from \"./common\";\n\nfunction withdrawFromSourceContainers(creep: Creep): boolean {\n  const target = creep.pos.findClosestByPath(FIND_STRUCTURES, {\n    filter: (structure: Structure) => {\n      if (structure.structureType !== STRUCTURE_CONTAINER) return false;\n      const container = structure as StructureContainer;\n      return container.store.getUsedCapacity(RESOURCE_ENERGY) >= 100;\n    }\n  }) as StructureContainer | null;\n\n  if (!target) return false;\n\n  const result = creep.withdraw(target, RESOURCE_ENERGY);\n  if (result === ERR_NOT_IN_RANGE) {\n    creep.moveTo(target, { reusePath: 15, visualizePathStyle: { stroke: \"#219ebc\" } });\n    return true;\n  }\n\n  return result === OK;\n}\n\nexport function runHauler(creep: Creep): void {\n  updateWorkingState(creep);\n\n  if (!creep.memory.working) {\n    if (withdrawFromSourceContainers(creep)) return;\n    if (withdrawStoredEnergy(creep)) return;\n    pickupDroppedEnergy(creep);\n    return;\n  }\n\n  fillPriorityEnergyTargets(creep);\n}\r\n", "import { harvestEnergy } from \"../tasks/energy\";\n\nfunction sourceContainer(creep: Creep): StructureContainer | null {\n  const source = creep.memory.sourceId ? Game.getObjectById(creep.memory.sourceId) : null;\n  if (!source) return null;\n\n  const containers = source.pos.findInRange(FIND_STRUCTURES, 1, {\n    filter: (structure: Structure) => structure.structureType === STRUCTURE_CONTAINER\n  }) as StructureContainer[];\n\n  return containers[0] ?? null;\n}\n\nexport function runMiner(creep: Creep): void {\n  const container = sourceContainer(creep);\n  if (container && creep.pos.getRangeTo(container) > 0) {\n    creep.moveTo(container, { reusePath: 20, visualizePathStyle: { stroke: \"#ffb703\" } });\n    return;\n  }\n\n  harvestEnergy(creep);\n}\r\n", "import { repairInfrastructure, upgradeController } from \"../tasks/work\";\nimport { updateWorkingState, acquireEnergy } from \"./common\";\n\nexport function runRepairer(creep: Creep): void {\n  updateWorkingState(creep);\n\n  if (!creep.memory.working) {\n    acquireEnergy(creep);\n    return;\n  }\n\n  if (repairInfrastructure(creep)) return;\n  upgradeController(creep);\n}\r\n", "import { reserveRoomController } from \"../tasks/combat\";\n\nexport function runReserver(creep: Creep): void {\n  const targets = Memory.strategy?.[creep.memory.homeRoom]?.reserveTargetRooms ?? [];\n  if (targets.length === 0) return;\n\n  const targetRoom = targets[Game.time % targets.length];\n  reserveRoomController(creep, targetRoom);\n}\r\n", "import { moveToRoomCenter } from \"../tasks/movement\";\n\nexport function runScout(creep: Creep): void {\n  const targets = Memory.strategy?.[creep.memory.homeRoom]?.scoutTargetRooms ?? [];\n  if (targets.length === 0) return;\n\n  const targetRoom = targets[Game.time % targets.length];\n  if (creep.room.name !== targetRoom) {\n    moveToRoomCenter(creep, targetRoom);\n    return;\n  }\n\n  creep.moveTo(25, 25, { reusePath: 5 });\n}\r\n", "import { attackInRoom } from \"../tasks/combat\";\n\nexport function runSoldier(creep: Creep): void {\n  const targets = Memory.strategy?.[creep.memory.homeRoom]?.attackTargetRooms ?? [];\n  if (targets.length === 0) return;\n\n  const targetRoom = targets[Game.time % targets.length];\n  attackInRoom(creep, targetRoom);\n}\r\n", "import { upgradeController } from \"../tasks/work\";\nimport { updateWorkingState, acquireEnergy } from \"./common\";\n\nexport function runUpgrader(creep: Creep): void {\n  updateWorkingState(creep);\n\n  if (!creep.memory.working) {\n    acquireEnergy(creep);\n    return;\n  }\n\n  upgradeController(creep);\n}\r\n", "import { fortifyDefenses, upgradeController } from \"../tasks/work\";\nimport { updateWorkingState, acquireEnergy } from \"./common\";\n\nfunction wallHitTarget(room: Room): number {\n  const rcl = room.controller?.level ?? 1;\n  return rcl >= 8 ? 2000000 : rcl >= 6 ? 500000 : 100000;\n}\n\nexport function runWaller(creep: Creep): void {\n  updateWorkingState(creep);\n\n  if (!creep.memory.working) {\n    acquireEnergy(creep);\n    return;\n  }\n\n  if (fortifyDefenses(creep, wallHitTarget(creep.room))) return;\n  upgradeController(creep);\n}\r\n", "import { runBuilder } from \"./builder\";\nimport { runClaimer } from \"./claimer\";\nimport { runHarvester } from \"./harvester\";\nimport { runHauler } from \"./hauler\";\nimport { runMiner } from \"./miner\";\nimport { runRepairer } from \"./repairer\";\nimport { runReserver } from \"./reserver\";\nimport { runScout } from \"./scout\";\nimport { runSoldier } from \"./soldier\";\nimport { runUpgrader } from \"./upgrader\";\nimport { runWaller } from \"./waller\";\n\nexport function runRole(creep: Creep): void {\n  switch (creep.memory.role) {\n    case \"harvester\":\n      runHarvester(creep);\n      return;\n    case \"hauler\":\n      runHauler(creep);\n      return;\n    case \"miner\":\n      runMiner(creep);\n      return;\n    case \"upgrader\":\n      runUpgrader(creep);\n      return;\n    case \"builder\":\n      runBuilder(creep);\n      return;\n    case \"repairer\":\n      runRepairer(creep);\n      return;\n    case \"waller\":\n      runWaller(creep);\n      return;\n    case \"scout\":\n      runScout(creep);\n      return;\n    case \"reserver\":\n      runReserver(creep);\n      return;\n    case \"claimer\":\n      runClaimer(creep);\n      return;\n    case \"soldier\":\n      runSoldier(creep);\n      return;\n  }\n}\r\n"],
  "mappings": "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",
  "names": ["source", "result"]
}
